<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Core Erlang Optimizations - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Core Erlang Optimizations - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-8 offset-lg-2">
            <article class="card mb-4">
    <div class="card-header">
        <h3><a href="/erlang-org/blog/core-erlang-optimizations/">Core Erlang Optimizations</a></h3>
        <div class="date">May 18, 2018
             · by Björn Gustavsson
        </div>
    </div>

    <div class="card-body">
        
        
        
        <p>This blog post continues the exploration of Core Erlang by
looking at some optimizations done by the <code class="language-plaintext highlighter-rouge">sys_core_fold</code>
compiler pass. The Core Erlang language was introduced in
the <a href="http://blog.erlang.org/core-erlang-by-example/">previous blog post</a>.</p>

<p>To prepare the examples in this blog post I used two
commands.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ erlc +time +dcore core_fold_example.erl
Compiling "core_fold_example"
 parse_module                  :      0.000 s       9.4 kB
 transform_module              :      0.000 s       9.4 kB
 lint_module                   :      0.005 s       9.4 kB
 expand_records                :      0.000 s       9.4 kB
 core                          :      0.000 s      59.3 kB
 listing                       :      0.003 s      59.3 kB
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">dcore</code> option produces the file <code class="language-plaintext highlighter-rouge">core_fold_example.core</code>
containing a listing of the Core Erlang code produced by the <code class="language-plaintext highlighter-rouge">core</code>
parse (implemented by the module <code class="language-plaintext highlighter-rouge">v3_core</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ erlc +time +dcopt core_fold_example.erl
Compiling "core_fold_example"
 parse_module                  :      0.000 s       9.4 kB
 transform_module              :      0.000 s       9.4 kB
 lint_module                   :      0.002 s       9.4 kB
 expand_records                :      0.000 s       9.4 kB
 core                          :      0.000 s      59.3 kB
 sys_core_fold                 :      0.000 s      25.3 kB
 core_transforms               :      0.000 s      25.3 kB
 listing                       :      0.002 s      25.3 kB
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">dcopt</code> option produces the file <code class="language-plaintext highlighter-rouge">core_fold_example.copt</code>
containing a listing of the Core Erlang code as it looks
after optimization by the <code class="language-plaintext highlighter-rouge">sys_core_fold</code> pass.</p>

<p>As was mentioned in my first blog post about the compiler,
<code class="language-plaintext highlighter-rouge">compile:options()</code> will print most of the hidden options for
the compiler.</p>
      <h2 id="the-most-basic-optimization">
        
        
          The most basic optimization <a href="#the-most-basic-optimization">#</a>
        
        
      </h2>
    

<p>The most basic optimization done by <code class="language-plaintext highlighter-rouge">sys_core_fold</code> is constant propagation.</p>

<p>Consider this Erlang function:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">a</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nv">A</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
    <span class="p">{</span><span class="n">ok</span><span class="p">,</span><span class="nv">A</span><span class="p">}.</span>
</code></pre></div></div>

<p>It can be translated to Core Erlang like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'a'/0 =
    fun () -&gt;
       let &lt;A&gt; = 42
       in {'ok',A}
</code></pre></div></div>

<p>The variable <code class="language-plaintext highlighter-rouge">A</code> is bound to a constant (as opposed to an expression such
as function call). We can replace all occurrences of the variable <code class="language-plaintext highlighter-rouge">A</code> with
the constant value <code class="language-plaintext highlighter-rouge">42</code> and eliminate the <code class="language-plaintext highlighter-rouge">let</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'a'/0 =
    fun () -&gt;
	{'ok',42}
</code></pre></div></div>
      <h2 id="optimizing-case-expressions">
        
        
          Optimizing <code class="language-plaintext highlighter-rouge">case</code> expressions <a href="#optimizing-case-expressions">#</a>
        
        
      </h2>
    

<p>Actually, the first version of <code class="language-plaintext highlighter-rouge">a/0</code> that I showed was already
slightly optimized by me.</p>

<p>Here is the actual Core Erlang code (only slightly edited to
remove annotations and unnecessary line breaks):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'a'/0 =
    fun () -&gt;
        case &lt;&gt; of
	  &lt;&gt; when 'true' -&gt;
	      let &lt;A&gt; = 42
	      in {'ok',A}
	  &lt;&gt; when 'true' -&gt;
		primop 'match_fail'({'function_clause'})
	end
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">let</code> has been wrapped in a useless outer <code class="language-plaintext highlighter-rouge">case</code>. The
<code class="language-plaintext highlighter-rouge">case</code> would serve some purpose if there had been some function
arguments, but why complicate the code generator if <code class="language-plaintext highlighter-rouge">sys_core_fold</code> is
perfectly capable of simplifying this code?</p>

<p><code class="language-plaintext highlighter-rouge">sys_core_fold</code> will simplify the code in several steps.</p>

<p>First it will look at each clause. If a clause can’t possibly
be executed (for example, it its guard is <code class="language-plaintext highlighter-rouge">false</code>) it will be
dropped. If a clause will always match, all clauses following
the clause will be dropped.</p>

<p>In this case, the first clause will always match, because the
pattern is a list of no variables that can’t fail to match, and
the guard is <code class="language-plaintext highlighter-rouge">true</code>. Thus the second clause is unreachable and
is dropped:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'a'/0 =
    fun () -&gt;
        case &lt;&gt; of
	  &lt;&gt; when 'true' -&gt;
	      let &lt;A&gt; = 42
	      in {'ok',A}
	end
</code></pre></div></div>

<p>The next step is to see if there is only one clause remaining.
If it is, the body of the clause can be kept and the <code class="language-plaintext highlighter-rouge">case</code>
eliminated:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'a'/0 =
    fun () -&gt;
       let &lt;A&gt; = 42
       in {'ok',A}
</code></pre></div></div>
      <h2 id="another-case-example">
        
        
          Another case example <a href="#another-case-example">#</a>
        
        
      </h2>
    

<p>Let’s see how a more complicated function can be optimized
following the steps just described. Consider this Erlang
function:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">aa</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="n">tuple</span><span class="p">}</span> <span class="k">of</span>
	<span class="p">[</span><span class="nv">List</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="nv">List</span><span class="p">;</span>
	<span class="p">{</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">}</span> <span class="o">-&gt;</span>  <span class="p">{</span><span class="n">tuple</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">};</span>
	<span class="p">_</span> <span class="o">-&gt;</span>      <span class="n">something_else</span>
    <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>Translated to Core Erlang code (with the outer <code class="language-plaintext highlighter-rouge">case</code> and
annotations removed) it will look this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'aa'/0 =
    fun () -&gt;
      case {'a','tuple'} of
	&lt;[List|[]]&gt; when 'true' -&gt;
	    List
	&lt;{A,B}&gt; when 'true' -&gt;
	    {'tuple',A,B}
	&lt;_@c1&gt; when 'true' -&gt;
	    'something_else'
	&lt;_@c0&gt; when 'true' -&gt;
	    primop 'match_fail'({'case_clause',_@c0})
      end
</code></pre></div></div>

<p>Let’s go through the clauses one by one:</p>

<ul>
  <li>
    <p>The first clause will only match a list with exactly one element.
The <code class="language-plaintext highlighter-rouge">case</code> expression is a tuple, so the first clause can’t
possibly match. It will be dropped.</p>
  </li>
  <li>
    <p>The second clause will match a tuple with (any) two elements.
The case expression is a tuple with two elements, so this clause
will always match.</p>
  </li>
  <li>
    <p>There is no need to look at the remaining clauses, since the
second clause will always match. The remaining clauses are dropped.</p>
  </li>
</ul>

<p>We now have:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'aa'/0 =
    fun () -&gt;
      case {'a','tuple'} of
	&lt;{A,B}&gt; when 'true' -&gt;
	    {'tuple',A,B}
      end
</code></pre></div></div>

<p>This is a <code class="language-plaintext highlighter-rouge">case</code> with just one clause, so we can keep
the body of the clause and remove the <code class="language-plaintext highlighter-rouge">case</code>. But there is
a problem if we do that naively:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'aa'/0 =
    fun () -&gt;
       {'tuple',A,B}
</code></pre></div></div>

<p>The variables <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are used, but they don’t have
any values bound to them. We must use a <code class="language-plaintext highlighter-rouge">let</code> to bind
the variables before they can be used:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'aa'/0 =
    fun () -&gt;
      let &lt;A,B&gt; = &lt;'a','tuple'&gt;
      in {'tuple',A,B}
</code></pre></div></div>

<p>Propagating constants, the final code is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'aa'/0 =
    fun () -&gt;
	{'tuple','a','tuple'}
</code></pre></div></div>
      <h2 id="avoiding-tuple-building">
        
        
          Avoiding tuple building <a href="#avoiding-tuple-building">#</a>
        
        
      </h2>
    

<p>Here is an example of a common pattern of matching
several expressions in parallel:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">b</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="p">{</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">}</span> <span class="k">of</span>
	<span class="p">{</span><span class="n">true</span><span class="p">,</span><span class="n">false</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">ok</span><span class="p">;</span>
	<span class="p">{</span><span class="n">false</span><span class="p">,</span><span class="n">true</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">not_ok</span><span class="p">;</span>
	<span class="p">{_,_}</span> <span class="o">-&gt;</span> <span class="n">error</span>
    <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>The unoptimized Core Erlang code looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'b'/2 =
    fun (_@c1,_@c0) -&gt;
	case &lt;_@c1,_@c0&gt; of
	  &lt;A,B&gt; when 'true' -&gt;
	      case {A,B} of
		&lt;{'true','false'}&gt; when 'true' -&gt;
		    'ok'
		&lt;{'false','true'}&gt; when 'true' -&gt;
		    'not_ok'
		&lt;{_@c5,_@c6}&gt; when 'true' -&gt;
		    'error'
		&lt;_@c2&gt; when 'true' -&gt;
		      primop 'match_fail'({'case_clause',_@c2})
	      end
	end
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">case</code> expression is <code class="language-plaintext highlighter-rouge">{A,B}</code>. When executing the <code class="language-plaintext highlighter-rouge">case</code>
a tuple will built, and then almost immediately discarded.
That is wasteful. Therefore <code class="language-plaintext highlighter-rouge">sys_core_fold</code> rewrites the
code to eliminate the tuple building:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'b'/2 =
    fun (_@c1,_@c0) -&gt;
	case &lt;_@c1,_@c0&gt; of
	  &lt;'true','false'&gt; when 'true' -&gt;
	      'ok'
	  &lt;'false','true'&gt; when 'true' -&gt;
	      'not_ok'
	  &lt;_@c5,_@c6&gt; when 'true' -&gt;
	      'error'
	end
</code></pre></div></div>

<p>Here a value list is used instead of a tuple. (See
<a href="http://blog.erlang.org/core-erlang-by-example/">previous blog post</a>
for several examples of value lists.)</p>

<p>Another common pattern where tuples are built and immediately
discarded is shown in this example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">c</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">}</span> <span class="o">=</span> <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
		<span class="n">a1</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>
		<span class="n">b2</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="mi">20</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>
		<span class="p">_</span> <span class="o">-&gt;</span>  <span class="p">{</span><span class="mi">100</span><span class="p">,</span><span class="mi">42</span><span class="p">}</span>
	    <span class="k">end</span><span class="p">,</span>
    <span class="nv">A</span><span class="o">+</span><span class="nv">B</span><span class="p">.</span>
</code></pre></div></div>

<p>The unoptimized Core Erlang code looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'c'/1 =
    fun (_@c0) -&gt;
	case _@c0 of
	  &lt;X&gt; when 'true' -&gt;
	      let &lt;_@c2&gt; =
		  case X of
		    &lt;'a1'&gt; when 'true' -&gt;
			{10,1}
		    &lt;'b2'&gt; when 'true' -&gt;
			{20,2}
		    &lt;_@c5&gt; when 'true' -&gt;
			{100,42}
		    &lt;_@c1&gt; when 'true' -&gt;
			  primop 'match_fail'({'case_clause',_@c1})
		  end
	      in
		  case _@c2 of
		    &lt;{A,B}&gt; when 'true' -&gt;
			call 'erlang':'+'(A, B)
		    &lt;_@c3&gt; when 'true' -&gt;
			  primop 'match_fail'({'badmatch',_@c3})
		  end
	  &lt;_@c4&gt; when 'true' -&gt;
		  primop 'match_fail'({'function_clause',_@c4})
	end
</code></pre></div></div>

<p>Here a tuple is built and assigned to <code class="language-plaintext highlighter-rouge">_@c2</code>. It is then matched
in a <code class="language-plaintext highlighter-rouge">case</code>.</p>

<p>First the code is optimized like this to eliminate the tuple building
in each clause of the first <code class="language-plaintext highlighter-rouge">case</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'c'/1 =
    fun (_@c0) -&gt;
	let &lt;_@f4,_@f5&gt; =
	    case _@c0 of
	      &lt;'a1'&gt; when 'true' -&gt;
		  &lt;10,1&gt;
	      &lt;'b2'&gt; when 'true' -&gt;
		  &lt;20,2&gt;
	      &lt;_@c5&gt; when 'true' -&gt;
		  &lt;100,42&gt;
	    end
	in
            let &lt;_@c2&gt; = {_@f4,_@f5}
            in
	          case _@c2 of
		    &lt;{A,B}&gt; when 'true' -&gt;
			call 'erlang':'+'(A, B)
		    &lt;_@c3&gt; when 'true' -&gt;
			  primop 'match_fail'({'badmatch',_@c3})
		  end
	end
</code></pre></div></div>

<p>Applying all of the optimizations previously described,
the remaining tuple building and matching can be eliminated:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'c'/1 =
    fun (_@c0) -&gt;
	let &lt;_@f4,_@f5&gt; =
	    case _@c0 of
	      &lt;'a1'&gt; when 'true' -&gt;
		  &lt;10,1&gt;
	      &lt;'b2'&gt; when 'true' -&gt;
		  &lt;20,2&gt;
	      &lt;_@c5&gt; when 'true' -&gt;
		  &lt;100,42&gt;
	    end
	in
	    call 'erlang':'+'(_@f4, _@f5)
</code></pre></div></div>
      <h2 id="conclusion">
        
        
          Conclusion <a href="#conclusion">#</a>
        
        
      </h2>
    

<p>That was a quick look at some of the optimizations done by
<code class="language-plaintext highlighter-rouge">sys_core_fold</code>.</p>

<p>Some of the optimizations are very simple. The power of the
<code class="language-plaintext highlighter-rouge">sys_core_fold</code> pass comes from the combination of optimizations.  One
optimization gives opportunities for other optimizations, as could be
seen in the examples.</p>
      <h2 id="points-to-ponder">
        
        
          Points to Ponder <a href="#points-to-ponder">#</a>
        
        
      </h2>
    

<p>Why is the optimization pass called <code class="language-plaintext highlighter-rouge">sys_core_fold</code>?</p>

<p>A hint can be found in the title of this Wikipedia article:
<a href="https://en.wikipedia.org/wiki/Constant_folding">Constant folding</a>.</p>

        
    </div>
</article>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-c.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-bash.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>