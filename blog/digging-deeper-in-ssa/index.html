<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Digging deeper in SSA - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Digging deeper in SSA - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-8 offset-lg-2">
            <article class="card mb-4">
    <div class="card-header">
        <h3><a href="/erlang-org/blog/digging-deeper-in-ssa/">Digging deeper in SSA</a></h3>
        <div class="date">September 20, 2018
             · by Björn Gustavsson
        </div>
    </div>

    <div class="card-body">
        
        
        
        <p>This blog post continues the exploration of the <a href="https://github.com/erlang/otp/pull/1935">new SSA-based
intermediate representation</a> through multiple examples. Make
sure to read the <a href="http://blog.erlang.org/introducing-ssa/">Introduction to SSA</a> if you missed it.</p>
      <h2 id="calling-a-bif-that-may-fail">
        
        
          Calling a BIF that may fail <a href="#calling-a-bif-that-may-fail">#</a>
        
        
      </h2>
    

<p>The first example calls a guard BIF that may fail with
an exception:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">element_body</span><span class="p">(</span><span class="nv">T</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nb">element</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span>
</code></pre></div></div>

<p>The (optimized) SSA code looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function blog:element_body(_0) {
0:
  %% blog.erl:5
  _1 = bif:element literal 2, _0
  @ssa_bool = succeeded _1
  br @ssa_bool, label 3, label 1

3:
  ret _1

1:
  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg
  ret @ssa_ret
}
</code></pre></div></div>

<p>Let’s go through the code a few lines at a time:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  %% blog.erl:5
  _1 = bif:element literal 2, _0
  @ssa_bool = succeeded _1
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">bif:element</code> instruction calls the guard BIF <code class="language-plaintext highlighter-rouge">element/2</code>, assigning
the value to the variable <code class="language-plaintext highlighter-rouge">_1</code> if the call is successful.</p>

<p>What if the call is not successful?</p>

<p>The <code class="language-plaintext highlighter-rouge">succeeded _1</code> instruction tests whether the previous instruction
assigning to <code class="language-plaintext highlighter-rouge">_1</code> was successful. <code class="language-plaintext highlighter-rouge">true</code> will be assigned to <code class="language-plaintext highlighter-rouge">@ssa_bool</code>
if the second element of the tuple was successfully fetched from the tuple,
and <code class="language-plaintext highlighter-rouge">false</code> will be assigned otherwise.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  br @ssa_bool, label 3, label 1
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">br</code> instruction tests whether <code class="language-plaintext highlighter-rouge">@ssa_bool</code> is <code class="language-plaintext highlighter-rouge">true</code>. If <code class="language-plaintext highlighter-rouge">true</code>, execution
continues at block 3, which returns the value of the second element from the
tuple. If <code class="language-plaintext highlighter-rouge">false</code>, execution continues at block 1.</p>

<p>It was mentioned in the <a href="http://blog.erlang.org/introducing-ssa/">previous blog post</a> that block 1 is a
special block that the SSA code generator always emits. In the
previous examples, it was never referenced and therefore removed by
one of the optimization passes.</p>

<p>In this example, it is used as the target when the call to <code class="language-plaintext highlighter-rouge">element/2</code> fails.</p>

<p>The BEAM code generator treats references to block 1 specially. Here follows the
BEAM code for the function. As usual, I have omitted the function header.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  %% Block 0.
  {line,[{location,"blog.erl",5}]}.
  {bif,element,{f,0},[{integer,2},{x,0}],{x,0}}.
  return.
</code></pre></div></div>

<p>Note that no code has been generated for block 1.</p>

<p>The <code class="language-plaintext highlighter-rouge">line</code> instructions gives the file name and line number of the source file.
It will be used in the stack backtrace if the following instruction fails.</p>

<p>The <code class="language-plaintext highlighter-rouge">bif</code> instruction calls the given guard BIF, <code class="language-plaintext highlighter-rouge">element/2</code> in this case.
The <code class="language-plaintext highlighter-rouge">{f,0}</code> operand gives the action to take if the <code class="language-plaintext highlighter-rouge">element/2</code> fails. The number
<code class="language-plaintext highlighter-rouge">0</code> is a special case, meaning that a <code class="language-plaintext highlighter-rouge">badarg</code> exception should be raised if the
call of <code class="language-plaintext highlighter-rouge">element/2</code> fails.</p>
      <h2 id="a-failing-bif-call-in-a-guard">
        
        
          A failing BIF call in a guard <a href="#a-failing-bif-call-in-a-guard">#</a>
        
        
      </h2>
    

<p>In the next example, <code class="language-plaintext highlighter-rouge">element/2</code> is called in a guard:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">element_guard</span><span class="p">(</span><span class="nv">T</span><span class="p">)</span> <span class="k">when</span> <span class="nb">element</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nv">T</span><span class="p">)</span> <span class="o">=:=</span> <span class="n">true</span> <span class="o">-&gt;</span>
    <span class="n">ok</span><span class="p">;</span>
<span class="nf">element_guard</span><span class="p">(_)</span> <span class="o">-&gt;</span>
    <span class="n">error</span><span class="p">.</span>
</code></pre></div></div>

<p>The SSA code looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function blog:element_guard(_0) {
0:
  %% blog.erl:7
  _1 = bif:element literal 2, _0
  @ssa_bool = succeeded _1
  br @ssa_bool, label 4, label 3

4:
  @ssa_bool:5 = bif:'=:=' _1, literal true
  br @ssa_bool:5, label 6, label 3

6:
  ret literal ok

3:
  ret literal error
}
</code></pre></div></div>

<p>The first two instructions in block 0 are the same as in the previous
example.  The <code class="language-plaintext highlighter-rouge">br</code> instruction has different labels, though. The
failure label refers to block 3, which returns the value <code class="language-plaintext highlighter-rouge">error</code>. The
success label continues execution at block 4.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4:
  @ssa_bool:5 = bif:'=:=' _1, literal true
  br @ssa_bool:5, label 6, label 3
</code></pre></div></div>

<p>Block 4 is the translation of <code class="language-plaintext highlighter-rouge">=:= true</code> part of the Erlang code.
If the second element in the tuple is equal to <code class="language-plaintext highlighter-rouge">true</code>, execution
continues at block 6, which returns the value <code class="language-plaintext highlighter-rouge">ok</code>. Otherwise
execution continues at block 3, which returns the value <code class="language-plaintext highlighter-rouge">error</code>.</p>

<p>Here is the BEAM code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  {bif,element,{f,5},[{integer,2},{x,0}],{x,0}}.
  {test,is_eq_exact,{f,5},[{x,0},{atom,true}]}.
  {move,{atom,ok},{x,0}}.
  return.
{label,5}.
  {move,{atom,error},{x,0}}.
  return.
</code></pre></div></div>

<p>In the <code class="language-plaintext highlighter-rouge">bif</code> instruction, <code class="language-plaintext highlighter-rouge">{f,5}</code> means that execution should
continue at label 5 if the <code class="language-plaintext highlighter-rouge">element/2</code> call fails. Otherwise
execution will continue at the next instruction.</p>
      <h2 id="our-first-case">
        
        
          Our first case <a href="#our-first-case">#</a>
        
        
      </h2>
    

<p>Here is the next example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">case1</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
        <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">;</span>
        <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">_</span> <span class="o">-&gt;</span> <span class="n">c</span>
    <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>Translated to SSA code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function blog:case1(_0) {
0:
  switch _0, label 3, [ { literal 2, label 5 }, { literal 1, label 4 } ]

4:
  ret literal a

5:
  ret literal b

3:
  ret literal c
}
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">switch</code> instruction is a multi-way branch to one of any number of
other blocks, based on the value of a variable. In this example, it
branches based on the value of the variable <code class="language-plaintext highlighter-rouge">_0</code>. If <code class="language-plaintext highlighter-rouge">_0</code> is equal
to 2, execution continues at block 5. If <code class="language-plaintext highlighter-rouge">_0</code> is equal to 1,
execution continues at block 4. If the value is not equal to any
of the values in the switch list, execution continues at the block
referred to by the failure label, in this example block 3.</p>

<p>The BEAM code looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  {select_val,{x,0},{f,10},{list,[{integer,2},{f,9},{integer,1},{f,8}]}}.
{label,8}.
  {move,{atom,a},{x,0}}.
  return.
{label,9}.
  {move,{atom,b},{x,0}}.
  return.
{label,10}.
  {move,{atom,c},{x,0}}.
  return.
</code></pre></div></div>
      <h2 id="terminators">
        
        
          Terminators <a href="#terminators">#</a>
        
        
      </h2>
    

<p>As mentioned in the <a href="http://blog.erlang.org/introducing-ssa/">previous blog post</a>, the last instruction in a block is
called a <em>terminator</em>. A terminator either returns from the function or transfers
control to another block. With the introduction of <code class="language-plaintext highlighter-rouge">switch</code>, the terminator story
is complete. To summarize, a block can end in one of the following terminators:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ret</code> to return a value from the function.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">br</code> to either branch to another block (one-way branch), or branch to one
of two possible other blocks based on a variable (two-way branch).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">switch</code> to branch to one of any number of other blocks.</p>
  </li>
</ul>
      <h2 id="another-case">
        
        
          Another case <a href="#another-case">#</a>
        
        
      </h2>
    

<p>Here is a slightly different example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">case2</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
        <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">;</span>
        <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">;</span>
        <span class="mi">3</span> <span class="o">-&gt;</span> <span class="n">c</span>
    <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>In this case, <code class="language-plaintext highlighter-rouge">X</code> must be one of the integers 1, 2, or 3. Otherwise, there will
be a <code class="language-plaintext highlighter-rouge">{case_clause,X}</code> exception. Here is the SSA code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function blog:case2(_0) {
0:
  switch _0, label 3, [ { literal 3, label 6 }, { literal 2, label 5 }, { literal 1, label 4 } ]

4:
  ret literal a

5:
  ret literal b

6:
  ret literal c

3:
  _2 = put_tuple literal case_clause, _0

  %% blog.erl:20
  @ssa_ret:7 = call remote (literal erlang):(literal error)/1, _2
  ret @ssa_ret:7
}
</code></pre></div></div>

<p>The failure label for the <code class="language-plaintext highlighter-rouge">switch</code> is 3. Block 3 builds the <code class="language-plaintext highlighter-rouge">{case_clause,X}</code>
tuple and calls <code class="language-plaintext highlighter-rouge">erlang:error/1</code>.</p>

<p>Here is the BEAM code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  {select_val,{x,0},
              {f,16},
              {list,[{integer,3},
                     {f,15},
                     {integer,2},
                     {f,14},
                     {integer,1},
                     {f,13}]}}.
{label,13}.
  {move,{atom,a},{x,0}}.
  return.
{label,14}.
  {move,{atom,b},{x,0}}.
  return.
{label,15}.
  {move,{atom,c},{x,0}}.
  return.
{label,16}.
  {line,[{location,"blog.erl",20}]}.
  {case_end,{x,0}}.
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">case_end</code> instruction is an optimization to save space. It is shorter than
the equivalent:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  {test_heap,3,1}.
  {put_tuple2,{x,0},{list,[{atom,case_clause},{x,0}]}}.
  {line,[{location,"blog.erl",20}]}.
  {call_ext_only,1,{extfunc,erlang,error,1}}.
</code></pre></div></div>

<p>(The <code class="language-plaintext highlighter-rouge">put_tuple2</code> instruction was introduced in
<a href="https://github.com/erlang/otp/pull/1947">#1947: Introduce a put_tuple2 instruction</a>, which was recently merged
to <code class="language-plaintext highlighter-rouge">master</code>.)</p>
      <h2 id="our-final-case">
        
        
          Our final case <a href="#our-final-case">#</a>
        
        
      </h2>
    

<p>It’s time to address the kind of <code class="language-plaintext highlighter-rouge">case</code> similar to what was teased at the
end of the previous blog post.</p>

<p>In this example, the variable <code class="language-plaintext highlighter-rouge">Y</code> will be assigned different values in
each clause of the <code class="language-plaintext highlighter-rouge">case</code>:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">case3a</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
        <span class="n">zero</span> <span class="o">-&gt;</span>
            <span class="nv">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">something</span> <span class="o">-&gt;</span>
            <span class="nv">Y</span> <span class="o">=</span> <span class="nv">X</span><span class="p">;</span>
        <span class="p">_</span> <span class="o">-&gt;</span>
            <span class="nv">Y</span> <span class="o">=</span> <span class="n">no_idea</span>
    <span class="k">end</span><span class="p">,</span>
    <span class="p">{</span><span class="n">ok</span><span class="p">,</span><span class="nv">Y</span><span class="p">}.</span>
</code></pre></div></div>

<p>Perhaps a more common way to write this <code class="language-plaintext highlighter-rouge">case</code> would be:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">case3b</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Y</span> <span class="o">=</span> <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
            <span class="n">zero</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">something</span> <span class="o">-&gt;</span> <span class="nv">X</span><span class="p">;</span>
            <span class="p">_</span> <span class="o">-&gt;</span> <span class="n">no_idea</span>
        <span class="k">end</span><span class="p">,</span>
    <span class="p">{</span><span class="n">ok</span><span class="p">,</span><span class="nv">Y</span><span class="p">}.</span>
</code></pre></div></div>

<p>In either case, the problem remains. Static Single Assignment means that each
variable can only be given a value once. So how can this example be translated
to SSA code?</p>

<p>Here follows the SSA code for <code class="language-plaintext highlighter-rouge">case3a/1</code>. The SSA code for <code class="language-plaintext highlighter-rouge">case3b/1</code> is almost
identical except for variable naming.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function blog:case3a(_0) {
0:
  switch _0, label 4, [ { literal something, label 6 }, { literal zero, label 5 } ]

5:
  br label 3

6:
  br label 3

4:
  br label 3

3:
  Y = phi { literal no_idea, 4 }, { literal 0, 5 }, { _0, 6 }
  _7 = put_tuple literal ok, Y
  ret _7
}
</code></pre></div></div>

<p>Let’s jump right to the interesting (and confusing) part of the code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3:
  Y = phi { literal no_idea, 4 }, { literal 0, 5 }, { _0, 6 }
</code></pre></div></div>

<p>Clearly, <code class="language-plaintext highlighter-rouge">Y</code> is only given a value once, so the SSA property is
preserved.</p>

<p>That’s good, but exactly what is the value that is being assigned?</p>

<p>The name of the instruction is <code class="language-plaintext highlighter-rouge">phi</code>, which is the name of the
Greek letter <a href="https://en.wikipedia.org/wiki/Phi">φ</a>. Having an unusual name, the instruction
deserves to have unusual operands, too. Each operand is a pair, the
first element in the pair being a value and the second element a block
number of a predecessor block. The value of the <code class="language-plaintext highlighter-rouge">phi</code> node will be one
of the values from one the pairs. But from which pair? That depends on
the number of the previous block that branched to the <code class="language-plaintext highlighter-rouge">phi</code> instruction.</p>

<p>To make that somewhat clearer, let’s look at all operands:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">{ literal no_idea, 4 }</code>: If the number of block that executed <code class="language-plaintext highlighter-rouge">br label 3</code>
was 4, the value of the <code class="language-plaintext highlighter-rouge">phi</code> instruction will be the value in this pair,
that is, the atom <code class="language-plaintext highlighter-rouge">no_idea</code>. The failure label for the <code class="language-plaintext highlighter-rouge">switch</code> instruction
is 4, so this pair will be chosen when <code class="language-plaintext highlighter-rouge">_0</code> does not match any of the values
in the switch list.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">{ literal 0, 5 }</code>: If the number of block that executed <code class="language-plaintext highlighter-rouge">br label 3</code>
was 5, the value of the <code class="language-plaintext highlighter-rouge">phi</code> instruction will be the integer 0. The
<code class="language-plaintext highlighter-rouge">switch</code> instruction will transfer control to block 5 if the value of
<code class="language-plaintext highlighter-rouge">_0</code> is the atom <code class="language-plaintext highlighter-rouge">zero</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">{ _0, 6 }</code>: Finally, if <code class="language-plaintext highlighter-rouge">_0</code> is the atom <code class="language-plaintext highlighter-rouge">something</code>, the <code class="language-plaintext highlighter-rouge">switch</code>
will transfer control to block 6, which will transfer control to
block 3. The value of the <code class="language-plaintext highlighter-rouge">phi</code> instruction will be the value of the
variable <code class="language-plaintext highlighter-rouge">_0</code>.</p>
  </li>
</ul>

<p>The concept of <code class="language-plaintext highlighter-rouge">phi</code> instructions probably feels a bit strange at
first sight (and at second sight), and one might also think they
must be terribly inefficient.</p>

<p>Leaving the strangeness aside, let’s talk about the efficiency. <code class="language-plaintext highlighter-rouge">phi</code>
instructions is a fiction convenient for representing and optimizing
the code. When translating to BEAM code, the <code class="language-plaintext highlighter-rouge">phi</code> instructions are
eliminated.</p>

<p>Here follows an example that is <strong>not</strong> SSA code, because it assigns
the variable <code class="language-plaintext highlighter-rouge">Y</code> three times, but gives an idea how the <code class="language-plaintext highlighter-rouge">phi</code>
instruction is eliminated:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%% Not SSA code!
function blog:case3a(_0) {
0:
  switch _0, label 4, [ { literal something, label 6 }, { literal zero, label 5 } ]

5:
  Y := literal 0
  br label 3

6:
  Y := _0
  br label 3

4:
  Y := no_idea
  br label 3

3:
  _7 = put_tuple literal ok, Y
  ret _7
}
</code></pre></div></div>

<p>The BEAM code generator (<code class="language-plaintext highlighter-rouge">beam_ssa_codegen</code>) does a similar rewrite
during code generation.</p>

<p>Here is the unoptimized BEAM code, slightly edited for clarity:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%% Block 0.
{select_val,{x,0},
            {f,53},
            {list,[{atom,something},{f,55},{atom,zero},{f,57}]}}.

%% Block 5.
{label,57}.
  {move,{integer,0},{x,0}}.
  {jump,{f,59}}.

%% Block 6.
{label,55}.
  %% The result is already in {x,0}.
  {jump,{f,59}}.

%% Block 4.
{label,53}.
  {move,{atom,no_idea},{x,0}}.
  {jump,{f,59}}.

%% Block 3.
{label,59}.
   {test_heap,3,1}.
   {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.
   return.
</code></pre></div></div>

<p>Here is the final BEAM code after some more optimizations:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{label,18}.
  {select_val,{x,0},
              {f,20},
              {list,[{atom,something},{f,21},{atom,zero},{f,19}]}}.
{label,19}.
  {move,{integer,0},{x,0}}.
  {jump,{f,21}}.
{label,20}.
  {move,{atom,no_idea},{x,0}}.
{label,21}.
  {test_heap,3,1}.
  {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.
  return.
</code></pre></div></div>
      <h2 id="the-cold-case">
        
        
          The cold case <a href="#the-cold-case">#</a>
        
        
      </h2>
    

<p>Here is the example from the end of the previous blog post:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">bar</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
        <span class="n">none</span> <span class="o">-&gt;</span>
            <span class="nv">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">_</span> <span class="o">-&gt;</span>
            <span class="nv">Y</span> <span class="o">=</span> <span class="nv">X</span>
    <span class="k">end</span><span class="p">,</span>
    <span class="nv">Y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">.</span>
</code></pre></div></div>

<p>And here is the SSA code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function blog:bar(_0) {
0:
  @ssa_bool = bif:'=:=' _0, literal none
  br @ssa_bool, label 5, label 4

5:
  br label 3

4:
  br label 3

3:
  Y = phi { _0, 4 }, { literal 0, 5 }

  %% blog.erl:52
  _6 = bif:'+' Y, literal 1
  @ssa_bool:6 = succeeded _6
  br @ssa_bool:6, label 7, label 1

7:
  ret _6

1:
  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg
  ret @ssa_ret
}
</code></pre></div></div>

<p>It is left as an exercise to the reader to read and understand the code.</p>

<p>Here is the BEAM code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{label,28}.
  {test,is_eq_exact,{f,29},[{x,0},{atom,none}]}.
  {move,{integer,0},{x,0}}.
{label,29}.
  {line,[{location,"blog.erl",52}]}.
  {gc_bif,'+',{f,0},1,[{x,0},{integer,1}],{x,0}}.
  return.
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">gc_bif</code> instruction calls a guard BIF that might need to do a
garbage collection. Since integers can be of essentially unlimited
size in Erlang, the result of <code class="language-plaintext highlighter-rouge">+</code> might not fit in a word. The
<code class="language-plaintext highlighter-rouge">1</code> following <code class="language-plaintext highlighter-rouge">{f,0}</code> is the number of registers that must be
preserved; in this case, only <code class="language-plaintext highlighter-rouge">{x,0}</code>.</p>

        
    </div>
</article>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-c.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-bash.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>