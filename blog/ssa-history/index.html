<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"SSA History - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>SSA History - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-8 offset-lg-2">
            <article class="card mb-4">
    <div class="card-header">
        <h3><a href="/erlang-org/blog/ssa-history/">SSA History</a></h3>
        <div class="date">September 28, 2018
             · by Björn Gustavsson
        </div>
    </div>

    <div class="card-body">
        
        
        
        <p>This blog post looks back on the development of
the <a href="https://github.com/erlang/otp/pull/1935">SSA-based intermediate representation</a>
from the beginning of this year to the end
of August when the branch was merged.</p>
      <h2 id="january-2018">
        
        
          January 2018 <a href="#january-2018">#</a>
        
        
      </h2>
    

<p>In January this year we realized that we have reached
the limit of the optimizations that we could do working
on BEAM code.</p>

<p><a href="https://github.com/jhogberg">John</a> had finished the work on extending <a href="https://github.com/erlang/otp/blob/2e40d8d1c51ad1c3d3750490ecac6b290233f085/lib/compiler/src/beam_bsm.erl"><code class="language-plaintext highlighter-rouge">beam_bsm</code></a>
(a pass that attempts to <a href="http://erlang.org/doc/efficiency_guide/binaryhandling.html#matching-binaries">delay creation of sub
binaries</a>). The extended <code class="language-plaintext highlighter-rouge">beam_bsm</code> pass could apply the
optimization in a few more cases than it could before, but the amount
of code in <code class="language-plaintext highlighter-rouge">beam_bsm</code> to achieve that modest improvement of the
optimization was insane.</p>

<p>John, <a href="https://github.com/garazdawi">Lukas</a>, and I discussed what we should do about
it. Clearly, we needed a better intermediate format. But what should
it be? Could we use the existing BEAM code but with variables instead of
BEAM registers and do register allocation later? That would solve
some of the problems but not all of them. The irregular nature of
BEAM instructions makes it cumbersome to traverse and analyze
BEAM code.</p>

<p>So we decided to do like most modern compilers and use an <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a>-based
intermediate format.</p>
      <h3 id="rewrites-are-scary">
        
        
          Rewrites are scary! <a href="#rewrites-are-scary">#</a>
        
        
      </h3>
    

<p>Introducing a new intermediate format would require rewriting at
least some parts of the compiler. The problem with rewrites is
that they always take longer time than expected and that they often
get abandoned before they are finished.</p>

<p>To increase the odds that this rewrite would be successful, we come
up with this plan to do the minimum amount of work to get something working
as soon as possible:</p>

<ol>
  <li>
    <p>Write a new pass that translates from <a href="http://blog.erlang.org/beam-compiler-history#r6b-enter-kernel-erlang">Kernel Erlang</a> to SSA code.</p>
  </li>
  <li>
    <p>Write a new pass that translates from SSA code to BEAM code.</p>
  </li>
  <li>
    <p>Keep all existing optimization passes.</p>
  </li>
  <li>
    <p>Rewrite the optimization passes one at a time.</p>
  </li>
</ol>

<p>It didn’t quite work out according to the plan, as will soon be evident.</p>
      <h2 id="february-2018">
        
        
          February 2018 <a href="#february-2018">#</a>
        
        
      </h2>
    

<p>I made the first the commit February 1 this year.</p>
      <h3 id="beam_kernel_to_ssa">
        
        
          beam_kernel_to_ssa <a href="#beam_kernel_to_ssa">#</a>
        
        
      </h3>
    

<p>The first pass I wrote was the translator from Kernel Erlang to SSA code.
We named it <code class="language-plaintext highlighter-rouge">beam_kernel_to_ssa</code>.</p>

<p>My first thought was to write the pass from scratch, as opposed to
base it on <code class="language-plaintext highlighter-rouge">v3_codegen</code>. After all, there are fundamental differences
between BEAM code and SSA code. BEAM code is a flat list of instructions.
SSA code consists of blocks of numbered blocks stored in a map, and there
are also the phi nodes.</p>

<p>On the other hand, the input for both <code class="language-plaintext highlighter-rouge">v3_codegen</code> and
<code class="language-plaintext highlighter-rouge">beam_kernel_to_ssa</code> was Kernel Erlang. There was nothing wrong with
the code that handled the Kernel Erlang records and I didn’t want to
rewrite that code from scratch.  Instead, I rewrote the part of the
code that produced a list of BEAM instructions to produce a list of
SSA instructions.  I then wrote a simple pass (about 100 lines of
code) that <a href="https://github.com/erlang/otp/blob/6bee2ac7d11668888d93ec4f93730bcae3e5fa79/lib/compiler/src/beam_kernel_to_ssa.erl#L1231">packaged the SSA instructions into blocks and added the
phi nodes</a>.</p>
      <h3 id="testing-beam_kernel_to_ssa">
        
        
          Testing beam_kernel_to_ssa <a href="#testing-beam_kernel_to_ssa">#</a>
        
        
      </h3>
    

<p>I prefer to test the code I write a soon as possible after writing it.
It is much easier to find and fix bugs in code that has been recently
written.</p>

<p>How can one test <code class="language-plaintext highlighter-rouge">beam_kernel_to_ssa</code> before the code generator for
BEAM code has been written?</p>

<p>One cannot, not completely, but there are ways to find major problems.</p>

<p>One such way is <a href="https://en.wikipedia.org/wiki/Smoke_testing_(software)">smoke testing</a>. I modified
the compiler so that it would first run <code class="language-plaintext highlighter-rouge">beam_kernel_to_ssa</code> but
discard its output, then run <code class="language-plaintext highlighter-rouge">v3_codegen</code> and the rest of the compiler
passes. That allowed me to run the entire compiler test suite, and
if the <code class="language-plaintext highlighter-rouge">beam_kernel_to_ssa</code> pass crashed, I’ve had found a bug.</p>

<p>Another way was to write a validator or linter of the SSA code.
<a href="https://github.com/jhogberg">John</a> wrote the <code class="language-plaintext highlighter-rouge">beam_ssa_lint</code> pass (actually called
<code class="language-plaintext highlighter-rouge">beam_ssa_validator</code> at that time and later renamed), which would
verify that a variable was only defined once, that variables were
defined before they were used, that labels in terminators and phi
nodes referred to defined blocks, and so on. It helped me find a
few bugs.</p>

<p><a href="http://erlang.org/doc/apps/dialyzer/index.html">Dialyzer</a> also helped me find some bugs. I made sure
that I added types for all fields in all new records and
specifications for all exported functions. Dialyzer pointed out
some bugs when I ran it and thinking about the types when writing
the <code class="language-plaintext highlighter-rouge">-type</code> declarations was also useful.</p>
      <h3 id="finishing-beam_kernel_to_ssa">
        
        
          Finishing beam_kernel_to_ssa <a href="#finishing-beam_kernel_to_ssa">#</a>
        
        
      </h3>
    

<p>I am not sure exactly how long time I spent on the initial
implementation of <code class="language-plaintext highlighter-rouge">beam_kernel_to_ssa</code>, but it was probably less
than two weeks. There were a few snags along the way, most of
them bugs in <code class="language-plaintext highlighter-rouge">v3_kernel</code> that did not cause any problems
with the old <code class="language-plaintext highlighter-rouge">v3_codegen</code>.</p>

<p>Here is an example. I chose to fix it in OTP 21 even though it was
harmless in that release:</p>

<p><a href="https://github.com/erlang/otp/commit/c896f08f5c028b1e31290e6a5502597401acd39f">v3_kernel: Stop ensuring one return value in #k_try{}</a></p>
      <h3 id="beam_ssa_pre_codegen">
        
        
          beam_ssa_pre_codegen <a href="#beam_ssa_pre_codegen">#</a>
        
        
      </h3>
    

<p>Next up was the translation from SSA code to BEAM code.</p>

<p>I have already decided that the translation was sufficiently complicated
that to better be split into two major passes.</p>

<p>The first pass of those passes,
<a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl"><code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code></a>, would work on the SSA
code, rewriting it, and adding annotations for another pass that would
generate the BEAM code, but the output would still be valid SSA code
so that <code class="language-plaintext highlighter-rouge">ssa_lint</code> could be used to validate the output. The pretty-printed
SSA code also includes the annotations to facilitate debugging.</p>

<p>The <code class="language-plaintext highlighter-rouge">dprecg</code> option can be used to produce a pretty-printed listing of
the SSA code. The following command will create the file <code class="language-plaintext highlighter-rouge">blog.precodegen</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>erlc +dprecg blog.erl
</code></pre></div></div>

<p>The next section will dig deeper into the workings of <code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code>.
On a first reading, you might want to skip that section and jump ahead to
the section about <a href="#beam_ssa_codegen">beam_ssa_codegen</a>.</p>
      <h3 id="digging-deeper-in-beam_ssa_pre_codegen">
        
        
          Digging deeper in beam_ssa_pre_codegen <a href="#digging-deeper-in-beam_ssa_pre_codegen">#</a>
        
        
      </h3>
    

<p>To provide some context for the description of <code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code>,
we will first look at some BEAM code and talk about stack frames and
Y registers.</p>

<p>Here is the example in Erlang:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">foo</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span> <span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Sum</span> <span class="o">=</span> <span class="nn">lists</span><span class="p">:</span><span class="nf">sum</span><span class="p">(</span><span class="nv">L</span><span class="p">),</span>
    <span class="nv">C</span> <span class="o">+</span> <span class="nv">Sum</span><span class="p">.</span>
</code></pre></div></div>

<p>The BEAM code looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{allocate,1,2}.
{move,{x,0},{y,0}}.
{move,{x,1},{x,0}}.
{line,[{location,"blog.erl",5}]}.
{call_ext,1,{extfunc,lists,sum,1}}.
{line,[{location,"blog.erl",6}]}.
{gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.
{deallocate,1}.
return.
</code></pre></div></div>

<p>As usual, we will walk through the code one or a few lines at a time.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{allocate,1,2}.
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">allocate</code> instruction allocates a stack frame. The <code class="language-plaintext highlighter-rouge">1</code> operand
means that there should be room for one slot in the stack frame for
storing one value.  The slots in the stack frame are called <em>Y
registers</em>.</p>

<p>The <code class="language-plaintext highlighter-rouge">2</code> operand means that two X registers (<code class="language-plaintext highlighter-rouge">{x,0}</code> and <code class="language-plaintext highlighter-rouge">{x,1}</code>) are
live and must be preserved if <code class="language-plaintext highlighter-rouge">allocate</code> needs to do a garbage
collection in order to allocate space for the stack frame.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{move,{x,0},{y,0}}.
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">C</code> argument for <code class="language-plaintext highlighter-rouge">foo/2</code> is in <code class="language-plaintext highlighter-rouge">{x,0}</code>. The <code class="language-plaintext highlighter-rouge">move</code> instruction
copies the value of <code class="language-plaintext highlighter-rouge">{x,0}</code> to <code class="language-plaintext highlighter-rouge">{y,0}</code>, which is the zeroth slot
in the stack frame. The reason for doing this copy will soon become
clear.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{move,{x,1},{x,0}}.
</code></pre></div></div>

<p>Preparing for the call of <code class="language-plaintext highlighter-rouge">lists:sum/1</code>, the value of <code class="language-plaintext highlighter-rouge">L</code> in <code class="language-plaintext highlighter-rouge">{x,1}</code>
is copied to <code class="language-plaintext highlighter-rouge">{x,0}</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{line,[{location,"blog.erl",5}]}.
{call_ext,1,{extfunc,lists,sum,1}}.
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">lists:sum/1</code> is called. The argument is in <code class="language-plaintext highlighter-rouge">{x,0}</code>. The result
(the sum of all numbers in the list) is returned in <code class="language-plaintext highlighter-rouge">{x,0}</code>. Also,
the contents of all other X registers are destroyed. That means that
any value that is to be used after a function call must be saved to
a Y register.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.
</code></pre></div></div>

<p>This instruction calculates the sum of <code class="language-plaintext highlighter-rouge">C</code> (in <code class="language-plaintext highlighter-rouge">{y,0}</code>) and <code class="language-plaintext highlighter-rouge">Sum</code> (in <code class="language-plaintext highlighter-rouge">{x,0}</code>),
storing the result in <code class="language-plaintext highlighter-rouge">{x,0}</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{deallocate,1}.
</code></pre></div></div>

<p>Preparing to return from the function, the <code class="language-plaintext highlighter-rouge">deallocate</code> instruction
removes the stack frame that <code class="language-plaintext highlighter-rouge">allocate</code> created.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return.
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">return</code> returns from the function. The return value is in <code class="language-plaintext highlighter-rouge">{x,0}</code>.</p>

<p>Here is the SSA code for the function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function blog:foo(_0, _1) {
0:
  %% blog.erl:5
  _2 = call remote (literal lists):(literal sum)/1, _1

  %% blog.erl:5
  _3 = bif:'+' _0, _2
  @ssa_bool = succeeded _3
  br @ssa_bool, label 3, label 1

3:
  ret _3

1:
  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg
  ret @ssa_ret
}
</code></pre></div></div>

<p>After running <code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code>, the SSA code looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function blog:foo(x0/_0, x1/_1) {
  %% _0: 0..1
  %% _1: 0..1 0..3
%% #{frame_size =&gt; 1,yregs =&gt; [0]}
0:
  %% _0:4: 1..5
  [1] y0/_0:4 = copy x0/_0

  %% blog.erl:5
  %% _2: 3..5
  [3] x0/_2 = call remote (literal lists):(literal sum)/1, x1/_1

  %% blog.erl:5
  %% _3: 5..11
  [5] x0/_3 = bif:'+' y0/_0:4, x0/_2

  %% @ssa_bool: 7..9
  [7] z0/@ssa_bool = succeeded x0/_3
  [9] br z0/@ssa_bool, label 3, label 1

3:
  [11] ret x0/_3

1:
  %% @ssa_ret: 13..15
  [13] x0/@ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg
  [15] ret x0/@ssa_ret
}
</code></pre></div></div>

<p>We will describe what the important (for this example) sub passes of
<code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code> do, and point to the relevant part of code while
doing so.</p>

<p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L715">place_frames</a> determines where stack frames should be allocated.
In the example, block 0 needs a stack frame.</p>

<p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1114">find_yregs</a> determines which variables that are to be
placed in Y registers. The result will be a <code class="language-plaintext highlighter-rouge">yregs</code> annotation added
to each block that allocates a stack frame. For this example, the
annotation will look like:</p>

<pre class="highlight">
    %% #{frame_size =&gt; 1,<b>yregs =&gt; [0]</b>}
</pre>

<p>Variable <code class="language-plaintext highlighter-rouge">_0</code> is <code class="language-plaintext highlighter-rouge">C</code> from the Erlang code. It needs to be saved across the
call to <code class="language-plaintext highlighter-rouge">lists:sum/1</code>.</p>

<p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1645">reserve_yregs</a> uses the <code class="language-plaintext highlighter-rouge">yregs</code> annotations and inserts <code class="language-plaintext highlighter-rouge">copy</code> instructions
to copy each variable that needs saving to a new variable. For the example,
the following instruction will be added</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [1] y0/_0:4 = copy x0/_0
</code></pre></div></div>
<p>It copies the value of <code class="language-plaintext highlighter-rouge">_0</code> to <code class="language-plaintext highlighter-rouge">_0:4</code>.</p>

<p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1487">number_instructions</a> numbers all instructions as a preparation for register
allocation. In the listing, those numbers are in brackets before each instruction:
<code class="language-plaintext highlighter-rouge">[1]</code>, <code class="language-plaintext highlighter-rouge">[3]</code>, <code class="language-plaintext highlighter-rouge">[5]</code>, and so on.</p>

<p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1515">live_intervals</a> calculates the intervals in which each variable is live.
In the listing, the live intervals are shown as comments before the definition
of the variable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  %% _0:4: 1..5
  [1] y0/_0:4 = copy x0/_0
</code></pre></div></div>

<p>The variable <code class="language-plaintext highlighter-rouge">_0:4</code> is live from instruction <code class="language-plaintext highlighter-rouge">[1]</code> (its definition) to
<code class="language-plaintext highlighter-rouge">[5]</code> (its last use).</p>

<p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L2118">linear_scan</a> uses the <a href="http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf">linear scan</a> algorithm
to allocate registers for each variable. The result is saved as annotation
for the function. In the listing of the SSA code, the register will be added
to the definition and each use of a variable. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [1] y0/_0:4 = copy x0/_0
</code></pre></div></div>

<p>Variable <code class="language-plaintext highlighter-rouge">_0</code> (the argument <code class="language-plaintext highlighter-rouge">L</code>) is in <code class="language-plaintext highlighter-rouge">{x,0}</code>. Its copy in <code class="language-plaintext highlighter-rouge">_0:4</code> is in
<code class="language-plaintext highlighter-rouge">{y,0}</code>.</p>

<p>But what is <code class="language-plaintext highlighter-rouge">z0</code>?</p>

<pre class="highlight">
      [7] <b>z0</b>/@ssa_bool = succeeded x0/_3
      [9] br <b>z0</b>/@ssa_bool, label 3, label 1
</pre>

<p><code class="language-plaintext highlighter-rouge">succeeded</code> is not a BEAM instruction. It will be combined with the previous
instruction (<code class="language-plaintext highlighter-rouge">bif:+</code> in this example) and the <code class="language-plaintext highlighter-rouge">br</code> instruction that follows it
to the following BEAM instruction:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.
</code></pre></div></div>

<p>Thus, the value <code class="language-plaintext highlighter-rouge">@ssa_bool</code> is never explicitly stored in a BEAM
register.  Before I invented Z registers, <code class="language-plaintext highlighter-rouge">@ssa_bool</code> would have been
assigned to an X register.  That worked most of the time, but sometimes
an X register would seem to be occupied when it was not, and prevent
another instruction from using that register.</p>

<p>Here are the <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L52">references that I used when implementing linear scan</a>.</p>

<p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1741">frame_size</a> uses the information from the linear scan pass to calculate the size
of each stack frame. The result is stored as an annotation:</p>

<pre class="highlight">
    %% #{<b>frame_size =&gt; 1</b>,yregs =&gt; [0]}
</pre>
      <h3 id="beam_ssa_codegen">
        
        
          beam_ssa_codegen <a href="#beam_ssa_codegen">#</a>
        
        
      </h3>
    

<p>The <a href="https://github.com/erlang/otp/blob/ec1f35c9f52be894ba295b9a48237020855e3c46/lib/compiler/src/beam_ssa_codegen.erl"><code class="language-plaintext highlighter-rouge">beam_ssa_codegen</code></a> pass generates BEAM code
from the annotated SSA code. Testing of this pass was easier, because
I could compile some sample code and try to run it.</p>

<p>Often I did not even have to run the code to know that it was wrong.
The compiler would tell me, loudly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>blog: function bar/2+4:
  Internal consistency check failed - please report this bug.
  Instruction: {test_heap,2,3}
  Error:       {{x,2},not_live}:
</code></pre></div></div>

<p>It’s time to introduce the <code class="language-plaintext highlighter-rouge">beam_validator</code> pass.</p>
      <h4 id="beam_validator">
        
        
          beam_validator <a href="#beam_validator">#</a>
        
        
      </h4>
    

<p>The <a href="https://github.com/erlang/otp/blob/e2a939dc4d23d75a0588722d0a08aef129b4c0be/lib/compiler/src/beam_validator.erl"><code class="language-plaintext highlighter-rouge">beam_validator</code></a> pass was introduced in one of
the R10B releases (probably in 2006). It is run directly before the
BEAM code is packaged into a binary and written to a BEAM file. The
purpose of <code class="language-plaintext highlighter-rouge">beam_validator</code> is to find unsafe instructions that
could crash the runtime system or cause it to misbehave in other
ways.</p>

<p>Let’s look at a simple example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">bar</span><span class="p">(</span><span class="nv">H</span><span class="p">,</span> <span class="nv">T</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">].</span>
</code></pre></div></div>

<p>Here is the BEAM code, but edited by me to contain an unsafe instruction:</p>

<pre class="highlight">
      {label,4}.
        {test_heap,2,<b>3</b>}.
        {put_list,{x,0},{x,1},{x,0}}.
        return.
</pre>

<p>The number of live registers is here given as <code class="language-plaintext highlighter-rouge">3</code> instead of <code class="language-plaintext highlighter-rouge">2</code>.
That means that <code class="language-plaintext highlighter-rouge">{x,0}</code>, <code class="language-plaintext highlighter-rouge">{x,1}</code>, and <code class="language-plaintext highlighter-rouge">{x,2}</code> are supposed to contain
valid Erlang terms. Because <code class="language-plaintext highlighter-rouge">bar/2</code> is only called with two arguments,
<code class="language-plaintext highlighter-rouge">{x,2}</code> can contain any old garbage.</p>

<p>When running this code, it could crash the runtime system, or it could
be completely harmless. It depends on whether there will be a garbage
collection during execution of the <code class="language-plaintext highlighter-rouge">test_heap</code> instruction, and on the
exact nature of the garbage in <code class="language-plaintext highlighter-rouge">{x,2}</code>. For example, if the garbage
happens to be an atom nothing bad will happen. That means that this
type of compiler bug is difficult to reliably catch in a test case.</p>

<p><code class="language-plaintext highlighter-rouge">beam_validator</code> will find this bug immediately. It keeps track of
which registers are initialized at any point in the function. If it
finds a reference to a register that is not initialized it will
complain:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>blog: function bar/2+4:
  Internal consistency check failed - please report this bug.
  Instruction: {test_heap,2,3}
  Error:       {{x,2},not_live}:
</code></pre></div></div>
      <h4 id="friend-and-foe">
        
        
          Friend and foe <a href="#friend-and-foe">#</a>
        
        
      </h4>
    

<p>During the implementation of <code class="language-plaintext highlighter-rouge">beam_ssa_codegen</code>, the <code class="language-plaintext highlighter-rouge">beam_validator</code>
pass pointed out many bugs for me. It was my friend.</p>

<p>It was also my foe, sort of. It would complain that some perfectly safe
code was unsafe. When that happened, I had to thoroughly investigate the
code to make doubly sure it was safe, and then extend <code class="language-plaintext highlighter-rouge">beam_validator</code>
to make it smarter so that it would understand that the code was safe.</p>

<p>Here is one example where I had to make <code class="language-plaintext highlighter-rouge">beam_validator</code> smarter.
Consider this code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{move,{x,0},{y,0}}.
{test,is_map,{f,777},[{x,0}]}.
{put_map_assoc,{f,0},{y,0},...}.
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">move</code> instruction stores a copy of <code class="language-plaintext highlighter-rouge">{x,0}</code> in <code class="language-plaintext highlighter-rouge">{y,0}</code> (a location
on the stack). The following <code class="language-plaintext highlighter-rouge">test</code> instruction tests whether <code class="language-plaintext highlighter-rouge">{x,0}</code>
is a map and branches to label 777 if not. The <code class="language-plaintext highlighter-rouge">put_map_assoc</code> instruction
updates the map in <code class="language-plaintext highlighter-rouge">{y,0}</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">put_map_assoc</code> instruction will crash if its source argument is
not a map.  Therefore, <code class="language-plaintext highlighter-rouge">beam_validator</code> complains if <code class="language-plaintext highlighter-rouge">put_map_assoc</code> is
used with a source argument that is not a map. In this example,
<code class="language-plaintext highlighter-rouge">beam_validator</code> had not seen a <code class="language-plaintext highlighter-rouge">test</code> instruction that ensured that
<code class="language-plaintext highlighter-rouge">{y,0}</code> was a map, so it complained. It is obvious (for a human) that
<code class="language-plaintext highlighter-rouge">{y,0}</code> is a map because it is a copy of <code class="language-plaintext highlighter-rouge">{x,0}</code>, which is a map.</p>

<p><code class="language-plaintext highlighter-rouge">v3_codegen</code> never generated such code; in fact, it explicitly
<a href="https://github.com/erlang/otp/blob/64422fcac9c602641dcf24ef2d35e3491376304d/lib/compiler/src/v3_codegen.erl#L1600">avoided generating such code</a>.
I did not want to add similar kludges to the new code generator, so
<a href="https://github.com/erlang/otp/commit/1f221b27f1336e747f7409692f260055dd3ddf79"><code class="language-plaintext highlighter-rouge">beam_validator</code> had to become smarter</a>.</p>
      <h4 id="unsafe-optimization-passes">
        
        
          Unsafe optimization passes <a href="#unsafe-optimization-passes">#</a>
        
        
      </h4>
    

<p>Some of the unsafe code that <code class="language-plaintext highlighter-rouge">beam_validator</code> found was really unsafe,
but it was not the fault of my new compiler passes, but of the
optimization passes that optimized the generated BEAM code.</p>

<p>The problem was that some of the optimization passes had implicit
assumptions of the kind of code that <code class="language-plaintext highlighter-rouge">v3_codegen</code> would generate
(or, rather, would <strong>not</strong> generate). The new code generator broke
those assumptions.</p>

<p>At first, when I saw those bugs, I removed the broken part of the
optimization pass. Making the optimizations safe would be non-trivial
and ultimately wasted work because we intended to rewrite all those
optimization passes to work on SSA code.</p>

<p>When I have seen a few too many of those unsafe optimizations, <a href="https://github.com/erlang/otp/commit/3fc40fd57fa01b097b4c363860c4d4762e13db8b">I ripped
out all of the unsafe optimization passes</a>.</p>

<p>That meant that we would have to re-implement all of the optimizations
before the generated code would be as good as the code from the old
compiler. I had also noticed that the new BEAM code generator in a
few ways generated better code than the old one, but in other ways the
code was worse. For example, the generated code used more stack space and
did a lot of register shuffling. Eventually, that had to be addressed in
some way.</p>

<p>Meanwhile, I had worse problems to worry about.</p>
      <h2 id="march-2018">
        
        
          March 2018 <a href="#march-2018">#</a>
        
        
      </h2>
    

<p>On March 14 I presented my progress on the new compiler passes for
the OTP team. One of my slides had the following text:</p>

<blockquote>
  <ul>
    <li>Can compile all modules in OTP (and run many of them correctly)</li>
  </ul>
</blockquote>

<p>Yes, I had finished the initial implementation of <code class="language-plaintext highlighter-rouge">beam_ssa_codegen</code>
so that I could compile all code in OTP.</p>

<p>The problem that I only at hinted in the slide was that Erlang could
crash and dump core when running test suites. Not every time, and
never in the same test case twice. It only happened when I have
compiled OTP with the new compiler.</p>

<p>The crash didn’t seem related to the test cases themselves, but to the
writing of log files. I soon narrowed it down to that the crash could
happen if <a href="https://github.com/erlang/otp/blob/OTP-21.0.9/lib/kernel/src/file_io_server.erl"><code class="language-plaintext highlighter-rouge">file_io_server</code></a> had been compiled with
the new compiler passes. However, that was not much help. The module
contains complicated code that uses the binary syntax, <code class="language-plaintext highlighter-rouge">try</code>/<code class="language-plaintext highlighter-rouge">catch</code>,
and <code class="language-plaintext highlighter-rouge">receive</code>, all of which are complicated instructions that might
not be correctly translated by the new compiler passes.</p>

<p><code class="language-plaintext highlighter-rouge">beam_validator</code> was supposed to catch those kinds of bugs before
they can cause a crash. Either there was some kind of bug that
<code class="language-plaintext highlighter-rouge">beam_validator</code> didn’t look for, or there was a bug in the
implementation of some of the instructions in the BEAM interpreter.</p>

<p>I ended up spending the rest of March trying to hunt down that bug.</p>
      <h2 id="april-2018">
        
        
          April 2018 <a href="#april-2018">#</a>
        
        
      </h2>
    

<p>At the beginning of April, the bug still eluded me. I had narrowed
it down somewhat. I was pretty sure it had something to do with
<code class="language-plaintext highlighter-rouge">receive</code>.</p>

<p>Then <a href="https://github.com/rickard-green">Rickard</a> gave me some information that I could connect to another
piece of information that I had absorbed during my hunt for the bug.</p>
      <h3 id="the-bug">
        
        
          The bug <a href="#the-bug">#</a>
        
        
      </h3>
    

<p>This section is somewhat advanced, and if you wish you can
skip to <a href="#the-fix">the fix</a>.</p>

<p>Reading about the <a href="https://github.com/erlang/otp/blob/OTP-21.0.9/erts/emulator/internal_doc/GarbageCollection.md">Erlang Garbage Collector</a> can give some
background to better understand this section.</p>

<p>Rickard reminded me about the <code class="language-plaintext highlighter-rouge">message_queue_data</code> option that
had been added to <a href="http://erlang.org/doc/man/erlang.html#process_flag-2"><code class="language-plaintext highlighter-rouge">process_flag/2</code></a> in OTP 19. After
calling <code class="language-plaintext highlighter-rouge">process_flag(message_queue_data, off_heap)</code> all messages
that have not yet been received would be stored outside the process
heap. Storing the messages outside the heap means that the garbage
collector doesn’t have to spend time copying the unreceived messages
during garbage collection, which can be a huge win for processes that
have many messages in its message queue.</p>

<p>The implementations details of messages outside the heap are
crucial. Consider this selective <code class="language-plaintext highlighter-rouge">receive</code>:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">receive</span>
    <span class="p">{</span><span class="n">tagged_message</span><span class="p">,</span><span class="nv">Message</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nv">Message</span>
<span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>When the BEAM interpreter executes this code, it will retrieve a
reference message from the external message queue and match it against
the tuple pattern. If the message does not match, the next message
will be processed in the same way, and so on.</p>

<p>If a message does not match, there <strong>must not</strong> be any remaining
references to it stored on the stack. The reason is that if there is a
garbage collection, the garbage collector will copy the message (or
part of the message) to the heap, and, even worse, it will destroy the
original message during the copy operation. The message is still in
the external message queue, but it has now been corrupted by the
garbage collector. If the message is later matched out in a <code class="language-plaintext highlighter-rouge">receive</code>,
it will likely cause a crash.</p>

<p>When Rickard first implemented off-heap messages, he asked me whether
the compiler could ever store references to unreceived messages
on the stack. I assured him that it could not happen.</p>

<p>Yes, that was true, it could not happen because of the way
<code class="language-plaintext highlighter-rouge">v3_codegen</code> generated the code for <code class="language-plaintext highlighter-rouge">receive</code>.</p>

<p>With the new compiler passes, <a href="https://github.com/erlang/otp/blob/333e4c5a1406cdeb9d1d5cf9bf4a4fadb232fca8/lib/compiler/test/beam_validator_SUITE_data/receive_stacked.S#L22">it <strong>could</strong> happen</a>. When
I first discussed the bug with Richard in March, he did mention that
it is forbidden to store references to off-heap messages on the
stack. At that time, I was not aware that the compiler could store
references to off-heap messages on the stack.</p>

<p>When Rickard reminded me about that for the second time in April, I remember
seeing during my bug hunt generated code that stored off-heap message
references on the stack.</p>
      <h3 id="the-fix">
        
        
          The fix <a href="#the-fix">#</a>
        
        
      </h3>
    

<p>After finding the reason for the bug, I first taught <code class="language-plaintext highlighter-rouge">beam_validator</code>
to <a href="https://github.com/erlang/otp/commit/90853d8e7b50be13a3b71f4a1ed6b0407e1f7c2f">complain about “fragile references” on the stack</a>.
I included that commit in OTP 21.</p>

<p>I then added a sub pass to <code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code> to <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L919">rewrite <code class="language-plaintext highlighter-rouge">receive</code></a>.
It introduces new variables and <code class="language-plaintext highlighter-rouge">copy</code> instructions to ensure that
any references to the message being matched are kept in X registers.</p>

<p>With no known bugs in the code generator, I could start rewriting the optimization
passes I had removed.</p>
      <h3 id="more-optimizations">
        
        
          More optimizations <a href="#more-optimizations">#</a>
        
        
      </h3>
    
      <h4 id="beam_ssa_recv">
        
        
          beam_ssa_recv <a href="#beam_ssa_recv">#</a>
        
        
      </h4>
    

<p><a href="https://github.com/erlang/otp/blob/367f4a3fabb12cda3f2547e9908acbf28cb34e3a/lib/compiler/src/beam_ssa_recv.erl"><code class="language-plaintext highlighter-rouge">beam_ssa_recv</code></a> is a replacement for the unsafe
<a href="https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_receive.erl"><code class="language-plaintext highlighter-rouge">beam_receive</code></a> pass.  The purpose is to optimize a
<code class="language-plaintext highlighter-rouge">receive</code> that can only match a newly created reference.  The
optimization avoids scanning the messages that were placed in the
message queue before the reference was created.</p>

<p>I actually wrote <code class="language-plaintext highlighter-rouge">beam_ssa_recv</code> at the beginning of March as an
experiment to see how easy it would be to write optimizations of SSA code.
It turned out to be pretty easy. <code class="language-plaintext highlighter-rouge">beam_ssa_recv</code> can apply the optimization
in more places than <code class="language-plaintext highlighter-rouge">beam_receive</code> could, using slightly less code.</p>

<p>In the old <code class="language-plaintext highlighter-rouge">beam_receive</code> pass, a lot of code is needed to handle
the many variants of BEAM instructions. For example, in
<a href="https://github.com/erlang/otp/blob/333e4c5a1406cdeb9d1d5cf9bf4a4fadb232fca8/lib/compiler/src/beam_receive.erl#L185"><code class="language-plaintext highlighter-rouge">opt_update_regs/3</code></a> there are three
clauses just to handle three variants of a <code class="language-plaintext highlighter-rouge">call</code> instruction (calling
a local function, calling an external function, and calling a fun).</p>

<p>Here is an example of a function that <code class="language-plaintext highlighter-rouge">beam_receive</code> did not optimize, but
<a href="https://github.com/erlang/otp/blob/6bee2ac7d11668888d93ec4f93730bcae3e5fa79/lib/compiler/test/receive_SUITE_data/ref_opt/yes_14.erl"><code class="language-plaintext highlighter-rouge">beam_ssa_recv</code> can optimize</a>.</p>
      <h4 id="beam_ssa_opt">
        
        
          beam_ssa_opt <a href="#beam_ssa_opt">#</a>
        
        
      </h4>
    

<p>The <a href="https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_opt.erl"><code class="language-plaintext highlighter-rouge">beam_ssa_opt</code></a> pass runs a <a href="https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_opt.erl#L49">number of
optimizations</a>. Many of the optimizations are replacements
for the optimizations I removed earlier.</p>
      <h4 id="beam_ssa_type">
        
        
          beam_ssa_type <a href="#beam_ssa_type">#</a>
        
        
      </h4>
    

<p><a href="https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_type.erl"><code class="language-plaintext highlighter-rouge">beam_ssa_type</code></a> replaces the unsafe <a href="https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_type.erl"><code class="language-plaintext highlighter-rouge">beam_type</code></a> pass.</p>

<p>The <code class="language-plaintext highlighter-rouge">beam_type</code> pass did a local type analysis (basically for extended basic blocks),
and tried to simplify the code, for example by removing unnecessary type tests.</p>

<p>The <code class="language-plaintext highlighter-rouge">beam_ssa_type</code> pass analyzes the types in an entire function and
simplifies the code, for example by removing unnecessary type
tests. It finds many more opportunities for optimizations than
<code class="language-plaintext highlighter-rouge">beam_type</code> did.</p>
      <h2 id="may-2018">
        
        
          May 2018 <a href="#may-2018">#</a>
        
        
      </h2>
    

<p>At the beginning of May, <a href="https://github.com/jhogberg">John</a> started working on what was to become
this pull request:</p>

<p><a href="https://github.com/erlang/otp/pull/1958">#1958: Rewrite BSM optimizations in the new SSA-based intermediate format</a></p>

<p>I continued to write optimizations and fix bugs that John found while
developing his optimizations.</p>
      <h3 id="rethinking-the-binary-matching-instructions">
        
        
          Rethinking the binary matching instructions <a href="#rethinking-the-binary-matching-instructions">#</a>
        
        
      </h3>
    

<p>While working on his binary optimizations, John realized that the SSA
instructions for binary matching were difficult to optimize. The
binary match instructions I had designed were close to the semantics
of the BEAM instructions. John suggested that the <code class="language-plaintext highlighter-rouge">bs_get</code> instruction
should be broken up into a <code class="language-plaintext highlighter-rouge">bs_match</code> instruction and a <code class="language-plaintext highlighter-rouge">bs_extract</code>
instruction to simplify optimizations.</p>

<p>The breaking up of the instructions meant that <a href="https://github.com/erlang/otp/blob/master/lib/compiler/src/beam_ssa_pre_codegen.erl#L209"><code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code>
would have to work harder to combine
them</a>, but it vastly simplified John’s
optimizations. It turned out that it also enabled other optimizations:
the <a href="https://github.com/erlang/otp/blob/e6c3dd9f701d354c06b9b1b043a3d7e9cc050b1c/lib/compiler/src/beam_ssa_opt.erl#L777">liveness optimizations</a> could remove unused
instructions more aggressively.</p>

<p>On the first day of <a href="https://codesync.global/conferences/code-beam-sto-2018/">Code BEAM STO 2018</a> May 31, I didn’t
know of any bugs in the new compiler passes and my list of optimizations to
re-implement was shrinking steadily. I met <a href="https://github.com/michalmuskala">Michał Muskała</a>
(a frequent contributor to Erlang/OTP and a member of the
<a href="https://elixirforum.com/groups/Elixir-Core-Team">Elixir Core Team</a>) there and told him about my work
on the compiler and that it was stable enough be tested outside OTP,
for example to compile Elixir code…</p>
      <h2 id="june-2018">
        
        
          June 2018 <a href="#june-2018">#</a>
        
        
      </h2>
    
      <h3 id="michałs-feedback">
        
        
          Michał’s feedback <a href="#michałs-feedback">#</a>
        
        
      </h3>
    

<p>I received an email from Michał in the middle of June. He had tried out
my compiler branch. He wrote:</p>

<blockquote>
  <p>First impression is that it took a loooong time to compile Elixir’s unicode module,
so long that I had to shut it down after about 10 minutes.</p>
</blockquote>

<p>He sent me an Erlangified version of <a href="https://github.com/elixir-lang/elixir/blob/54cb02c2407856f4063c75a440507dacb6a31dbc/lib/elixir/unicode/unicode.ex">Elixir’s unicode module</a>.
The size of the Erlang source for the module was almost 82,000 lines or
about 3,700,000 bytes. Based on the size, compilation could be expected to be
a little bit slow, but not that slow. On his computer, OTP 21.0-RC2 finished
the compilation in 16 seconds.</p>

<p>I compiled the module using the <code class="language-plaintext highlighter-rouge">time</code> option. The slowest pass was <code class="language-plaintext highlighter-rouge">beam_ssa_type</code>.
After some further profiling, I found the bottleneck in the joining of two maps.
Here is the <a href="https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_type.erl#L944">corrected code</a>. The original code didn’t compare
the size of maps and swap them as needed. I might have done some other improvements,
too. Anyway, that took care of that bottleneck. Now <code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code> was the
slowest pass.</p>

<p>I fixed several bottlenecks in the <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L2118">linear scan sub pass</a>, and after
that some other bottleneck in <code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code>. I think that reduced the
compilation time to well under one minute.</p>
      <h3 id="optimizing-code-generation">
        
        
          Optimizing code generation <a href="#optimizing-code-generation">#</a>
        
        
      </h3>
    

<p>After having finished the re-implementation of the last optimization
pass (I think it was the <a href="https://github.com/erlang/otp/blob/e6c3dd9f701d354c06b9b1b043a3d7e9cc050b1c/lib/compiler/src/beam_ssa_opt.erl#L517">optimization of floating point
operations</a>, as previously done by the unsafe
<a href="https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_type.erl"><code class="language-plaintext highlighter-rouge">beam_type</code></a> pass), I started to compare the code
generated by OTP 21 with code from the new compiler passes.</p>

<p>I used <a href="https://github.com/erlang/otp/blob/master/scripts/diffable">scripts/diffable</a>, which compiles about 1000
modules from OTP to BEAM code and massages the BEAM code to make it more friendly
for diffing. I then ran <code class="language-plaintext highlighter-rouge">diff -u old new</code> to compare the new code to
the old code.</p>

<p>In the last part of June and the first week of July, I then improved
<code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code> and <code class="language-plaintext highlighter-rouge">beam_ssa_codegen</code> to address the issues that I
noticed when reading the diff.</p>
      <h4 id="beam_ssa_pre_codegen-improvements">
        
        
          <code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code> improvements <a href="#beam_ssa_pre_codegen-improvements">#</a>
        
        
      </h4>
    

<p>I did not change the <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L2118">linear scan</a> sub pass of <code class="language-plaintext highlighter-rouge">beam_ssa_pre_codegen</code>
itself. Instead I added transformations of the SSA code that would help
linear scan do a better job of allocating registers.</p>

<p>The most obvious issue I noticed was unnecessary <code class="language-plaintext highlighter-rouge">move</code> instructions.
Here are two of the sub passes I added to address that issue:</p>

<ul>
  <li>
    <p><a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1916">reserve_xregs</a> gives hints to the linear scan sub pass that a
certain X register should be used for a certain variable, if possible.</p>
  </li>
  <li>
    <p><a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1422">opt_get_list</a> tries to eliminate the extra <code class="language-plaintext highlighter-rouge">move</code> instruction that
is frequently added when matching out elements from a list.  See the
comments in the code for an example and an explanation.</p>
  </li>
</ul>

<p>Another frequent issue was that the code generated from the new code
generator used more stack space because two variables that were not
strictly live at the same time were allocated different Y registers
(slots on the stack) instead of re-using the same Y register. I addressed
that issue in <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1222">copy_retval</a>. See the comments in the code for an example.</p>
      <h4 id="beam_ssa_codegen-improvements">
        
        
          <code class="language-plaintext highlighter-rouge">beam_ssa_codegen</code> improvements <a href="#beam_ssa_codegen-improvements">#</a>
        
        
      </h4>
    

<p>Michał noticed that when a value was stored in both an X register and
a Y register (on the stack), instructions using the value would
always use the Y register. The old code generator would use the X
register.  The new code could be slower because the BEAM interpreter
is generally optimized for operands being in X registers.</p>

<p>I added <a href="https://github.com/erlang/otp/blob/7fbb86c77fa99caddabedfb992f47ddeece80652/lib/compiler/src/beam_ssa_codegen.erl#L359">prefer_xregs</a> to address that issue. See the comments in the code
for examples.</p>
      <h2 id="july-2018">
        
        
          July 2018 <a href="#july-2018">#</a>
        
        
      </h2>
    

<p>Vacation.</p>
      <h2 id="august-2018">
        
        
          August 2018 <a href="#august-2018">#</a>
        
        
      </h2>
    

<p>Before I left for vacation, it seemed that the new compiler passes generally
generated code at least as good as the old compiler passes. In some cases,
the code would be much better.</p>

<p>Back after my vacation, I did some final polishing.</p>

<p>On Aug 17 I created a <a href="https://github.com/erlang/otp/pull/1935">pull request</a>.</p>

<p>Before merging the pull request, I sneaked in a few final optimizations.</p>

<p>On Aug 24 I <a href="https://github.com/erlang/otp/commit/9facb02b91979ef90b47ac0a54d1eb71fdaa1ee1">merged</a> the pull request.</p>
      <h2 id="the-future">
        
        
          The Future <a href="#the-future">#</a>
        
        
      </h2>
    

<p>The SSA-based intermediate representation provides a solid framework for
future improvements of the compiler. After the merging of the pull request in
August, several pull requests have already added further improvements:</p>

<ul>
  <li>
    <p><a href="https://github.com/erlang/otp/pull/1947">Introduce a put_tuple2 instruction</a></p>
  </li>
  <li>
    <p><a href="https://github.com/erlang/otp/pull/1955">Replace beam_dead with beam_ssa_dead</a></p>
  </li>
  <li>
    <p><a href="https://github.com/erlang/otp/pull/1958">Rewrite BSM optimizations in the new SSA-based intermediate format</a></p>
  </li>
  <li>
    <p><a href="https://github.com/erlang/otp/pull/1959">Clean up variable-related cruft in new SSA passes</a></p>
  </li>
  <li>
    <p><a href="https://github.com/erlang/otp/pull/1960">beam_validator: Use set_aliased_type in more operations</a></p>
  </li>
  <li>
    <p><a href="https://github.com/erlang/otp/pull/1965">Minor cleanups and bug fixes of the compiler</a></p>
  </li>
</ul>

<p>Here is a list of possible further improvements that could be implemented either
by OTP members or external contributors before OTP 22 is released:</p>

<ul>
  <li>
    <p>Rewrite <code class="language-plaintext highlighter-rouge">sys_core_dsetel</code> to be SSA-based.</p>
  </li>
  <li>
    <p>Rewrite the guard optimizing sub pass <code class="language-plaintext highlighter-rouge">guard_opt/2</code> in <code class="language-plaintext highlighter-rouge">v3_kernel</code>
to an SSA-based optimization pass.</p>
  </li>
  <li>
    <p>Rewrite <code class="language-plaintext highlighter-rouge">beam_trim</code>. It would probably have to be a part of <code class="language-plaintext highlighter-rouge">beam_ssa_codegen</code>.</p>
  </li>
  <li>
    <p>Optimize <code class="language-plaintext highlighter-rouge">switch</code> branches. If two branches jump to blocks
that do the same thing, let both branches jump to the same
block. <code class="language-plaintext highlighter-rouge">beam_jump</code> does this kind of optimization, but doing it
earlier in the SSA representation could speed up compilation of functions
with many clauses.</p>
  </li>
  <li>
    <p>Get rid of the <code class="language-plaintext highlighter-rouge">beam_utils</code> module, especially the <code class="language-plaintext highlighter-rouge">is_killed()</code> and
<code class="language-plaintext highlighter-rouge">is_not_used()</code> family of functions. The functions in <code class="language-plaintext highlighter-rouge">beam_utils</code>
used by <code class="language-plaintext highlighter-rouge">beam_jump</code> could be moved into <code class="language-plaintext highlighter-rouge">beam_jump</code>.</p>
  </li>
  <li>
    <p>Rewrite <code class="language-plaintext highlighter-rouge">beam_bs</code> to be SSA-based. This rewrite might not improve
the generated code, but it might speed up compilation of modules
with heavy use of the binary syntax.</p>
  </li>
</ul>

        
    </div>
</article>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-c.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-bash.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>