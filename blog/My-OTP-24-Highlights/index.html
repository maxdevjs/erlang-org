<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Erlang/OTP 24 Highlights - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Erlang/OTP 24 Highlights - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-8 offset-lg-2">
            <article class="card mb-4">
    <div class="card-header">
        <h3><a href="/erlang-org/blog/My-OTP-24-Highlights/">Erlang/OTP 24 Highlights</a></h3>
        <div class="date">May 12, 2021
             · by Lukas Larsson
        </div>
    </div>

    <div class="card-body">
        
        
        
        <p>Finally Erlang/OTP 24 is here! A release that for me has been <a href="https://vimeo.com/44231138">about 10 years</a>
in the making. <a href="https://blog.erlang.org/My-OTP-21-Highlights/">As</a> is <a href="https://blog.erlang.org/OTP-22-Highlights/">tradition</a> by <a href="https://blog.erlang.org/OTP-23-Highlights/">now</a>, this blog post will go through the
additions to Erlang/OTP that I am most excited about!</p>

<p>Erlang/OTP 24 includes contributions from 60+ external contributors totalling
1400+ commits, 300+ PRs and changing 0.5 million(!) lines of code. Though I’m not
sure the line number should count as we vendored all of <a href="https://asmjit.com/">AsmJit</a> and
re-generated the wxWidgets support. If we ignore AsmJit and wx, there are still
260k lines of code added and 320k lines removed, which is about 100k more than
what our releases normally contain.</p>

<p>You can download the readme describing the changes here: <a href="http://erlang.org/download/otp_src_24.0.readme">Erlang/OTP 24 Readme</a>.
Or, as always, look at the release notes of the application you are interested in.
For instance here: <a href="http://erlang.org/doc/apps/erts/notes.html#erts-12.0">Erlang/OTP 24 - Erts Release Notes - Version 12.0</a>.</p>

<p>This years highlights are:</p>
<ul>
  <li><a href="#beamasm---the-jit-compiler-for-erlang">BeamAsm - the JIT compiler for Erlang</a></li>
  <li><a href="#improved-error-messages">Improved error messages</a></li>
  <li><a href="#improved-receive-optimizations">Improved receive optimizations</a></li>
  <li><a href="#eep-53-process-aliases">EEP-53: Process aliases</a></li>
  <li><a href="#eep-48-documentation-chunks-for-edoc">EEP-48: Documentation chunks for edoc</a></li>
  <li><a href="#socket-support-in-gen_tcp">socket support in gen_tcp</a></li>
  <li><a href="#EEP-56-supervisor-automatic-shutdown">EEP-56: Supervisor automatic shutdown</a></li>
  <li><a href="#edwards-curve-digital-signature-algorithm">Edwards-curve Digital Signature Algorithm</a></li>
</ul>
      <h1 id="beamasm---the-jit-compiler-for-erlang">
        
        
          BeamAsm - the JIT compiler for Erlang <a href="#beamasm---the-jit-compiler-for-erlang">#</a>
        
        
      </h1>
    

<p>The most anticipated feature of Erlang/OTP 24 has to be the JIT compiler.
A lot has already been said about it:</p>

<ul>
  <li><a href="https://github.com/erlang/otp/pull/2745">Initial PR</a></li>
  <li><a href="https://blog.erlang.org/a-first-look-at-the-jit/">A first look at the JIT</a></li>
  <li><a href="https://blog.erlang.org/jit-part-2/">Further adventures in the JIT</a></li>
  <li><a href="https://blog.erlang.org/the-road-to-the-jit/">The Road to the JIT</a></li>
  <li><a href="http://erlang.org/doc/apps/erts/BeamAsm.html">BeamAsm, the Erlang JIT</a></li>
</ul>

<p>and even before released the WhatsApp team has <a href="https://twitter.com/garazdawi/status/1385263924803735556">shown what it is capable of</a>.</p>

<p>However, besides the performance gains that the JIT brings, what I am the most
excited about is the benefits that come with running native code
instead of interpreting. What I’m talking about is the native code tooling that
now becomes available to all Erlang programmers, such as integration with <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a>.</p>

<p>As an example, when building a dialyzer plt of a small core of Erlang, the
previous way to profile would be via something like <a href="https://erlang.org/doc/man/eprof.html">eprof</a>.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">eprof</span><span class="p">:</span><span class="nf">profile</span><span class="p">(</span><span class="k">fun</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nn">dialyzer</span><span class="p">:</span><span class="nf">run</span><span class="p">([{</span><span class="n">analysis_type</span><span class="p">,</span><span class="n">'plt_build'</span><span class="p">},{</span><span class="n">apps</span><span class="p">,[</span><span class="n">erts</span><span class="p">]}])</span>
  <span class="k">end</span><span class="p">).</span>
</code></pre></div></div>

<p>This increases the time to build the PLT from about 1.2 seconds to 15 seconds on
my system. In the end, you get something like the below that will guide you to
what you need to optimize. Maybe take a look at <code class="language-plaintext highlighter-rouge">erl_types:t_has_var*/1</code>
and check if you really need to call it 13-15 million times!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; eprof:analyze(total).
FUNCTION                      CALLS        %     TIME [uS / CALLS]
--------                      -----  -------     ---- [----------]
erl_types:t_sup1/2          2744805     1.68   752795 [      0.27]
erl_types:t_subst/2         2803211     1.92   858180 [      0.31]
erl_types:t_limit_k/2       3783173     2.04   913217 [      0.24]
maps:find/2                 4798032     2.14   957223 [      0.20]
erl_types:t_has_var/1      15943238     5.89  2634428 [      0.17]
erl_types:t_has_var_list/1 13736485     7.51  3360309 [      0.24]
------------------------  ---------  ------- -------- [----------]
Total:                    174708211  100.00% 44719837 [      0.26]
</code></pre></div></div>

<p>In Erlang/OTP 24 we can get the same result without having to pay the pretty
steep cost of profiling with eprof. When running the same analysis as above
using <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> it takes roughly 1.3 seconds to run.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ ERL_FLAGS</span><span class="o">=</span><span class="s2">"+JPperf true"</span> perf record dialyzer <span class="nt">--build_plt</span> <span class="se">\</span>
    <span class="nt">--apps</span> erts
</code></pre></div></div>

<p>Then we can use tools such as <a href="https://man7.org/linux/man-pages/man1/perf-report.1.html">perf report</a>, <a href="https://github.com/KDAB/hotspot">hotspot</a> or <a href="https://twitter.com/michalslaski/status/1391381431335669765">speedscope</a> to
analyze the results.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>hotspot perf.data
</code></pre></div></div>

<p><img class="img-fluid"src="/blog/images/hotspot-dialyzer.png" alt="alt text" title="Hotspot dialyzer" /></p>

<p>In the above, we can see that we get roughly the same result as when using
<code class="language-plaintext highlighter-rouge">eprof</code>, though interestingly not exactly the same. I’ll leave the whys of
this up to the reader to find out :)</p>

<p>With this little overhead when profiling, we can run scenarios that previously
would take too long to run when profiling. For those brave enough it might even
be possible to run always-on profiling in production!</p>

<p>The journey with what can be done with <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> has only started. In <a href="https://github.com/erlang/otp/pull/4676">PR-4676</a> we
will be adding frame pointer support which will give a much more accurate call
frames when profiling and, in the end, the goal is to have mappings to Erlang
source code lines instead of only functions when using <a href="https://man7.org/linux/man-pages/man1/perf-report.1.html">perf report</a> and
<a href="https://github.com/KDAB/hotspot">hotspot</a> to analyze a perf recording.</p>
      <h1 id="improved-error-messages">
        
        
          Improved error messages <a href="#improved-error-messages">#</a>
        
        
      </h1>
    

<p>Erlang’s error messages tend to get a lot of (valid) critisism for being hard to
understand. Two great new features have been added to help the user understand
why something has failed.</p>
      <h2 id="column-number-in-warnings-and-errors">
        
        
          Column number in warnings and errors <a href="#column-number-in-warnings-and-errors">#</a>
        
        
      </h2>
    

<p>Thanks to the work of <a href="https://github.com/richcarl">Richard Carlsson</a> and <a href="https://github.com/uabboli">Hans Bolinder</a>, when you compile
Erlang code you now get the line and column of errors and warnings printed in
the shell together with a <code class="language-plaintext highlighter-rouge">^</code>-sign showing exactly where the error
actually was. For example, if you compile the below:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">foo</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="err">#</span><span class="p">{</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="nv">A</span><span class="p">,</span> <span class="n">b</span> <span class="p">:</span><span class="o">=</span> <span class="nv">B</span> <span class="p">}.</span>
</code></pre></div></div>

<p>you would in Erlang/OTP 23 and earlier get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ erlc t.erl
t.erl:6: only association operators '=&gt;' are allowed in map construction
</code></pre></div></div>

<p>but in Erlang/OTP 24 you now also get the following printout:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ erlc test.erl
t.erl:6:16: only association operators '=&gt;' are allowed in map construction
%    6|   #{ a =&gt; A, b := B }.
%     |                ^
</code></pre></div></div>

<p>This behavior also extends into most of the Erlang code editors so that
when you use VSCode or Emacs through <a href="https://erlang-ls.github.io/">Erlang LS</a> or <a href="https://www.flycheck.org/">flycheck</a> you also
get a narrower warning/error indicator, for example in Emacs using <a href="https://erlang-ls.github.io/">Erlang LS</a>.</p>

<p><img class="img-fluid"src="/blog/images/column-numbers-highlight.png" alt="alt text" title="Emacs columns numbers with Erlang-LS" /></p>
      <h2 id="eep-54-improved-bif-error-information">
        
        
          EEP-54: Improved BIF error information <a href="#eep-54-improved-bif-error-information">#</a>
        
        
      </h2>
    

<p>One of the other big changes when it comes to error information is the
introduction of <a href="https://www.erlang.org/erlang-enhancement-proposals/eep-0054.html">EEP-54</a>. In the past many of the <a href="https://erlang.org/doc/reference_manual/functions.html#built-in-functions--bifs-">BIFs</a> (built-in functions)
would give very cryptic error messages:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nb">element</span><span class="p">({</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">},</span> <span class="mi">1</span><span class="p">).</span>
<span class="o">**</span> <span class="n">exception</span> <span class="nn">error</span><span class="p">:</span> <span class="n">bad</span> <span class="n">argument</span>
     <span class="n">in</span> <span class="n">function</span>  <span class="nb">element</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">called</span> <span class="n">as</span> <span class="nb">element</span><span class="p">({</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">},</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>In the example above, the only thing we know is that one or more of the
arguments are invalid, but without checking
<a href="https://erlang.org/doc/man/erlang.html#element-2">the documentation</a>
there is no way of knowing which one and why. This is especially a problem for
BIFs where the arguments may fail for different reasons depending on factors not
visible in the arguments. For example in the <code class="language-plaintext highlighter-rouge">ets:update_counter</code> call below:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">ets</span><span class="p">:</span><span class="nf">update_counter</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>
<span class="o">**</span> <span class="n">exception</span> <span class="nn">error</span><span class="p">:</span> <span class="n">bad</span> <span class="n">argument</span>
     <span class="n">in</span> <span class="n">function</span>  <span class="nn">ets</span><span class="p">:</span><span class="n">update_counter</span><span class="o">/</span><span class="mi">3</span>
        <span class="n">called</span> <span class="n">as</span> <span class="nn">ets</span><span class="p">:</span><span class="nf">update_counter</span><span class="p">(</span><span class="n">table</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>We don’t know if the call failed because the table did not exist at all
or if the key <code class="language-plaintext highlighter-rouge">k</code> that we wanted to update did not exist in the table.</p>

<p>In Erlang/OTP 24 both of the examples above will have a much clearer error
messages.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nb">element</span><span class="p">({</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">},</span> <span class="mi">1</span><span class="p">).</span>
<span class="o">**</span> <span class="n">exception</span> <span class="nn">error</span><span class="p">:</span> <span class="n">bad</span> <span class="n">argument</span>
     <span class="n">in</span> <span class="n">function</span>  <span class="nb">element</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">called</span> <span class="n">as</span> <span class="nb">element</span><span class="p">({</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">},</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">***</span> <span class="n">argument</span> <span class="mi">1</span><span class="p">:</span> <span class="ow">not</span> <span class="n">an</span> <span class="n">integer</span>
        <span class="o">***</span> <span class="n">argument</span> <span class="mi">2</span><span class="p">:</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">tuple</span>
<span class="mi">2</span><span class="o">&gt;</span> <span class="nn">ets</span><span class="p">:</span><span class="nf">new</span><span class="p">(</span><span class="n">table</span><span class="p">,[</span><span class="n">named_table</span><span class="p">]).</span>
<span class="n">table</span>
<span class="mi">3</span><span class="o">&gt;</span> <span class="nn">ets</span><span class="p">:</span><span class="nf">update_counter</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>
<span class="o">**</span> <span class="n">exception</span> <span class="nn">error</span><span class="p">:</span> <span class="n">bad</span> <span class="n">argument</span>
     <span class="n">in</span> <span class="n">function</span>  <span class="nn">ets</span><span class="p">:</span><span class="n">update_counter</span><span class="o">/</span><span class="mi">3</span>
        <span class="n">called</span> <span class="n">as</span> <span class="nn">ets</span><span class="p">:</span><span class="nf">update_counter</span><span class="p">(</span><span class="n">table</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">***</span> <span class="n">argument</span> <span class="mi">2</span><span class="p">:</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">key</span> <span class="n">that</span> <span class="n">exists</span> <span class="n">in</span> <span class="n">the</span> <span class="n">table</span>
</code></pre></div></div>

<p>That looks much better and now we can see what the problem was!
The standard logging formatters also include the additional information
so that if this type of error happens in a production environment you will
get the extra error information:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1&gt; proc_lib:spawn(fun() -&gt; ets:update_counter(table, k, 1) end).
&lt;0.94.0&gt;
=CRASH REPORT==== 10-May-2021::11:20:35.367023 ===
  crasher:
    initial call: erl_eval:'-expr/5-fun-3-'/0
    pid: &lt;0.94.0&gt;
    registered_name: []
    exception error: bad argument
      in function  ets:update_counter/3
         called as ets:update_counter(table,k,1)
         *** argument 1: the table identifier does
                         not refer to an existing ETS table
    ancestors: [&lt;0.92.0&gt;]
</code></pre></div></div>

<p><a href="https://www.erlang.org/erlang-enhancement-proposals/eep-0054.html">EEP-54</a> is not only useful for error messages coming from BIFs but can be used
by any application that wants to provide extra information about their exceptions.
For example, we have been working on providing better error information around
<code class="language-plaintext highlighter-rouge">io:format</code> in <a href="https://github.com/erlang/otp/pull/4757">PR-4757</a>.</p>
      <h1 id="improved-receive-optimizations">
        
        
          Improved receive optimizations <a href="#improved-receive-optimizations">#</a>
        
        
      </h1>
    

<p>Since Erlang/OTP R14 (released in 2010), the Erlang compiler and run-time system
have co-operated to optimize for the pattern of code used by
<code class="language-plaintext highlighter-rouge">gen_server:call</code> like functionality to avoid scanning a potentially
huge mailbox. The basic pattern looks like this:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">call</span><span class="p">(</span><span class="nv">To</span><span class="p">,</span> <span class="nv">Msg</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="nv">Ref</span> <span class="o">=</span> <span class="nf">make_ref</span><span class="p">(),</span>
  <span class="nv">To</span> <span class="o">!</span> <span class="p">{</span><span class="n">call</span><span class="p">,</span> <span class="nv">Ref</span><span class="p">,</span> <span class="nf">self</span><span class="p">(),</span> <span class="nv">Msg</span><span class="p">},</span>
  <span class="k">receive</span>
    <span class="p">{</span><span class="n">reply</span><span class="p">,</span> <span class="nv">Ref</span><span class="p">,</span> <span class="nv">Reply</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nv">Reply</span>
  <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>The compiler can from this figure out that when <code class="language-plaintext highlighter-rouge">Ref</code> is created, there can be
no messages in the mailbox of the process that contains <code class="language-plaintext highlighter-rouge">Ref</code> and therefore it
can skip all of those when receiving the <code class="language-plaintext highlighter-rouge">Reply</code>.</p>

<p>This has always worked great in simple scenarios like this, but as soon as you
had to make the scenarios a little more complex it tended to break the
compiler’s analysis and you would end up scanning the entire mailbox. For example,
in the code below Erlang/OTP 23 will not optimize the receive.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">call</span><span class="p">(</span><span class="nv">To</span><span class="p">,</span> <span class="nv">Msg</span><span class="p">,</span> <span class="nv">Async</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="nv">Ref</span> <span class="o">=</span> <span class="nf">make_ref</span><span class="p">(),</span>
  <span class="nv">To</span> <span class="o">!</span> <span class="p">{</span><span class="n">call</span><span class="p">,</span> <span class="nv">Ref</span><span class="p">,</span> <span class="nf">self</span><span class="p">(),</span> <span class="nv">Msg</span><span class="p">},</span>
  <span class="k">if</span>
    <span class="nv">Async</span> <span class="o">-&gt;</span>
      <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Ref</span><span class="p">};</span>
    <span class="ow">not</span> <span class="nv">Async</span> <span class="o">-&gt;</span>
      <span class="k">receive</span>
        <span class="p">{</span><span class="n">reply</span><span class="p">,</span> <span class="nv">Ref</span><span class="p">,</span> <span class="nv">Reply</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nv">Reply</span>
      <span class="k">end</span>
  <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>That all changes with Erlang/OTP 24! Many more complex scenarios are now
covered by the optimization and a new compiler flag has been added to tell the
user if an optimization is done.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>erlc +recv_opt_info test.erl
test.erl:6: Warning: OPTIMIZED: reference used to mark
                                a message queue position
%    6|   Ref <span class="o">=</span> make_ref<span class="o">()</span>,
test.erl:12: Warning: OPTIMIZED: all clauses match reference
                                 created by make_ref/0
                                 at test.erl:6
%   12|       receive
</code></pre></div></div>

<p>Even patterns such as multi_call are now optimized to not scan the mailbox of
the process.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">multi_call</span><span class="p">(</span><span class="nv">ToList</span><span class="p">,</span> <span class="nv">Msg</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="c">%% OPTIMIZED: reference used to mark a message queue position
</span>  <span class="nv">Ref</span> <span class="o">=</span> <span class="nf">make_ref</span><span class="p">(),</span>
  <span class="c">%% INFO: passing reference created by make_ref/0 at test.erl:18
</span>  <span class="p">[</span><span class="nv">To</span> <span class="o">!</span> <span class="p">{</span><span class="n">call</span><span class="p">,</span> <span class="nv">Ref</span><span class="p">,</span> <span class="nf">self</span><span class="p">(),</span> <span class="nv">Msg</span><span class="p">}</span> <span class="p">||</span> <span class="nv">To</span> <span class="o">&lt;-</span> <span class="nv">ToList</span><span class="p">],</span>
  <span class="c">%% INFO: passing reference created by make_ref/0 at test.erl:18
</span>  <span class="c">%% OPTIMIZED: all clauses match reference
</span>  <span class="c">%%            in function parameter 2
</span>  <span class="p">[</span><span class="k">receive</span> <span class="p">{</span><span class="n">reply</span><span class="p">,</span> <span class="nv">Ref</span><span class="p">,</span> <span class="nv">Reply</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nv">Reply</span> <span class="k">end</span> <span class="p">||</span> <span class="p">_</span> <span class="o">&lt;-</span> <span class="nv">ToList</span><span class="p">].</span>
</code></pre></div></div>

<p>There are still a lot of places where this optimization does not trigger. For
instance as soon as any of the make_ref/send/receive are in different modules it
will not work. However, the new improvements in Erlang/OTP 24 make the number of
scenarios a lot fewer and now we also have the tools to check and see if the
optimization is triggered!</p>

<p>You can read more about this optimization and others in the <a href="https://erlang.org/doc/efficiency_guide/processes.html#process-messages">Efficiency Guide</a>.</p>
      <h1 id="eep-53-process-aliases">
        
        
          EEP-53: Process aliases <a href="#eep-53-process-aliases">#</a>
        
        
      </h1>
    

<p>When doing a call to another Erlang process, the pattern used by
<code class="language-plaintext highlighter-rouge">gen_server:call</code>, <code class="language-plaintext highlighter-rouge">gen_statem:call</code> and others normally looks something
like this:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">call</span><span class="p">(</span><span class="nv">To</span><span class="p">,</span> <span class="nv">Msg</span><span class="p">,</span> <span class="nv">Tmo</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="nv">MonRef</span> <span class="o">=</span> <span class="nn">erlang</span><span class="p">:</span><span class="nb">monitor</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nv">To</span><span class="p">),</span>
  <span class="nv">To</span> <span class="o">!</span> <span class="p">{</span><span class="n">call</span><span class="p">,</span> <span class="nv">MonRef</span><span class="p">,</span> <span class="nf">self</span><span class="p">(),</span> <span class="nv">Msg</span><span class="p">},</span>
  <span class="k">receive</span>
    <span class="p">{</span><span class="n">'DOWN'</span><span class="p">,</span><span class="nv">MonRef</span><span class="p">,_,_,</span><span class="nv">Reason</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="p">{</span><span class="n">error</span><span class="p">,</span> <span class="nv">Reason</span><span class="p">};</span>
    <span class="p">{</span><span class="n">reply</span><span class="p">,</span> <span class="nv">MonRef</span><span class="p">,</span> <span class="nv">Reply</span><span class="p">}</span>
      <span class="nn">erlang</span><span class="p">:</span><span class="nb">demonitor</span><span class="p">(</span><span class="nv">MonRef</span><span class="p">,[</span><span class="n">flush</span><span class="p">]),</span>
      <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Reply</span><span class="p">}</span>
    <span class="k">after</span> <span class="nv">Tmo</span> <span class="o">-&gt;</span>
      <span class="nn">erlang</span><span class="p">:</span><span class="nb">demonitor</span><span class="p">(</span><span class="nv">MonRef</span><span class="p">,[</span><span class="n">flush</span><span class="p">]),</span>
      <span class="p">{</span><span class="n">error</span><span class="p">,</span> <span class="n">timeout</span><span class="p">}</span>
  <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>This normally works well except for when a timeout happens. When a timeout
happens the process on the other end has no way to know that the reply is no
longer needed and so will send it anyway when it is done with it. This causes
all kinds of problems as the user of a third-party library would never know what
messages to expect to be present in the mailbox.</p>

<p>There have been numerous attempts to solve this problem using the primitives
that Erlang gives you, but in the end, most ended up just adding a <code class="language-plaintext highlighter-rouge">handle_info</code>
in their <code class="language-plaintext highlighter-rouge">gen_server</code>s that ignored any unknown messages.</p>

<p>In Erlang/OTP 24, <a href="https://www.erlang.org/erlang-enhancement-proposals/eep-0053.html">EEP-53</a> has introduced the <code class="language-plaintext highlighter-rouge">alias</code> functionality to solve this problem.
An <code class="language-plaintext highlighter-rouge">alias</code> is a temporary reference to a process that can be used
to send messages to. In most respects, it works just as a PID except that
the lifetime of an alias is not tied with the lifetime of the process it
represents. So when you try to send a late reply to an alias that has been
deactivated the message will just be dropped.</p>

<p>The code changes needed to make this happen are very small and are already used
behind the scenes in all the standard behaviors of Erlang/OTP. The only thing
needed to be changed in the example code above is that a new option must be
given to <code class="language-plaintext highlighter-rouge">erlang:monitor</code> and the reply reference should now be the alias
instead of the calling PID. That is, like this:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">call</span><span class="p">(</span><span class="nv">To</span><span class="p">,</span> <span class="nv">Msg</span><span class="p">,</span> <span class="nv">Tmo</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="nv">MonAlias</span> <span class="o">=</span> <span class="nn">erlang</span><span class="p">:</span><span class="nb">monitor</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nv">To</span><span class="p">,</span> <span class="p">[{</span><span class="n">alias</span><span class="p">,</span> <span class="nb">demonitor</span><span class="p">}]),</span>
  <span class="nv">To</span> <span class="o">!</span> <span class="p">{</span><span class="n">call</span><span class="p">,</span> <span class="nv">MonAlias</span><span class="p">,</span> <span class="nv">MonAlias</span><span class="p">,</span> <span class="nv">Msg</span><span class="p">},</span>
  <span class="k">receive</span>
    <span class="p">{</span><span class="n">'DOWN'</span><span class="p">,</span> <span class="nv">MonAlias</span><span class="p">,</span> <span class="p">_</span> <span class="p">,</span> <span class="p">_,</span> <span class="nv">Reason</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="p">{</span><span class="n">error</span><span class="p">,</span> <span class="nv">Reason</span><span class="p">};</span>
    <span class="p">{</span><span class="n">reply</span><span class="p">,</span> <span class="nv">MonAlias</span><span class="p">,</span> <span class="nv">Reply</span><span class="p">}</span>
      <span class="nn">erlang</span><span class="p">:</span><span class="nb">demonitor</span><span class="p">(</span><span class="nv">MonAlias</span><span class="p">,[</span><span class="n">flush</span><span class="p">]),</span>
      <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Reply</span><span class="p">}</span>
    <span class="k">after</span> <span class="nv">Tmo</span> <span class="o">-&gt;</span>
      <span class="nn">erlang</span><span class="p">:</span><span class="nb">demonitor</span><span class="p">(</span><span class="nv">MonAlias</span><span class="p">,[</span><span class="n">flush</span><span class="p">]),</span>
      <span class="p">{</span><span class="n">error</span><span class="p">,</span> <span class="n">timeout</span><span class="p">}</span>
  <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>You can read more about this functionality in the <a href="https://erlang.org/doc/reference_manual/processes.html#process-aliases">alias documentation</a>.</p>
      <h1 id="eep-48-documentation-chunks-for-edoc">
        
        
          EEP-48: Documentation chunks for edoc <a href="#eep-48-documentation-chunks-for-edoc">#</a>
        
        
      </h1>
    

<p>In Erlang/OTP 23 <a href="http://erlang.org/doc/man/erl_docgen_app.html">erl_docgen</a> was extended to be able to emit <a href="https://www.erlang.org/erlang-enhancement-proposals/eep-0048.html">EEP-48</a> style
documentation. This allowed the documentation to be used by <code class="language-plaintext highlighter-rouge">h(lists)</code> in
the Erlang shell and external tools such as <a href="https://erlang-ls.github.io/">Erlang LS</a>. However, there
are very few applications outside Erlang/OTP that use <code class="language-plaintext highlighter-rouge">erl_docgen</code> to
create documentation, so <a href="https://www.erlang.org/erlang-enhancement-proposals/eep-0048.html">EEP-48</a> style documentation was unavailable to
those applications. Until now!</p>

<p><a href="https://github.com/erszcz">Radek Szymczyszyn</a> has <a href="https://github.com/erlang/otp/pull/2803">added</a> support for <a href="https://www.erlang.org/erlang-enhancement-proposals/eep-0048.html">EEP-48</a> into <a href="https://erlang.org/doc/man/edoc.html">edoc</a> which means
that from Erlang/OTP 24 you can view both the documentation of <code class="language-plaintext highlighter-rouge">lists:foldl/3</code>
and <code class="language-plaintext highlighter-rouge">recon:info/1</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rebar3 as docs shell
Erlang/OTP 24 [erts-12.0] [source] [jit]

Eshell V11.2.1  (abort with ^G)
1&gt; h(recon,info,1).
 -spec info(PidTerm) -&gt;
   [{info_type(), [{info_key(), Value}]}, ...]
     when PidTerm :: pid_term().

  Allows to be similar to erlang:process_info/1, but excludes
  fields such as the mailbox, which tend to grow
  and be unsafe when called in production systems. Also includes
  a few more fields than what is usually given (monitors,
  monitored_by, etc.), and separates the fields in a more
  readable format based on the type of information contained.
</code></pre></div></div>

<p>For more information about how to enable this in your project see
the <a href="https://erlang.org/doc/apps/edoc/chapter.html#doc-chunks">Doc chunks section in the Edoc User’s Guide</a>.</p>
      <h1 id="socket-support-in-gen_tcp">
        
        
          <code class="language-plaintext highlighter-rouge">socket</code> support in <code class="language-plaintext highlighter-rouge">gen_tcp</code> <a href="#socket-support-in-gen_tcp">#</a>
        
        
      </h1>
    

<p>The <a href="https://erlang.org/doc/man/gen_tcp.html">gen_tcp</a> module has gotten support for optionally using the new <a href="https://erlang.org/doc/man/socket.html">socket</a>
nif API instead of the previous inet driver. The new interface can be configured
to be used either on a system level through setting the application
configuration parameter like this: <code class="language-plaintext highlighter-rouge">-kernel inet_backend socket</code>, or on a per
connection bases like this: <code class="language-plaintext highlighter-rouge">gen_tcp:connect(localhost,8080,[{inet_backend,socket}])</code>.</p>

<p>If you do this you will notice that the <code class="language-plaintext highlighter-rouge">Socket</code> returned by <code class="language-plaintext highlighter-rouge">gen_tcp</code> no longer
is a port but instead of a tuple containing (among other things) a PID and a
reference.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nn">gen_tcp</span><span class="p">:</span><span class="nf">connect</span><span class="p">(</span><span class="n">localhost</span><span class="p">,</span><span class="mi">8080</span><span class="p">,[{</span><span class="n">inet_backend</span><span class="p">,</span><span class="n">socket</span><span class="p">}]).</span>
<span class="p">{</span><span class="n">ok</span><span class="p">,{</span><span class="n">'$inet'</span><span class="p">,</span><span class="n">gen_tcp_socket</span><span class="p">,</span>
             <span class="p">{</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">88</span><span class="p">.</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,{</span><span class="n">'$socket'</span><span class="p">,</span><span class="err">#</span><span class="nv">Ref</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">2959644163</span><span class="p">.</span><span class="mi">2576220161</span><span class="p">.</span><span class="mi">68602</span><span class="o">&gt;</span><span class="p">}}}}</span>
</code></pre></div></div>

<p>This data structure is and always has been <a href="http://erlang.org/doc/reference_manual/typespec.html#type-declarations-of-user-defined-types">opaque</a>, and therefore should not be inspected
directly but instead only used as an argument to other <a href="https://erlang.org/doc/man/gen_tcp.html">gen_tcp</a> and <a href="https://erlang.org/doc/man/inet.html">inet</a>
functions.</p>

<p>You can then use <a href="https://erlang.org/doc/man/inet.html#i-0">inet:i/0</a> to get a listing of all open sockets in the system:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span><span class="o">&gt;</span> <span class="nn">inet</span><span class="p">:</span><span class="nf">i</span><span class="p">().</span>
<span class="nv">Port</span>      <span class="nv">Module</span>         <span class="nv">Recv</span> <span class="nv">Sent</span> <span class="nv">Owner</span>    <span class="nv">Local</span> <span class="nv">Address</span>   <span class="nv">Foreign</span> <span class="nv">Address</span>    <span class="nv">State</span> <span class="nv">Type</span>   
<span class="n">esock</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="n">gen_tcp_socket</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">98</span><span class="p">.</span><span class="mi">0</span><span class="o">&gt;</span> <span class="nn">localhost</span><span class="p">:</span><span class="mi">44082</span> <span class="nn">localhost</span><span class="p">:</span><span class="n">http</span><span class="o">-</span><span class="n">alt</span> <span class="nv">CD</span><span class="p">:</span><span class="nv">SD</span> <span class="nv">STREAM</span> 
</code></pre></div></div>

<p>The <a href="https://erlang.org/doc/man/gen_tcp.html">gen_tcp</a> API should be completely backward compatible with the old
implementation, so if you can, please test it and report any bugs that you find
back to us.</p>

<p>Why should you want to test this? Because in some of our benchmarks, we get up
to 4 times the throughput vs the old implementation. In others,
there is no difference or even a loss of throughput. So, as always, you need to
measure and check for yourself!</p>
      <h1 id="eep-56-supervisor-automatic-shutdown">
        
        
          EEP-56: Supervisor automatic shutdown <a href="#eep-56-supervisor-automatic-shutdown">#</a>
        
        
      </h1>
    

<p>When creating supervisor hierarchies for applications that manage connections
such as <a href="https://erlang.org/doc/man/ssl.html">ssl</a> or <a href="https://erlang.org/doc/man/ssh.html">ssh</a>, there are times when there is a need for terminating
that supervisor hierarchy from within. Some event happens on the socket that
should trigger a graceful shutdown of the processes associated with the
connection.</p>

<p>Normally this would be done by using <a href="https://erlang.org/doc/man/supervisor.html#terminate_child-2">supervisor:terminate_child/2</a>. However,
this has two problems.</p>

<ol>
  <li>It requires the child to know the ID of the child that needs to be terminated
and the PID of the supervisor to talk to. This is simple when there is just
one process in the supervisor, but when there are supervisors under
supervisors, this becomes harder and harder to figure out.</li>
  <li>Calling <a href="https://erlang.org/doc/man/supervisor.html#terminate_child-2">supervisor:terminate_child/2</a> is a synchronous operation. This means
that if you do the call in the child, you may end up in a deadlock as the top
supervisor wants to terminate the child while the child is blocking in the call
to terminate itself.</li>
</ol>

<p>To solve this problem <a href="https://www.erlang.org/erlang-enhancement-proposals/eep-0056.html">EEP-56</a> has added a mechanism in which a child can be
marked as significant and if such a child terminates, it can trigger an automatic
shutdown of the supervisor that it is part of.</p>

<p>This way a child process can trigger the shutdown of a supervisor hierarchy from
within, without the child having to know anything about the supervisor hierarchy
nor risking dead-locking itself during termination.</p>

<p>You can read more about automatic shutdown in the <a href="https://erlang.org/doc/man/supervisor.html#auto_shutdown">supervisor documentation</a>.</p>
      <h1 id="edwards-curve-digital-signature-algorithm">
        
        
          Edwards-curve Digital Signature Algorithm <a href="#edwards-curve-digital-signature-algorithm">#</a>
        
        
      </h1>
    

<p>With Erlang/OTP 24 comes support for <a href="https://datatracker.ietf.org/doc/html/rfc8032">Edwards-curve Digital Signature Algorithm</a>
(<code class="language-plaintext highlighter-rouge">EdDSA</code>). <code class="language-plaintext highlighter-rouge">EdDSA</code> can be used when connecting to or acting as a TLS 1.3
client/server.</p>

<p><code class="language-plaintext highlighter-rouge">EdDSA</code> is a type of <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">elliptic curve signature algorithm</a> (<code class="language-plaintext highlighter-rouge">ECDSA</code>)
that can be used for secure communication. The security of <code class="language-plaintext highlighter-rouge">ECDSA</code> relies on a
<a href="http://erlang.org/doc/man/crypto.html#strong_rand_bytes-1">strong cryptographically secure random number</a> which can cause issues when
the random number is by mistake not secure enough, as has been the case in several
uses of ECDSA (none of them in Erlang as far as we know :).</p>

<p><code class="language-plaintext highlighter-rouge">EdDSA</code> does not rely on a strong random number to be secure. This means that
when you are using <code class="language-plaintext highlighter-rouge">EdDSA</code>, the communication is secure even if your random
number generator is not.</p>

<p>Despite the added security, <code class="language-plaintext highlighter-rouge">EdDSA</code> is claimed to be faster than other eliptic
curve signature algorithms. If you have <a href="https://www.openssl.org/">OpenSSL</a> 1.1.1 or later, then as of
Erlang/OTP 24 you will have access to this algorithm!</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">crypto</span><span class="p">:</span><span class="nf">supports</span><span class="p">(</span><span class="n">curves</span><span class="p">).</span>
<span class="p">[...</span>
  <span class="n">c2tnb359v1</span><span class="p">,</span> <span class="n">c2tnb431r1</span><span class="p">,</span> <span class="n">ed25519</span><span class="p">,</span> <span class="n">ed448</span><span class="p">,</span> <span class="n">ipsec3</span><span class="p">,</span> <span class="n">ipsec4</span>
 <span class="p">...]</span>                     <span class="err">^</span>        <span class="err">^</span>
</code></pre></div></div>

        
    </div>
</article>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-c.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-bash.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>