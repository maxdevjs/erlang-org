<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"ETS oddity - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>ETS oddity - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-8 offset-lg-2">
            <article class="card mb-4">
    <div class="card-header">
        <h3><a href="/erlang-org/blog/ets-oddity/">ETS oddity</a></h3>
        <div class="date">January 07, 2019
             Â· by Lukas Larsson
        </div>
    </div>

    <div class="card-body">
        
        
        
        <p>When working with the implementation of the new <a href="https://github.com/erlang/otp/pull/1952">scalable ordered_set</a>
we came across a strangeness with the guarantees when iterating over a table
while inserting elements in parallel.</p>
      <h3 id="scenario">
        
        
          Scenario: <a href="#scenario">#</a>
        
        
      </h3>
    

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nv">Tab</span> <span class="o">=</span> <span class="nn">ets</span><span class="p">:</span><span class="nf">new</span><span class="p">(</span><span class="n">test_table</span><span class="p">,</span>
                <span class="p">[</span><span class="n">set</span><span class="p">,</span> <span class="n">public</span><span class="p">,</span> <span class="p">{</span><span class="n">write_concurrency</span><span class="p">,</span> <span class="n">true</span><span class="p">}]).</span>
<span class="err">#</span><span class="nv">Ref</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">1705802953</span><span class="p">.</span><span class="mi">985792516</span><span class="p">.</span><span class="mi">98626</span><span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="nv">P1</span> <span class="o">=</span> <span class="nb">spawn</span><span class="p">(</span><span class="k">fun</span><span class="p">()</span> <span class="o">-&gt;</span>
               <span class="nn">ets</span><span class="p">:</span><span class="nf">insert</span><span class="p">(</span><span class="nv">Tab</span><span class="p">,</span> <span class="p">{</span><span class="n">fir</span><span class="p">,</span> <span class="mi">1</span><span class="p">}),</span>
               <span class="nn">ets</span><span class="p">:</span><span class="nf">insert</span><span class="p">(</span><span class="nv">Tab</span><span class="p">,</span> <span class="p">{</span><span class="n">sec</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span>
             <span class="k">end</span><span class="p">).</span>
<span class="o">&gt;</span> <span class="nv">K1</span> <span class="o">=</span> <span class="nn">ets</span><span class="p">:</span><span class="nf">first</span><span class="p">(</span><span class="nv">Tab</span><span class="p">),</span> <span class="nv">K2</span> <span class="o">=</span> <span class="nn">ets</span><span class="p">:</span><span class="nf">next</span><span class="p">(</span><span class="nv">Tab</span><span class="p">,</span> <span class="nv">K1</span><span class="p">).</span>
</code></pre></div></div>

<p>What are the theoretical possible values of <code class="language-plaintext highlighter-rouge">K1</code> and <code class="language-plaintext highlighter-rouge">K2</code>? Let us first list the obvious:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">K1 = fir</code>, <code class="language-plaintext highlighter-rouge">K2 = sec</code> - both values inserted and found in term order</li>
  <li><code class="language-plaintext highlighter-rouge">K1 = sec</code>, <code class="language-plaintext highlighter-rouge">K2 = fir</code> - since this is a <code class="language-plaintext highlighter-rouge">set</code>, the hash algorithm may put <code class="language-plaintext highlighter-rouge">sec</code> before <code class="language-plaintext highlighter-rouge">fir</code></li>
  <li><code class="language-plaintext highlighter-rouge">K1 = fir</code>, <code class="language-plaintext highlighter-rouge">K2 = '$end_of_table'</code> - only <code class="language-plaintext highlighter-rouge">fir</code> had time to be inserted</li>
  <li><code class="language-plaintext highlighter-rouge">K1 = '$end_of_table'</code>, <code class="language-plaintext highlighter-rouge">K2 = badarg</code> - no elements were inserted</li>
</ul>

<p>However it is also possible to get:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">K1 = sec</code>, <code class="language-plaintext highlighter-rouge">K2 = '$end_of_table'</code></li>
</ul>

<p>This was, at first, very counter-intuitive to me. How can the <code class="language-plaintext highlighter-rouge">ets:first/1</code> find the
second value inserted, but then when iterating not find the value inserted before it?</p>

<p>The answer can be found in the way that the <code class="language-plaintext highlighter-rouge">write_concurrency</code> functionality is
implemented. Imagine we have a <a href="https://en.wikipedia.org/wiki/Hash_table">hash table</a>
where each bucket is protected by a mutex. When inserting a new element the mutex for
the current bucket has to be taken and when iterating over the hash table we take
each mutex in turn for the buckets we iterate through.</p>
      <h3 id="initial-table">
        
        
          Initial Table: <a href="#initial-table">#</a>
        
        
      </h3>
    

<table>
  <thead>
    <tr>
      <th>Bucket #</th>
      <th>Values</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
    <tr>
      <td>2</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
  </tbody>
</table>
      <h3 id="finished-table">
        
        
          Finished Table: <a href="#finished-table">#</a>
        
        
      </h3>
    

<table>
  <thead>
    <tr>
      <th>Bucket #</th>
      <th>Values</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><code class="language-plaintext highlighter-rouge">[{fir,1}]</code></td>
    </tr>
    <tr>
      <td>2</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td><code class="language-plaintext highlighter-rouge">[{sec,2}]</code></td>
    </tr>
  </tbody>
</table>

<p>So, in the scenario that leads to the strange behaviour the following will happen:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ets:first/1</code> is called when the table is empty and iterates to Bucket #2.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Bucket #</th>
      <th>Values</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
    <tr>
      <td>2 (first)</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>The OS does a context switch and P1 is allowed to run.</li>
  <li>P1 inserts both <code class="language-plaintext highlighter-rouge">{fir,1}</code> and <code class="language-plaintext highlighter-rouge">{sec,2}</code> and then exits.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Bucket #</th>
      <th>Values</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><code class="language-plaintext highlighter-rouge">[{fir,a}]</code></td>
    </tr>
    <tr>
      <td>2 (first)</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td><code class="language-plaintext highlighter-rouge">[{sec,b}]</code></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">ets:first/1</code> call resumes and will only see <code class="language-plaintext highlighter-rouge">sec</code> and then <code class="language-plaintext highlighter-rouge">'$end_of_table'</code>.</li>
</ul>

<p>When spelled out like this it becomes more logical that it is possible to get only
the element inserted as the second element. This is not normally a problem for
tables of type <code class="language-plaintext highlighter-rouge">set</code> which have an arbitrary iteration order that you canât depend on anyway.</p>

<p>However, for <code class="language-plaintext highlighter-rouge">ordered_set</code> you may very well depend on the defined iteration order
and expect <code class="language-plaintext highlighter-rouge">ets:first/1</code> to return a key that has at least been first in the table
at some point in time. But for the same reasons as with <code class="language-plaintext highlighter-rouge">set</code>, that is not guaranteed
if you need that guarantee you have to either not use <code class="language-plaintext highlighter-rouge">write_concurrency</code>,
find some other way to synchronize or rely on luckâ¦ these races are very rare, but in heavily
used tables they will eventually happen.</p>

<p>The same oddity applies to all kinds of table iterations; <code class="language-plaintext highlighter-rouge">ets:next/1</code>,
<code class="language-plaintext highlighter-rouge">ets:select/1-3</code>, <code class="language-plaintext highlighter-rouge">ets:match/1-3</code> and friends. They may all miss concurrently
inserted keys and return a key that has never existed in the table ordered
directly after the previously returned key.</p>

        
    </div>
</article>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-c.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-bash.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>