<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0020 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0020 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Richard A. O&#39;Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>05-Aug-2008</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>R12B-4</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                <h2 id="eep-20-split-the-atoms">EEP 20: Split the atoms!</h2>

<h1 id="abstract">Abstract</h1>

<p>An idea from the Logix implementation of Flat Concurrent Prolog
can be adapted to Erlang:  invisibly to users there can be two
implementations of ‘atoms’, fixing a major system integrity
issue and removing the need to warp one’s data structure design
to code around it.</p>

<h1 id="specification">Specification</h1>

<p>There are no user-visible changes to the Erlang language or
libraries.  Interfaces between Erlang and other languages such
as C may need to be changed.</p>

<p>We split atoms into two classes:  “global” atoms are those atoms
which either appear in the post-preprocessing text of some loaded
module or are the registered name of any process; “local” atoms
are all others which a process creates.</p>

<p>A local atom is represented by a data structure SUCH AS</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+----------+</span>
<span class="p">|</span> <span class="nb">size</span><span class="o">+</span><span class="n">tag</span> <span class="p">|</span>    <span class="n">boxed</span> <span class="n">object</span> <span class="n">header</span><span class="p">;</span> <span class="n">see</span> <span class="n">below</span>
<span class="o">+----------+</span>
<span class="p">|</span> <span class="n">hashcode</span> <span class="p">|</span>    <span class="n">a</span> <span class="mi">32</span><span class="o">-</span><span class="n">bit</span> <span class="nb">hash</span> <span class="n">code</span>
<span class="o">+----------+</span>
<span class="p">|</span> <span class="n">equivrep</span> <span class="p">|</span>    <span class="n">points</span> <span class="n">to</span> <span class="nv">Union</span><span class="o">/</span><span class="nv">Find</span> <span class="n">representative</span>
<span class="o">+----------+</span>
<span class="p">|</span> <span class="n">bytes</span> <span class="k">of</span> <span class="p">|</span>
<span class="p">|</span> <span class="n">name</span> <span class="p">...</span> <span class="p">|</span>
<span class="o">+----------+</span>
</code></pre></div></div>

<p>As usual, the size+tag contains a 2 bit tag to say it is an
IMMED2 object, a 4-bit subtag to say what kind (I propose
1011), and a 26-bit arity.  However, the arity field is
split into two subfields:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+--------------+------------+----+--+</span>
<span class="p">|</span>  <span class="n">byte</span> <span class="n">count</span>  <span class="p">|</span> <span class="n">char</span> <span class="n">count</span> <span class="p">|</span><span class="nv">LATM</span><span class="p">|</span><span class="nv">BX</span><span class="p">|</span>
<span class="o">+--------------+------------+----+--+</span>
             <span class="mi">14</span>           <span class="mi">12</span>    <span class="mi">4</span>   <span class="mi">2</span>   <span class="nb">size</span> <span class="n">in</span> <span class="n">bits</span>
</code></pre></div></div>

<p>The char count says how many Unicode characters there are in
the name.  The byte count says how many bytes those characters
are stored in.  For compactness and backwards compatibility,
an atom whose name consists only of Latin-1 characters has
byte count = char count and name represented as Latin-1; atoms
with names outside that range are held in some other form
<em>such as</em> UTF-8, SCSU, BOCU, or what have you.  This proposal
is not specifically about encoding schemes; all I have to say
here is that it should be the same for all atoms and it should
be at least as good as UTF-8.</p>

<p>The hash code field is a 32-bit hash code.  Again, I have
nothing to say about atom hashes as such except to say that
the method should be the same for all atoms in all processes
on a node and that it should be a good one.  Advice about
good hashing functions is hard to find.  <code class="language-plaintext highlighter-rouge">hashpjw()</code> can be
improved on.  I heartily recommend <a href="http://www.lulu.com/content/1455536" title="Hashing in Smalltalk: Theory and Practice, Andrés Valloud">Valloud’s book</a>.</p>

<p>The equivrep field is a pointer.  It always points to an atom,
which may be a global atom or a local atom.  Initially, it points
to the local atom itself.  When a local atom is compared with
another local atom,</p>

<ul>
  <li>first,   check the header fields to see if they match</li>
  <li>second,  check the hash codes to see if they match</li>
  <li>finally, check the bytes of the names.</li>
</ul>

<p>But this is also combined with Union/Find, very much like
binding variables in Prolog.  So we “dereference” (chase the
equivrep fields) after the second step, and if we end up at
the same place, the two local atoms are equal.  And if two
physically distinct local atoms do turn out equal, we make
the younger one (the one most recently created) point to the
older one.</p>

<p>Global atoms should have a similar representation; I suggest that
the representation of a local atom should be embedded in the
representation of a global atom, so that local atoms can be
compared with global atoms as if they were both local.</p>

<p>Atoms returned by <code class="language-plaintext highlighter-rouge">list_to_existing_atom/1</code> are always global atoms.
Atoms returned by <code class="language-plaintext highlighter-rouge">list_to_atom/1</code> or <code class="language-plaintext highlighter-rouge">binary_to_term/1</code> are global
atoms if and only if they are already existing global atoms,
otherwise they are local atoms.</p>

<p>Interfaces provided to other languages, such as C or Java, should
leave existing atom-creation operations returning global atoms,
and should add operations for creating local atoms.</p>

<p>When a process is garbage collected, a pointer to a local atom is
replaced by that local atom’s equivrep, so that processes that
have ever noticed they have duplicate local atoms don’t keep them
forever.</p>

<h1 id="motivation">Motivation</h1>

<p>There are a number of problems that limit the usefulness
of Erlang atoms.</p>

<p>The first is that atom size is limited to 255 bytes,
which makes Erlang atoms of very little use for file names,
as C’s <code class="language-plaintext highlighter-rouge">FILENAME_MAX</code> is typically 1024 these days.</p>

<p>The second is that atoms are limited to Latin-1 characters.
We really do want full Unicode support for them, not so
much for programmers to write atoms in strange scripts in
their source code as to allow information to flow <em>through</em>
an Erlang system as atoms.</p>

<p>Those two are minor problems.</p>

<p>The major problem is the atom table.</p>

<p>It is a global resource, which means that on an SMP system
there has to be a lot of locking and unlocking.  This proposal
doesn’t include a new “always return a local atom” operation,
but it creates the possibilities for new operations like that
which require no locking.</p>

<p>The atom table is limited, in atom.c, to <code class="language-plaintext highlighter-rouge">ATOM_LIMIT=1024*1024</code>
entries.  Even on a 32-bit system, this is smaller than a
machine could support; it is an arbitrary limit, and such limits
are always a problem.</p>

<p>The atom table is not garbage collected.  Once an atom has been
created, it says created.  Historic Prolog systems, like Quintus
Prolog, did the same thing.  Back in 1984 this was recognised as
a problem, especially for programs that wanted to access large
volumes of stored data.  Modern Prolog systems, like SWI Prolog,
do collect atoms; SWI Prolog would not be nearly so useful for
manipulating large collections of RDF data if it were otherwise.
This proposal does not add garbage collection for the atom table;
what it does is to stop most of the atoms that would have been
collected ever entering that table in the first place.</p>

<p>Filling up the atom table crashes or hangs the entire node.</p>

<p>This means that it is far too easy to crash or hash Erlang
software by feeding it too many atoms.</p>

<p>And <em>that</em> means that Erlang programmers who would like to use
atoms in data structures (as keys in dictionaries, say) use
binaries instead: binaries are not limited in size or number,
can hold UTF-8 if you want them to, are garbage collected, and
are generally safer to use.</p>

<p>While this proposal makes atoms more <em>convenient</em> to use (they
may be longer, more numerous, and may contain Unicode), the
real point is to make atoms <em>safer</em> to use.  If you can
stream data from source through an Erlang process, mapping
external “strings” to binaries, you will be able to do the
same thing just as safely mapping them to atoms.</p>

<h1 id="rationale">Rationale</h1>

<p>Erlang is not the first language to face these problems.
It isn’t even the first concurrent language to face them.
Flat Concurrent Prolog was there first, and while I have
not seen the Logix source code, the idea was explained in
Logix documentation many years ago.  I know this <em>can</em>
work because it <em>did</em> work.</p>

<p>Logix used this approach for all atoms; eventually, I
believe Erlang will need to as well in order to handle
thousands of processors without lots of locks.  Right now,
it makes sense to keep on using the old representation for
fairly “static” atoms.  In particular, we would like module
and function names (and frame keys when we have them) to be
just the way they are now.  If an application is loaded after a
local atom has been created, we may find that it is a module
name or function name after all; this is one of the reasons
for the equivrep field.  Once it’s noticed, the duplication
won’t survive another garbage collection.</p>

<p>The current ‘global atom’ representation has a hack to make
term comparison faster.  For simplicity I have not described
it above, because that’s orthogonal to the issues this EEP is
concerned with.  I note (a) that for the ord0 field to
continue in its present form, the encoding would best be
UTF-8 or BOCU, and (b) to keep the compactness of the Latin-1
atoms, the ord0 field should be the first 31 bits that <em>would</em>
have been stored had the atom been stored in whichever of
UTF-8 or BOCU is chosen.  I also note (c) that if you don’t
allow “native” byte ordering to dictate the order in which the
bytes of an atom’s name are stored, you don’t <em>need</em> a special
ord0 field.</p>

<p>I should confess that this proposal doesn’t <em>entirely</em> avoid the
crashes and hangs problem.  If an Erlang system can be persuaded
to load modules from an untrustworthy source, it can still be
made to try to create enough atoms to get into trouble.  This is
one of the reasons that I think Erlang will eventually have to
abandon the global atom table.  However, anyone who loads modules</p>

<p>from untrustworthy sources should KNOW they are doing that; it is
an obviously dangerous thing to do.  <code class="language-plaintext highlighter-rouge">list_to_atom/1</code> is NOT an
obviously dangerous function, and it should not be any more
dangerous than <code class="language-plaintext highlighter-rouge">list_to_binary/1</code>.</p>

<h1 id="backwards-compatibility">Backwards Compatibility</h1>

<p>No existing code (outside the Erlang implementation)
should be affected in the slightest.</p>

<h1 id="reference-implementation">Reference Implementation</h1>

<p>None.  The change is simple in concept, but affects several
atoms in the core of the system.</p>

<h1 id="copyright">Copyright</h1>

<p>This document has been placed in the public domain.</p>


            </div>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>