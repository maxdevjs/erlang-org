<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0008 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0008 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Tobias Lindahl &lt;tobias(dot)lindahl(at)it(dot)uu(dot)se&gt;
                            
                            , 
                            
                            
                            Kostis Sagonas &lt;kostis(at)it(dot)uu(dot)se&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>2-Dec-2007</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>R12B</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                <h2 id="eep-8-types-and-function-specifications">EEP 8: Types and function specifications</h2>

<h1 id="abstract">Abstract</h1>

<p>This EEP describes an extension to the Erlang language for
declaring sets of Erlang terms to form a particular type, effectively
forming a specific subtype of the set of all Erlang terms.
Subsequently, these types can be used to specify types of record
fields and argument and return values of functions.</p>

<h1 id="rationale">Rationale</h1>

<p>Type information can be used to document function interfaces, provide
more information for bug detection tools such as Dialyzer, and can be
exploited by documentation tools such as Edoc for generating program
documentation of various forms. It is expected that the type language
described in this document will supersede and eventually replace the
purely comment-based @type and @spec declarations used by Edoc.</p>

<h1 id="specification">Specification</h1>

<h2 id="types-and-their-syntax">Types and their syntax</h2>

<p>Types describe sets of Erlang terms. Types consist and are built from
a set of predefined types (e.g. <code class="language-plaintext highlighter-rouge">integer()</code>, <code class="language-plaintext highlighter-rouge">atom()</code>, <code class="language-plaintext highlighter-rouge">pid()</code>, …)
described below. Predefined types represent a typically infinite set
of Erlang terms which belong to this type. For example, the type
<code class="language-plaintext highlighter-rouge">atom()</code> stands for the set of all Erlang atoms.</p>

<p>For integers and atoms, we allow for singleton types (e.g. the
integers <code class="language-plaintext highlighter-rouge">-1</code> and <code class="language-plaintext highlighter-rouge">42</code> or the atoms <code class="language-plaintext highlighter-rouge">'foo'</code> and <code class="language-plaintext highlighter-rouge">'bar'</code>).</p>

<p>All other types are built using unions of either predefined types or
singleton types. In a type union between a type and one of its
subtypes the subtype is absorbed by the supertype and the union is
subsequently treated as if the subtype was not a constituent of the
union. For example, the type union::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">atom</span><span class="p">()</span> <span class="p">|</span> <span class="n">'bar'</span> <span class="p">|</span> <span class="nf">integer</span><span class="p">()</span> <span class="p">|</span> <span class="mi">42</span>
</code></pre></div></div>

<p>describes the same set of terms as the type union::</p>

<table>
  <tbody>
    <tr>
      <td>atom()</td>
      <td>integer()</td>
    </tr>
  </tbody>
</table>

<p>Because of subtype relations that exist between types, types form a
lattice where the topmost element, <code class="language-plaintext highlighter-rouge">any()</code>, denotes the set of all Erlang
terms and the bottommost element, <code class="language-plaintext highlighter-rouge">none()</code>, denotes the empty set of terms.</p>

<p>The set of predefined types and the syntax for types is given below::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Type</span> <span class="p">::</span> <span class="nf">any</span><span class="p">()</span>            <span class="c">%% The top type, the set of all Erlang terms.
</span>      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span>           <span class="c">%% The bottom type, contains no terms.
</span>      <span class="p">|</span> <span class="nf">pid</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">port</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">ref</span><span class="p">()</span>
      <span class="p">|</span> <span class="p">[]</span>               <span class="c">%% nil
</span>      <span class="p">|</span> <span class="nv">Atom</span>
      <span class="p">|</span> <span class="nv">Binary</span>
      <span class="p">|</span> <span class="nb">float</span><span class="p">()</span>
      <span class="p">|</span> <span class="nv">Fun</span>
      <span class="p">|</span> <span class="nv">Integer</span>
      <span class="p">|</span> <span class="nv">List</span>
      <span class="p">|</span> <span class="nv">Tuple</span>
      <span class="p">|</span> <span class="nv">Union</span>
      <span class="p">|</span> <span class="nv">UserDefined</span>      <span class="c">%% described in Section 2
</span></code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Union</span> <span class="p">::</span> <span class="nv">Type1</span> <span class="p">|</span> <span class="nv">Type2</span>

<span class="nv">Atom</span> <span class="p">::</span> <span class="nf">atom</span><span class="p">()</span>
      <span class="p">|</span> <span class="nv">Erlang_Atom</span>      <span class="c">%% 'foo', 'bar', ...
</span></code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Binary</span> <span class="p">::</span> <span class="nf">binary</span><span class="p">()</span>                        <span class="c">%% &lt;&lt;_:_ * 8&gt;&gt;
</span>        <span class="p">|</span> <span class="o">&lt;&lt;&gt;&gt;</span>
        <span class="p">|</span> <span class="o">&lt;&lt;</span><span class="p">_:</span><span class="nv">Erlang_Integer</span><span class="o">&gt;&gt;</span>            <span class="c">%% Base size
</span>        <span class="p">|</span> <span class="o">&lt;&lt;</span><span class="p">_:_</span><span class="o">*</span><span class="nv">Erlang_Integer</span><span class="o">&gt;&gt;</span>          <span class="c">%% Unit size
</span>        <span class="p">|</span> <span class="o">&lt;&lt;</span><span class="p">_:</span><span class="nv">Erlang_Integer</span><span class="p">,</span> <span class="p">_:_</span><span class="o">*</span><span class="nv">Erlang_Integer</span><span class="o">&gt;&gt;</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Fun</span> <span class="p">::</span> <span class="k">fun</span><span class="p">()</span>                              <span class="c">%% any function
</span>     <span class="p">|</span> <span class="k">fun</span><span class="p">((...)</span> <span class="o">-&gt;</span> <span class="nv">Type</span><span class="p">)</span>                 <span class="c">%% any arity, returning Type
</span>     <span class="p">|</span> <span class="k">fun</span><span class="p">(()</span> <span class="o">-&gt;</span> <span class="nv">Type</span><span class="p">)</span>
     <span class="p">|</span> <span class="k">fun</span><span class="p">((</span><span class="nv">TList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Type</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Integer</span> <span class="p">::</span> <span class="nf">integer</span><span class="p">()</span>
         <span class="p">|</span> <span class="nv">Erlang_Integer</span>                 <span class="c">%% ..., -1, 0, 1, ... 42 ...
</span>         <span class="p">|</span> <span class="nv">Erlang_Integer</span><span class="p">..</span><span class="nv">Erlang_Integer</span> <span class="c">%% specifies an integer range
</span></code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">List</span> <span class="p">::</span> <span class="nf">list</span><span class="p">(</span><span class="nv">Type</span><span class="p">)</span>                        <span class="c">%% Proper list ([]-terminated)
</span>      <span class="p">|</span> <span class="nf">improper_list</span><span class="p">(</span><span class="nv">Type1</span><span class="p">,</span> <span class="nv">Type2</span><span class="p">)</span>       <span class="c">%% Type1=contents, Type2=termination
</span>      <span class="p">|</span> <span class="nf">maybe_improper_list</span><span class="p">(</span><span class="nv">Type1</span><span class="p">,</span> <span class="nv">Type2</span><span class="p">)</span> <span class="c">%% Type1 and Type2 as above
</span></code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Tuple</span> <span class="p">::</span> <span class="nf">tuple</span><span class="p">()</span>                          <span class="c">%% stands for a tuple of any size
</span>       <span class="p">|</span> <span class="p">{}</span>
       <span class="p">|</span> <span class="p">{</span><span class="nv">TList</span><span class="p">}</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">TList</span> <span class="p">::</span> <span class="nv">Type</span>
       <span class="p">|</span> <span class="nv">Type</span><span class="p">,</span> <span class="nv">TList</span>
</code></pre></div></div>

<p>Because lists are commonly used, they have shorthand type notations.
The type <code class="language-plaintext highlighter-rouge">list(T)</code> has the shorthand <code class="language-plaintext highlighter-rouge">[T]</code>. The shorthand <code class="language-plaintext highlighter-rouge">[T,...]</code>
stands for the set of non-empty proper lists whose elements are of type <code class="language-plaintext highlighter-rouge">T</code>.
The only difference between the two shorthands is that <code class="language-plaintext highlighter-rouge">[T]</code> may be an
empty list but <code class="language-plaintext highlighter-rouge">[T,...]</code> may not.</p>

<p>Notice that the shorthand for <code class="language-plaintext highlighter-rouge">list()</code>, i.e. the list of elements of
unknown type, is <code class="language-plaintext highlighter-rouge">[_]</code> (or <code class="language-plaintext highlighter-rouge">[any()]</code>), not <code class="language-plaintext highlighter-rouge">[]</code>. The notation <code class="language-plaintext highlighter-rouge">[]</code>
specifies the singleton type for the empty list.</p>

<p>For convenience, the following types are also built-in. They can be
thought as predefined aliases for the type unions also shown in the
table. (Some type unions below slightly abuse the syntax of types.)</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">==========================</span>  <span class="o">=====================================</span>
      <span class="nv">Built</span><span class="o">-</span><span class="n">in</span> <span class="n">type</span>                   <span class="nv">Stands</span> <span class="n">for</span>
<span class="o">==========================</span>  <span class="o">=====================================</span>
<span class="err">``</span><span class="nf">term</span><span class="p">()</span><span class="err">``</span>                  <span class="err">``</span><span class="nf">any</span><span class="p">()</span><span class="err">``</span>
<span class="err">``</span><span class="nf">bool</span><span class="p">()</span><span class="err">``</span>                  <span class="err">``</span><span class="n">'false'</span> <span class="p">|</span> <span class="n">'true'</span><span class="err">``</span>
<span class="err">``</span><span class="nf">byte</span><span class="p">()</span><span class="err">``</span>                  <span class="err">``</span><span class="mi">0</span><span class="p">..</span><span class="mi">255</span><span class="err">``</span>
<span class="err">``</span><span class="nf">char</span><span class="p">()</span><span class="err">``</span>                  <span class="err">``</span><span class="mi">0</span><span class="p">..</span><span class="mi">16#10ffff</span><span class="err">``</span>
<span class="err">``</span><span class="nf">non_neg_integer</span><span class="p">()</span><span class="err">``</span>       <span class="err">``</span><span class="mi">0</span><span class="p">..</span><span class="err">``</span>
<span class="err">``</span><span class="nf">pos_integer</span><span class="p">()</span><span class="err">``</span>           <span class="err">``</span><span class="mi">1</span><span class="p">..</span><span class="err">``</span>
<span class="err">``</span><span class="nf">neg_integer</span><span class="p">()</span><span class="err">``</span>           <span class="err">``</span><span class="p">..</span><span class="o">-</span><span class="mi">1</span><span class="err">``</span>
<span class="err">``</span><span class="nf">number</span><span class="p">()</span><span class="err">``</span>                <span class="err">``</span><span class="nf">integer</span><span class="p">()</span> <span class="p">|</span> <span class="nb">float</span><span class="p">()</span><span class="err">``</span>
<span class="err">``</span><span class="nf">list</span><span class="p">()</span><span class="err">``</span>                  <span class="err">``</span><span class="p">[</span><span class="nf">any</span><span class="p">()]</span><span class="err">``</span>
<span class="err">``</span><span class="nf">maybe_improper_list</span><span class="p">()</span><span class="err">``</span>   <span class="err">``</span><span class="nf">maybe_improper_list</span><span class="p">(</span><span class="nf">any</span><span class="p">(),</span> <span class="nf">any</span><span class="p">())</span><span class="err">``</span>
<span class="err">``</span><span class="nf">maybe_improper_list</span><span class="p">(</span><span class="nv">T</span><span class="p">)</span><span class="err">``</span>  <span class="err">``</span><span class="nf">maybe_improper_list</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nf">any</span><span class="p">())</span><span class="err">``</span>
<span class="err">``</span><span class="nf">string</span><span class="p">()</span><span class="err">``</span>                <span class="err">``</span><span class="p">[</span><span class="nf">char</span><span class="p">()]</span><span class="err">``</span>
<span class="err">``</span><span class="nf">nonempty_string</span><span class="p">()</span><span class="err">``</span>       <span class="err">``</span><span class="p">[</span><span class="nf">char</span><span class="p">(),...]</span><span class="err">``</span>
<span class="err">``</span><span class="nf">iolist</span><span class="p">()</span><span class="err">``</span>                <span class="err">``</span><span class="nf">maybe_improper_list</span><span class="p">(</span><span class="err">``</span>
                                <span class="err">``</span><span class="nf">char</span><span class="p">()</span> <span class="p">|</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span><span class="err">``</span>
                                <span class="err">``</span><span class="nf">iolist</span><span class="p">(),</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[])</span><span class="err">``</span>
<span class="err">``</span><span class="nf">module</span><span class="p">()</span><span class="err">``</span>                <span class="err">``</span><span class="nf">atom</span><span class="p">()</span><span class="err">``</span>
<span class="err">``</span><span class="nf">mfa</span><span class="p">()</span><span class="err">``</span>                   <span class="err">``</span><span class="p">{</span><span class="nf">atom</span><span class="p">(),</span><span class="nf">atom</span><span class="p">(),</span><span class="nf">byte</span><span class="p">()}</span><span class="err">``</span>
<span class="err">``</span><span class="nb">node</span><span class="p">()</span><span class="err">``</span>                  <span class="err">``</span><span class="nf">atom</span><span class="p">()</span><span class="err">``</span>
<span class="err">``</span><span class="nf">timeout</span><span class="p">()</span><span class="err">``</span>               <span class="err">``</span><span class="n">'infinity'</span> <span class="p">|</span> <span class="nf">non_neg_integer</span><span class="p">()</span><span class="err">``</span>
<span class="err">``</span><span class="nf">no_return</span><span class="p">()</span><span class="err">``</span>             <span class="err">``</span><span class="nf">none</span><span class="p">()</span><span class="err">``</span>
<span class="o">==========================</span>  <span class="o">=====================================</span>
</code></pre></div></div>

<p>Users are not allowed to define types with the same names as the
predefined or built-in ones. This is checked by the compiler and its
violation results in a compilation error. (For bootstrapping purposes,
it can also result to just a warning if this involves a built-in type
which has just been introduced.)</p>

<p><strong>NOTE</strong>: The following built-in list types also exist, but they are
expected to be rarely used. Hence, they have long names:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">nonempty_maybe_improper_list</span><span class="p">(</span><span class="nv">Type</span><span class="p">)</span> <span class="p">::</span> <span class="nf">nonempty_maybe_improper_list</span><span class="p">(</span><span class="nv">Type</span><span class="p">,</span> <span class="nf">any</span><span class="p">())</span>
<span class="nf">nonempty_maybe_improper_list</span><span class="p">()</span> <span class="p">::</span> <span class="nf">nonempty_maybe_improper_list</span><span class="p">(</span><span class="nf">any</span><span class="p">())</span>
</code></pre></div></div>

<p>where the following two types</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">nonempty_improper_list</span><span class="p">(</span><span class="nv">Type1</span><span class="p">,</span> <span class="nv">Type2</span><span class="p">)</span>
<span class="nf">nonempty_maybe_improper_list</span><span class="p">(</span><span class="nv">Type1</span><span class="p">,</span> <span class="nv">Type2</span><span class="p">)</span>
</code></pre></div></div>

<p>define the set of Erlang terms one would expect.</p>

<p>Also for convenience, we allow for record notation to be used. Records
are just shorthands for the corresponding tuples:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Record</span> <span class="p">::</span> <span class="err">#</span><span class="nv">Erlang_Atom</span><span class="p">{}</span>
        <span class="p">|</span> <span class="err">#</span><span class="nv">Erlang_Atom</span><span class="p">{</span><span class="nv">Fields</span><span class="p">}</span>
</code></pre></div></div>

<p>Records have been extended to possibly contain type information. This
is described in Section 3 below.</p>

<h2 id="type-declarations-of-user-defined-types">Type declarations of user-defined types</h2>

<p>As seen, the basic syntax of a type is an atom followed by closed
parentheses. New types are declared using <code class="language-plaintext highlighter-rouge">'type'</code> compiler attributes
as in the following:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">type</span> <span class="nf">my_type</span><span class="p">()</span> <span class="p">::</span> <span class="nv">Type</span><span class="p">.</span>
</code></pre></div></div>

<p>where the type name is an atom (<code class="language-plaintext highlighter-rouge">'my_type'</code> in the above) followed by
parenthesis. Type is a type as defined in the previous section. A
current restriction is that Type can contain only predefined types or
user-defined types which have been previously defined. This
restriction is enforced by the compiler and results in a compilation
error. (A similar restriction currently exists for records).</p>

<p>This means that general recursive types cannot be defined. Lifting
this restriction is future work.</p>

<p>Type declarations can also be parametrized by including type variables
between the parentheses. The syntax of type variables is the same as
Erlang variables (starts with an upper case letter). Naturally, these
variables can - and should - appear on the RHS of the definition.
A concrete example appears below:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">type</span> <span class="nf">orddict</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Val</span><span class="p">)</span> <span class="p">::</span> <span class="p">[{</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Val</span><span class="p">}].</span>
</code></pre></div></div>

<h2 id="type-information-in-record-declarations">Type information in record declarations</h2>
<p>The types of record fields can be specified in the declaration of the
record. The syntax for this is:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">rec</span><span class="p">,</span> <span class="p">{</span><span class="n">field1</span> <span class="p">::</span> <span class="nv">Type1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,</span> <span class="n">field3</span> <span class="p">::</span> <span class="nv">Type3</span><span class="p">}).</span>
</code></pre></div></div>

<p>For fields without type annotations, their type defaults to <code class="language-plaintext highlighter-rouge">any()</code>.
I.e., the above is a shorthand for:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">rec</span><span class="p">,</span> <span class="p">{</span><span class="n">field1</span> <span class="p">::</span> <span class="nv">Type1</span><span class="p">,</span> <span class="n">field2</span> <span class="p">::</span> <span class="nf">any</span><span class="p">(),</span> <span class="n">field3</span> <span class="p">::</span> <span class="nv">Type3</span><span class="p">}).</span>
</code></pre></div></div>

<p>In the presence of initial values for fields, the type must be
declared after the initialisation as in the following:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">rec</span><span class="p">,</span> <span class="p">{</span><span class="n">field1</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">::</span> <span class="nv">Type1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,</span> <span class="n">field3</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">::</span> <span class="nv">Type3</span><span class="p">}).</span>
</code></pre></div></div>

<p>Naturally, the initial values for fields should be compatible with
(i.e. a member of) the corresponding types. This is checked by the
compiler and results in a compilation error if a violation is
detected. For fields without initial values, the singleton type
<code class="language-plaintext highlighter-rouge">'undefined'</code> is added to all declared types. In other words, the
following two record declarations have identical effects:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">rec</span><span class="p">,</span> <span class="p">{</span><span class="n">f1</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">::</span> <span class="nf">integer</span><span class="p">(),</span>
              <span class="n">f2</span>      <span class="p">::</span> <span class="nb">float</span><span class="p">(),</span>
              <span class="n">f3</span>      <span class="p">::</span> <span class="n">'a'</span> <span class="p">|</span> <span class="n">'b'</span><span class="p">).</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">rec</span><span class="p">,</span> <span class="p">{</span><span class="n">f1</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">::</span> <span class="nf">integer</span><span class="p">(),</span>
              <span class="n">f2</span>      <span class="p">::</span> <span class="n">'undefined'</span> <span class="p">|</span> <span class="nb">float</span><span class="p">(),</span>
              <span class="n">f3</span>      <span class="p">::</span> <span class="n">'undefined'</span> <span class="p">|</span> <span class="n">'a'</span> <span class="p">|</span> <span class="n">'b'</span><span class="p">).</span>
</code></pre></div></div>

<p>For this reason, it is recommended that records contain initializers,
whenever possible.</p>

<p>Any record, containing type information or not, once defined, can be
used as a type using the syntax:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">#rec</span><span class="p">{}</span>
</code></pre></div></div>

<p>In addition, the record fields can be further specified when using a
record type by adding type information about the field in the
following manner:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">#rec</span><span class="p">{</span><span class="n">some_field</span> <span class="p">::</span> <span class="nv">Type</span><span class="p">}</span>
</code></pre></div></div>

<p>Any unspecified fields are assumed to have the type in the original
record declaration.</p>

<h2 id="specifications-contracts-for-functions">Specifications (contracts) for functions</h2>
<p>A contract (or specification) for a function is given using the new
compiler attribute <code class="language-plaintext highlighter-rouge">'spec'</code>. The basic format is as follows:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">spec</span> <span class="nv">Module</span><span class="p">:</span><span class="nv">Function</span><span class="p">(</span><span class="nv">ArgType1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">ArgTypeN</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">ReturnType</span><span class="p">.</span>
</code></pre></div></div>

<p>The arity of the function has to match the number of arguments, or
else a compilation error occurs.</p>

<p>This form can also be used in header files (.hrl) to declare type
information for exported functions. Then these header files can be
included in files that (implicitly or explicitly) import these
functions.</p>

<p>For most uses within a given module, the following shorthand is allowed:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">spec</span> <span class="nv">Function</span><span class="p">(</span><span class="nv">ArgType1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">ArgTypeN</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">ReturnType</span><span class="p">.</span>
</code></pre></div></div>

<p>Also, for documentation purposes, argument names can be given:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">spec</span> <span class="nv">Function</span><span class="p">(</span><span class="nv">ArgName1</span> <span class="p">::</span> <span class="nv">Type1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">ArgNameN</span> <span class="p">::</span> <span class="nv">TypeN</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">RT</span><span class="p">.</span>
</code></pre></div></div>

<p>A function specification can be overloaded. That is, it can have
several types, separated by a semicolon (;):</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">spec</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">T3</span>
       <span class="p">;</span> <span class="p">(</span><span class="nv">T4</span><span class="p">,</span> <span class="nv">T5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">T6</span><span class="p">.</span>
</code></pre></div></div>

<p>A current restriction, which currently results in a warning (<em>OBS</em>: not
an error) by the compiler, is that the domains of the argument types
cannot be overlapping. For example, the following specification
results in a warning:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">spec</span> <span class="nf">foo</span><span class="p">(</span><span class="nf">pos_integer</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="nf">pos_integer</span><span class="p">()</span>
       <span class="p">;</span> <span class="p">(</span><span class="nf">integer</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="nf">integer</span><span class="p">().</span>
</code></pre></div></div>

<p>Type variables can be used in specifications to specify relations for
the input and output arguments of a function. For example, the
following specification defines the type of a polymorphic identity
function:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">spec</span> <span class="nf">id</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">X</span><span class="p">.</span>
</code></pre></div></div>

<p>However, note that the above specification does not restrict the input
and output type in any way. We can constrain these types by guard-like
subtype constraints:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">spec</span> <span class="nf">id</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">X</span> <span class="k">when</span> <span class="nf">is_subtype</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nf">tuple</span><span class="p">()).</span>
</code></pre></div></div>

<p>and provide bounded quantification. Currently, the <code class="language-plaintext highlighter-rouge">is_subtype/2</code> guard
is the only guard which can be used in a <code class="language-plaintext highlighter-rouge">'spec'</code> attribute.</p>

<p>The scope of an <code class="language-plaintext highlighter-rouge">is_subtype/2</code> constraint is the <code class="language-plaintext highlighter-rouge">(...) -&gt; RetType</code>
specification after which it appears. To avoid confusion, we suggest
that different variables are used in different constituents of an
overloaded contract as in the example below:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">spec</span> <span class="nf">foo</span><span class="p">({</span><span class="nv">X</span><span class="p">,</span> <span class="nf">integer</span><span class="p">()})</span> <span class="o">-&gt;</span> <span class="nv">X</span> <span class="k">when</span> <span class="nf">is_subtype</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nf">atom</span><span class="p">())</span>
       <span class="p">;</span> <span class="p">([</span><span class="nv">Y</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nv">Y</span> <span class="k">when</span> <span class="nf">is_subtype</span><span class="p">(</span><span class="nv">Y</span><span class="p">,</span> <span class="nf">number</span><span class="p">()).</span>
</code></pre></div></div>

<p>Some functions in Erlang are not meant to return; either because they
define servers or because they are used to throw exceptions as the
function below::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">my_error</span><span class="p">(</span><span class="nv">Err</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nn">erlang</span><span class="p">:</span><span class="nf">throw</span><span class="p">({</span><span class="n">error</span><span class="p">,</span> <span class="nv">Err</span><span class="p">}).</span>
</code></pre></div></div>

<p>For such functions we recommend the use of the special <code class="language-plaintext highlighter-rouge">no_return()</code>
type for their “return”, via a contract of the form::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span><span class="ni">spec</span> <span class="nf">my_error</span><span class="p">(</span><span class="nf">term</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="nf">no_return</span><span class="p">().</span>
</code></pre></div></div>

<h2 id="current-limitations">Current limitations</h2>
<p>The main limitation is the inability to define recursive types.</p>

<h1 id="copyright">Copyright</h1>

<p>This document has been placed in the public domain.</p>


            </div>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>