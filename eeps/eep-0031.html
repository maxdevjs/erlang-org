<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0031 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0031 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Patrik Nyblom &lt;pan(at)erlang(dot)org&gt;
                            
                            , 
                            
                            
                            Fredrik Svahn &lt;Fredrik(dot)Svahn(at)gmail&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Final/R14A Proposal is implemented in OTP release R14A</dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>28-Nov-2009</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>R13B03</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                <h2 id="eep-31-binary-manipulation-and-searching-module">EEP 31: Binary manipulation and searching module</h2>

<h1 id="abstract">Abstract</h1>

<p>This EEP contains developed suggestions regarding the module <code class="language-plaintext highlighter-rouge">binary</code>
first suggested in <a href="eep-0009.md" title="EEP 9, the original work from which this EEP is derived">EEP 9</a>.</p>

<p><a href="eep-0009.md" title="EEP 9, the original work from which this EEP is derived">EEP 9</a> suggests several modules and is partially superseded by later
EEP’s (i.e. <a href="eep-0011.md" title="EEP 11, intresting extensions to EEP 9">EEP 11</a>), while still containing valuable suggestions not
yet implemented. The remaining modules from <a href="eep-0009.md" title="EEP 9, the original work from which this EEP is derived">EEP 9</a> will therefore
appear in separate EEP’s. This construction is made in agreement with
the original author of <a href="eep-0009.md" title="EEP 9, the original work from which this EEP is derived">EEP 9</a>.</p>

<p>The module <code class="language-plaintext highlighter-rouge">binary</code> is suggested to contain fast searching
algorithms together with some common operations on binaries already
present for lists (in the lists module).</p>

<h1 id="motivation">Motivation</h1>

<p>While efficient searching is already present in the <code class="language-plaintext highlighter-rouge">re</code> library,
dedicated search functions can further speed up searching in
binaries, given an efficient implementation (i.e. Boyer-More
and Aho-Corassick algorithm). Another important advantage of
separate searching algorithms are ease of use to the programmer,
as the suggested interfaces do not require knowledge about regular
expression syntax and special characters in the binaries need not
be escaped. It’s interesting to note how often regular expressions
are used for simple sub-string searching or replacement, which can
with this suggested module be done easily.</p>

<p>Decomposition of binaries are usually done by using bit-syntax.
However some common operations are useful to have as ordinary functions,
both for performance and to support a more traditiona functional
programming style.</p>

<p>Some operations for converting lists to binaries and v.v. are today in
the erlang module. BIFs concerning binaries now present have varied
view of zero vs. one-based positioning in binaries. I.e.
<code class="language-plaintext highlighter-rouge">binary_to_list/3</code> uses one-based while <code class="language-plaintext highlighter-rouge">split_binary/2</code> uses
zero-based. As the convention is to use zero-based, new functions for
converting binaries to lists and v.v. are needed.</p>

<p>Binaries are in fact a shared data-type, with small binaries often
referencing parts of larger binaries in a way not controllable by
the programmer in a simple way. The bitstring data-type further
complicate things to the programmer in a way hard to easily
manage. I therefore also suggest some low level functions to
inspect binary representation and to clone binaries to ensure a
minimal representation.</p>

<p>As matching is not allowed in guard expressions, I furthermore suggest
that a function for extracting parts of binaries is added to the set
of guard BIFs. This would be consistent with the function element/2
being allowed in guards.</p>

<h1 id="rationale">Rationale</h1>

<p>For the lists data type there is a help library providing functions for
common operations such as searching and splitting lists.  This EEP suggests
that a similar set of library functions should be created for binaries.
Many of the proposed functions are based on answers to questions regarding
binaries on the erlang-questions mailing list, e.g. “how do I convert a
number to a binary?”. This EEP therefore suggests the addition of one
module in stdlib, namely a module <code class="language-plaintext highlighter-rouge">binary</code> which will implement the
requested functionality in an efficient way. Most of this module will
need to be implemented in native code (residing in the virtual
machine) why the proposed implementation will be delivered as “beta”
functionality in a forthcoming Erlang release.</p>

<p>The functionality suggested is the following:</p>

<ul>
  <li>
    <p>Functionality for searching, splitting and replacing in
binaries. The functionality in some ways will overlap that of the
regular expression library already present in Erlang, but will be
even more efficient and will have a simpler interface.</p>
  </li>
  <li>
    <p>Common operations on binaries that have their counterparts for lists
already in the stdlib module <code class="language-plaintext highlighter-rouge">lists</code>. While not all interfaces in
the <code class="language-plaintext highlighter-rouge">lists</code> module are applicable to binaries, many are. This module
also provides a good place for future operations on binaries,
operations that are not applicable to lists or that we still don’t
know the need for.</p>
  </li>
  <li>
    <p>Functions for converting lists to binaries and v.v. These functions
should have a consistent view of zero-based indexing in binaries.</p>
  </li>
  <li>
    <p>Operations on binaries concerning their internal
representation. This functionality is sometimes necessary to avoid
extensive use of memory due to the shared nature of the binaries. As
operations on binaries do not involve copying when binaries are
taken apart, programs can unknowingly (or at least unintentionally)
keep references to large binaries by holding seemingly small amounts
of data in the process. The O(1) nature of many operations on
binaries makes the data sharing necessary, but the effects can
sometimes be surprising. On the other hand, O(n) complexity and
instant memory explosions when splitting a binary would be even more
surprising, why the current behavior need to be retained. It is suggested
that functions for both inspecting the nature of sharing of a binary
and to clone a copy of a binary to avoid sharing effects is present
in this suggested module.</p>
  </li>
</ul>

<p>All functionality is to be applied to byte oriented binaries, never
bitstrings that do not have a bitlength that is a multiple of
eight. All binaries supplied to and returned by these functions should
pass the <code class="language-plaintext highlighter-rouge">is_binary/1</code> test, otherwise an error will be raised.</p>

<h2 id="suggested-module-reference">Suggested module reference</h2>

<p>I suggest the following functionality (presented as an excerpt of an Erlang
manual pages). A discussion about the interface can be found below.</p>

<h3 id="data-types">DATA TYPES</h3>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cp</span><span class="p">()</span>
</code></pre></div></div>

<p>Opaque data-type representing a compiled search-pattern.
guaranteed to be a tuple() to allow programs to distinguish it from
non precompiled search patterns.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">part</span><span class="p">()</span> <span class="o">=</span> <span class="p">{</span><span class="nv">Pos</span><span class="p">,</span><span class="nv">Length</span><span class="p">}</span>

<span class="nv">Start</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span>
<span class="nv">Length</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span>
</code></pre></div></div>

<p>A representaion of a part (or range) in a binary. <code class="language-plaintext highlighter-rouge">Start</code> is a
zero-based offset into a binary() and Length is the length of that
part. As input to functions in this module, a reverse part
specification is allowed, constructed with a negative <code class="language-plaintext highlighter-rouge">Length</code>, so
that the part of the binary begins at <code class="language-plaintext highlighter-rouge">Start</code> + <code class="language-plaintext highlighter-rouge">Length</code> and is
-<code class="language-plaintext highlighter-rouge">Length</code> long. This is useful for referencing the last N bytes
of a binary as <code class="language-plaintext highlighter-rouge">{size(Binary), -N}</code>. The functions in this module
always return part()’s with positive <code class="language-plaintext highlighter-rouge">Length</code>.</p>

<h3 id="exports">EXPORTS</h3>

<h4 id="compile_patternpattern---cp"><code class="language-plaintext highlighter-rouge">compile_pattern(Pattern) -&gt; cp()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Pattern</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span>
</code></pre></div></div>

<p>Builds an internal structure representing a compilation of a
search-pattern, later to be used in the find, split or replace
functions. The cp() returned is guaranteed to be a tuple() to allow
programs to distinguish it from non precompiled search patterns</p>

<p>When a list of binaries is given, it denotes a <em>set</em> of alternative
binaries to search for. I.e if <code class="language-plaintext highlighter-rouge">[&lt;&lt;"functional"&gt;&gt;, &lt;&lt;"programming"&gt;&gt;]</code> 
is given as <code class="language-plaintext highlighter-rouge">Pattern</code>, this means ‘‘either <code class="language-plaintext highlighter-rouge">&lt;&lt;"functional"&gt;&gt;</code> <em>or</em>
<code class="language-plaintext highlighter-rouge">&lt;&lt;"programming"&gt;&gt;</code>’’. The pattern is a <em>set</em> of alternatives; when
only a single binary is given, the set has only one element.</p>

<p>If pattern is not a binary or a flat proper list of binaries, a <code class="language-plaintext highlighter-rouge">badarg</code>
exception will be raised.</p>

<h4 id="matchsubject-pattern---found--no"><code class="language-plaintext highlighter-rouge">match(Subject, Pattern) -&gt; Found | no</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Pattern</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nf">cp</span><span class="p">()</span>
<span class="nv">Found</span> <span class="o">=</span> <span class="nf">part</span><span class="p">()</span>
</code></pre></div></div>

<p>The same as <code class="language-plaintext highlighter-rouge">match(Subject, Pattern, [])</code>.</p>

<h4 id="matchsubjectpatternoptions---found--no"><code class="language-plaintext highlighter-rouge">match(Subject,Pattern,Options) -&gt; Found | no</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Pattern</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nf">cp</span><span class="p">()</span>
<span class="nv">Found</span> <span class="o">=</span> <span class="nf">part</span><span class="p">()</span>
<span class="nv">Options</span> <span class="o">=</span> <span class="p">[</span> <span class="nv">Option</span> <span class="p">]</span>
<span class="nv">Option</span> <span class="o">=</span> <span class="p">{</span><span class="n">scope</span><span class="p">,</span> <span class="nf">part</span><span class="p">()}</span>
</code></pre></div></div>

<p>Searches for the first occurrence of <code class="language-plaintext highlighter-rouge">Pattern</code> in <code class="language-plaintext highlighter-rouge">Subject</code> and returns
the position and length.</p>

<p>The function will return
<code class="language-plaintext highlighter-rouge">{Pos,Length}</code> for the binary in <code class="language-plaintext highlighter-rouge">Pattern</code> starting at
the lowest position in <code class="language-plaintext highlighter-rouge">Subject</code>.</p>

<p>Example::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">find</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"abcde"</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="p">[</span><span class="o">&lt;&lt;</span><span class="s">"bcde"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"cd"</span><span class="o">&gt;&gt;</span><span class="p">],[]).</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
</code></pre></div></div>

<p>Even though <code class="language-plaintext highlighter-rouge">&lt;&lt;"cd"&gt;&gt;</code> ends before <code class="language-plaintext highlighter-rouge">&lt;&lt;"bcde"&gt;&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;&lt;"bcde"&gt;&gt;</code>
begins first and is therefore the first match. If two overlapping
matches begins at the same position, the longest is returned.</p>

<p>Summary of the options:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">{scope, {Start, Length}}</code>  <br />
Only the given part is searched. Return values still have offsets
from the beginning of <code class="language-plaintext highlighter-rouge">Subject</code>. A negative <code class="language-plaintext highlighter-rouge">Length</code> is
allowed as described in the <strong>TYPES</strong> section of this manual.</li>
</ul>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">The</span> <span class="n">found</span> <span class="nf">part</span><span class="p">()</span> <span class="n">is</span> <span class="n">returned</span><span class="p">,</span> <span class="k">if</span> <span class="n">none</span> <span class="k">of</span> <span class="n">the</span> <span class="n">strings</span> <span class="n">in</span> <span class="err">``</span><span class="nv">Pattern</span><span class="err">``</span> <span class="n">is</span>
<span class="n">found</span><span class="p">,</span> <span class="n">the</span> <span class="n">atom</span> <span class="err">``</span><span class="n">no</span><span class="err">``</span> <span class="n">is</span> <span class="n">returned</span><span class="p">.</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">For</span> <span class="n">a</span> <span class="n">descrition</span> <span class="k">of</span> <span class="err">``</span><span class="nv">Pattern</span><span class="err">``</span><span class="p">,</span> <span class="n">see</span> <span class="err">``</span><span class="n">compile_pattern</span><span class="o">/</span><span class="mi">1</span><span class="err">``</span><span class="p">.</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">If</span> <span class="err">``</span><span class="p">{</span><span class="n">scope</span><span class="p">,</span> <span class="p">{</span><span class="nv">Start</span><span class="p">,</span><span class="nv">Length</span><span class="p">}}</span><span class="err">``</span> <span class="n">is</span> <span class="n">given</span> <span class="n">in</span> <span class="n">the</span> <span class="n">options</span> <span class="n">such</span> <span class="n">that</span>
<span class="err">``</span><span class="nv">Start</span><span class="err">``</span> <span class="n">is</span> <span class="n">larger</span> <span class="n">than</span> <span class="n">the</span> <span class="nb">size</span> <span class="k">of</span> <span class="err">``</span><span class="nv">Subject</span><span class="err">``</span><span class="p">,</span> <span class="err">``</span><span class="nv">Start</span><span class="err">``</span> <span class="o">+</span>
<span class="err">``</span><span class="nv">Length</span><span class="err">``</span> <span class="n">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">zero</span> <span class="ow">or</span> <span class="err">``</span><span class="nv">Start</span><span class="err">``</span> <span class="o">+</span> <span class="err">``</span><span class="nv">Length</span><span class="err">``</span> <span class="n">is</span> <span class="n">larger</span> <span class="n">than</span>
<span class="n">the</span> <span class="nb">size</span> <span class="k">of</span> <span class="err">``</span><span class="nv">Subject</span><span class="err">``</span><span class="p">,</span> <span class="n">a</span> <span class="err">``</span><span class="n">badarg</span><span class="err">``</span> <span class="n">exception</span> <span class="n">is</span> <span class="n">raised</span><span class="p">.</span>
</code></pre></div></div>

<h4 id="matchessubject-pattern---found"><code class="language-plaintext highlighter-rouge">matches(Subject, Pattern) -&gt; Found</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Pattern</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nf">cp</span><span class="p">()</span>
<span class="nv">Found</span> <span class="o">=</span> <span class="p">[</span> <span class="nf">part</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="p">[]</span>
</code></pre></div></div>

<p>The same as <code class="language-plaintext highlighter-rouge">matches(Subject, Pattern, [])</code>.</p>

<h4 id="matchessubjectpatternoptions---found"><code class="language-plaintext highlighter-rouge">matches(Subject,Pattern,Options) -&gt; Found</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Pattern</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nf">cp</span><span class="p">()</span>
<span class="nv">Found</span> <span class="o">=</span> <span class="p">[</span> <span class="nf">part</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="p">[]</span>
<span class="nv">Options</span> <span class="o">=</span> <span class="p">[</span> <span class="nv">Option</span> <span class="p">]</span>
<span class="nv">Option</span> <span class="o">=</span> <span class="p">{</span><span class="n">scope</span><span class="p">,</span> <span class="nf">part</span><span class="p">()}</span>
</code></pre></div></div>

<p>Works like match, but the <code class="language-plaintext highlighter-rouge">Subject</code> is search until exhausted and
a list of all non-overlapping parts present in Pattern are returned (in order).</p>

<p>The first and <em>longest</em> match is preferred
to a shorter, which is illustrated by the following example::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">matches</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"abcde"</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="p">[</span><span class="o">&lt;&lt;</span><span class="s">"bcde"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"bc"</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"de"</span><span class="o">&gt;&gt;</span><span class="p">],[]).</span>
<span class="p">[{</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">}]</span>
</code></pre></div></div>

<p>The result shows that <code class="language-plaintext highlighter-rouge">&lt;&lt;"bcde"&gt;&gt;&gt;</code> is selected instead of the
shorter match <code class="language-plaintext highlighter-rouge">&lt;&lt;"bc"&gt;&gt;</code> (which would have given raise to one more
match,<code class="language-plaintext highlighter-rouge">&lt;&lt;"de"&gt;&gt;</code>). This corresponds to the behavior of
posix regular expressions (and programs like <code class="language-plaintext highlighter-rouge">awk</code>), but is not
consistent with alternative matches in <code class="language-plaintext highlighter-rouge">re</code> (and Perl), where
instead lexical ordering in the search pattern selects which string
matches.</p>

<p>If none of the strings in pattern is found, an empty list is returned.</p>

<p>For a descrition of <code class="language-plaintext highlighter-rouge">Pattern</code>, see <code class="language-plaintext highlighter-rouge">compile_pattern/1</code> and for a
desctioption of available options, see <code class="language-plaintext highlighter-rouge">match/3</code>.</p>

<p>If <code class="language-plaintext highlighter-rouge">{scope, {Start,Length}}</code> is given in the options such that
<code class="language-plaintext highlighter-rouge">Start</code> is larger than the size of <code class="language-plaintext highlighter-rouge">Subject</code>, <code class="language-plaintext highlighter-rouge">Start</code> +
<code class="language-plaintext highlighter-rouge">Length</code> is less than zero or <code class="language-plaintext highlighter-rouge">Start</code> + <code class="language-plaintext highlighter-rouge">Length</code> is larger than
the size of <code class="language-plaintext highlighter-rouge">Subject</code>, a <code class="language-plaintext highlighter-rouge">badarg</code> exception is raised.</p>

<h4 id="splitsubjectpattern---parts"><code class="language-plaintext highlighter-rouge">split(Subject,Pattern) -&gt; Parts</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Pattern</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nf">cp</span><span class="p">()</span>
<span class="nv">Parts</span> <span class="o">=</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span>
</code></pre></div></div>

<p>The same as <code class="language-plaintext highlighter-rouge">split(Subject, Pattern, [])</code>.</p>

<h4 id="splitsubjectpatternoptions---parts"><code class="language-plaintext highlighter-rouge">split(Subject,Pattern,Options) -&gt; Parts</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Pattern</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nf">cp</span><span class="p">()</span>
<span class="nv">Parts</span> <span class="o">=</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span>
<span class="nv">Options</span> <span class="o">=</span> <span class="p">[</span> <span class="nv">Option</span> <span class="p">]</span>
<span class="nv">Option</span> <span class="o">=</span> <span class="p">{</span><span class="n">scope</span><span class="p">,</span> <span class="nf">part</span><span class="p">()}</span> <span class="p">|</span> <span class="n">trim</span> <span class="p">|</span> <span class="n">global</span>
</code></pre></div></div>

<p>Splits Binary into a list of binaries based on <code class="language-plaintext highlighter-rouge">Pattern</code>. If the
option <code class="language-plaintext highlighter-rouge">global</code> is not given, only the first occurrence of
<code class="language-plaintext highlighter-rouge">Pattern</code> in <code class="language-plaintext highlighter-rouge">Subject</code> will give rise to a split.</p>

<p>The parts of <code class="language-plaintext highlighter-rouge">Pattern</code> actually found in <code class="language-plaintext highlighter-rouge">Subject</code> are not included
in the result.</p>

<p>Example::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">split</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="p">[</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">],[]).</span>
<span class="p">[</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="p">]</span> 
<span class="mi">2</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">split</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">9</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="p">[</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="o">&gt;&gt;</span><span class="p">],[</span><span class="n">global</span><span class="p">]).</span>
<span class="p">[</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="o">&gt;&gt;</span><span class="p">]</span> 
</code></pre></div></div>

<p>Summary of options:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">{scope, part()}</code>  <br />
Works as in <code class="language-plaintext highlighter-rouge">binary:match/3</code> and <code class="language-plaintext highlighter-rouge">binary:matches/3</code>. Note
that this only defines the scope of the search for matching
strings, it does not cut the binary before splitting. The
bytes before and after the scope will be kept in the result.
See example below.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">trim</code>  <br />
Removes trailing empty parts of the result (as does <code class="language-plaintext highlighter-rouge">trim</code>
in <code class="language-plaintext highlighter-rouge">re:split/3</code>)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">global</code>  <br />
Repeats the split until the <code class="language-plaintext highlighter-rouge">Subject</code> is
exhausted. Conceptually the <code class="language-plaintext highlighter-rouge">global</code> option makes <code class="language-plaintext highlighter-rouge">split</code>
work on the positions returned by <code class="language-plaintext highlighter-rouge">binary:matches/3</code>, while
it normally works on the position returned by
<code class="language-plaintext highlighter-rouge">binary:match/3</code>.</p>
  </li>
</ul>

<p>Example of the difference between a <code class="language-plaintext highlighter-rouge">scope</code> and taking the binary apart 
before splitting::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">split</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"banana"</span><span class="o">&gt;&gt;</span><span class="p">,[</span><span class="o">&lt;&lt;</span><span class="s">"a"</span><span class="o">&gt;&gt;</span><span class="p">],[{</span><span class="n">scope</span><span class="p">,{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}}]).</span>
<span class="p">[</span><span class="o">&lt;&lt;</span><span class="s">"ban"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"na"</span><span class="o">&gt;&gt;</span><span class="p">]</span>
<span class="mi">2</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">split</span><span class="p">(</span><span class="nn">binary</span><span class="p">:</span><span class="nf">part</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"banana"</span><span class="o">&gt;&gt;</span><span class="p">,{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}),[</span><span class="o">&lt;&lt;</span><span class="s">"a"</span><span class="o">&gt;&gt;</span><span class="p">],[]).</span>
<span class="p">[</span><span class="o">&lt;&lt;</span><span class="s">"n"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"n"</span><span class="o">&gt;&gt;</span><span class="p">]</span>
</code></pre></div></div>

<p>The return type is always a list of binaries which are all referencing
<code class="language-plaintext highlighter-rouge">Subject</code>. This means that the data in <code class="language-plaintext highlighter-rouge">Subject</code> is not actually
copied to new binaries and that <code class="language-plaintext highlighter-rouge">Subject</code> cannot be garbage
collected until the results of the split are no longer referenced.</p>

<p>For a descrition of <code class="language-plaintext highlighter-rouge">Pattern</code>, see <code class="language-plaintext highlighter-rouge">compile_pattern/1</code>.</p>

<h4 id="replacesubjectpatternreplacement---result"><code class="language-plaintext highlighter-rouge">replace(Subject,Pattern,Replacement) -&gt; Result</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Pattern</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nf">cp</span><span class="p">()</span>
<span class="nv">Replacement</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Result</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
</code></pre></div></div>

<p>The same as <code class="language-plaintext highlighter-rouge">replace(Subject,Pattern,Replacement,[])</code>.</p>

<h4 id="replacesubjectpatternreplacementoptions---result"><code class="language-plaintext highlighter-rouge">replace(Subject,Pattern,Replacement,Options) -&gt; Result</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Pattern</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nf">cp</span><span class="p">()</span>
<span class="nv">Replacement</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Result</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Options</span> <span class="o">=</span> <span class="p">[</span> <span class="nv">Option</span> <span class="p">]</span>
<span class="nv">Option</span> <span class="o">=</span> <span class="n">global</span> <span class="p">|</span> <span class="p">{</span><span class="n">scope</span><span class="p">,</span> <span class="nf">part</span><span class="p">()}</span> <span class="p">|</span> <span class="p">{</span><span class="n">insert_replaced</span><span class="p">,</span> <span class="nv">InsPos</span><span class="p">}</span>
<span class="nv">InsPos</span> <span class="o">=</span> <span class="nv">OnePos</span> <span class="p">|</span> <span class="p">[</span> <span class="nv">OnePos</span> <span class="p">]</span>
<span class="nv">OnePos</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span> <span class="o">=&lt;</span> <span class="nb">byte_size</span><span class="p">(</span><span class="nv">Replacement</span><span class="p">)</span>
</code></pre></div></div>

<p>Constructs a new binary by replacing the parts in <code class="language-plaintext highlighter-rouge">Subject</code> matching
<code class="language-plaintext highlighter-rouge">Pattern</code> with the content of <code class="language-plaintext highlighter-rouge">Replacement</code>.</p>

<p>If the matching sub-part of <code class="language-plaintext highlighter-rouge">Subject</code> giving raise to the
replacement is to be inserted in the result, the option
<code class="language-plaintext highlighter-rouge">{insert_replaced, InsPos}</code> will insert the matching part into
<code class="language-plaintext highlighter-rouge">Replacement</code> at the given position (or positions) before actually
inserting <code class="language-plaintext highlighter-rouge">Replacement</code> into the Subject. Example::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">replace</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"abcde"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"b"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"[]"</span><span class="o">&gt;&gt;</span><span class="p">,[{</span><span class="n">insert_replaced</span><span class="p">,</span><span class="mi">1</span><span class="p">}]).</span>
<span class="o">&lt;&lt;</span><span class="s">"a[b]cde"</span><span class="o">&gt;&gt;</span>
<span class="mi">2</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">replace</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"abcde"</span><span class="o">&gt;&gt;</span><span class="p">,[</span><span class="o">&lt;&lt;</span><span class="s">"b"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"d"</span><span class="o">&gt;&gt;</span><span class="p">],</span><span class="o">&lt;&lt;</span><span class="s">"[]"</span><span class="o">&gt;&gt;</span><span class="p">,</span>
                 <span class="p">[</span><span class="n">global</span><span class="p">,{</span><span class="n">insert_replaced</span><span class="p">,</span><span class="mi">1</span><span class="p">}]).</span>
<span class="o">&lt;&lt;</span><span class="s">"a[b]c[d]e"</span><span class="o">&gt;&gt;</span>
<span class="mi">3</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">replace</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"abcde"</span><span class="o">&gt;&gt;</span><span class="p">,[</span><span class="o">&lt;&lt;</span><span class="s">"b"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"d"</span><span class="o">&gt;&gt;</span><span class="p">],</span><span class="o">&lt;&lt;</span><span class="s">"[]"</span><span class="o">&gt;&gt;</span><span class="p">,</span>
                 <span class="p">[</span><span class="n">global</span><span class="p">,{</span><span class="n">insert_replaced</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]}]).</span>
<span class="o">&lt;&lt;</span><span class="s">"a[bb]c[dd]e"</span><span class="o">&gt;&gt;</span>
<span class="mi">4</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">replace</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"abcde"</span><span class="o">&gt;&gt;</span><span class="p">,[</span><span class="o">&lt;&lt;</span><span class="s">"b"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"d"</span><span class="o">&gt;&gt;</span><span class="p">],</span><span class="o">&lt;&lt;</span><span class="s">"[-]"</span><span class="o">&gt;&gt;</span><span class="p">,</span>
                 <span class="p">[</span><span class="n">global</span><span class="p">,{</span><span class="n">insert_replaced</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]}]).</span>
<span class="o">&lt;&lt;</span><span class="s">"a[b-b]c[d-d]e"</span><span class="o">&gt;&gt;</span>
</code></pre></div></div>

<p>If any position given in <code class="language-plaintext highlighter-rouge">InsPos</code> is greater than the size of
the replacement binary, a <code class="language-plaintext highlighter-rouge">badarg</code> exception is raised.</p>

<p>The options <code class="language-plaintext highlighter-rouge">global</code> and <code class="language-plaintext highlighter-rouge">{scope, part()}</code> works as for
<code class="language-plaintext highlighter-rouge">binary:split/3</code>. The return type is always a binary.</p>

<p>For a descrition of <code class="language-plaintext highlighter-rouge">Pattern</code>, see <code class="language-plaintext highlighter-rouge">compile_pattern/1</code>.</p>

<h4 id="longest_common_prefixbinaries---int"><code class="language-plaintext highlighter-rouge">longest_common_prefix(Binaries) -&gt; int()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Binaries</span> <span class="o">=</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span>
</code></pre></div></div>

<p>Returns the length of the longest common prefix of the binaries in the
list <code class="language-plaintext highlighter-rouge">Binaries</code>. Example::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">longest_common_prefix</span><span class="p">([</span><span class="o">&lt;&lt;</span><span class="s">"erlang"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"ergonomy"</span><span class="o">&gt;&gt;</span><span class="p">]).</span>
<span class="mi">2</span>
<span class="mi">2</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">longest_common_prefix</span><span class="p">([</span><span class="o">&lt;&lt;</span><span class="s">"erlang"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"perl"</span><span class="o">&gt;&gt;</span><span class="p">]).</span>
<span class="mi">0</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">Binaries</code> is not a flat list of binaries, a <code class="language-plaintext highlighter-rouge">badarg</code> exception
is raised.</p>

<h4 id="longest_common_suffixbinaries---int"><code class="language-plaintext highlighter-rouge">longest_common_suffix(Binaries) -&gt; int()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Binaries</span> <span class="o">=</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span>
</code></pre></div></div>

<p>Returns the length of the longest common suffix of the binaries in the
list <code class="language-plaintext highlighter-rouge">Binaries</code>. Example::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">longest_common_suffix</span><span class="p">([</span><span class="o">&lt;&lt;</span><span class="s">"erlang"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"fang"</span><span class="o">&gt;&gt;</span><span class="p">]).</span>
<span class="mi">3</span>
<span class="mi">2</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">longest_common_suffix</span><span class="p">([</span><span class="o">&lt;&lt;</span><span class="s">"erlang"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"perl"</span><span class="o">&gt;&gt;</span><span class="p">]).</span>
<span class="mi">0</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">Binaries</code> is not a flat list of binaries, a <code class="language-plaintext highlighter-rouge">badarg</code> exception
is raised.</p>

<h4 id="firstsubject---int"><code class="language-plaintext highlighter-rouge">first(Subject) -&gt; int()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
</code></pre></div></div>

<p>Returns the first byte of the binary as an integer. If the binary
length is zero, a <code class="language-plaintext highlighter-rouge">badarg</code> exception is raised.</p>

<h4 id="lastsubject---int"><code class="language-plaintext highlighter-rouge">last(Subject) -&gt; int()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
</code></pre></div></div>

<p>Returns the last byte of the binary as an integer. If the binary
length is zero, a <code class="language-plaintext highlighter-rouge">badarg</code> exception is raised.</p>

<h4 id="atsubject-pos---int"><code class="language-plaintext highlighter-rouge">at(Subject, Pos) -&gt; int()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Pos</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>Returns the byte at position <code class="language-plaintext highlighter-rouge">Pos</code> (zero-based) in the binary
<code class="language-plaintext highlighter-rouge">Subject</code> as an integer. If <code class="language-plaintext highlighter-rouge">Pos</code> &gt;= <code class="language-plaintext highlighter-rouge">byte_size(Subject)</code>, a
<code class="language-plaintext highlighter-rouge">badarg</code> exception is raised.</p>

<h4 id="partsubject-poslen---binary"><code class="language-plaintext highlighter-rouge">part(Subject, PosLen) -&gt; binary()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">PosLen</span> <span class="o">=</span> <span class="nf">part</span><span class="p">()</span>
</code></pre></div></div>

<p>Extracts the part of the binary described by <code class="language-plaintext highlighter-rouge">PosLen</code>.</p>

<p>Negative length can be used to extract bytes at the end of a binary::</p>
<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 
<span class="mi">1</span><span class="o">&gt;</span> <span class="nv">Bin</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;&gt;</span><span class="p">.</span>
<span class="mi">2</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">part</span><span class="p">(</span><span class="nv">Bin</span><span class="p">,{</span><span class="nb">byte_size</span><span class="p">(</span><span class="nv">Bin</span><span class="p">),</span> <span class="o">-</span><span class="mi">5</span><span class="p">)).</span>
<span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;&gt;</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">PosLen</code> in any way references outside the binary, a <code class="language-plaintext highlighter-rouge">badarg</code>
exception is raised.</p>

<h4 id="partsubject-pos-len---binary"><code class="language-plaintext highlighter-rouge">part(Subject, Pos, Len) -&gt; binary()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Pos</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span>
<span class="nv">Len</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span>
</code></pre></div></div>

<p>The same as <code class="language-plaintext highlighter-rouge">part(Subject, {Pos, Len})</code>.</p>

<h4 id="bin_to_listsubject---list"><code class="language-plaintext highlighter-rouge">bin_to_list(Subject) -&gt; list()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
</code></pre></div></div>

<p>The same as <code class="language-plaintext highlighter-rouge">bin_to_list(Subject,{0,byte_size(Subject)})</code>.</p>

<h4 id="bin_to_listsubject-poslen---list"><code class="language-plaintext highlighter-rouge">bin_to_list(Subject, PosLen) -&gt; list()</code></h4>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">PosLen</span> <span class="o">=</span> <span class="nf">part</span><span class="p">()</span>
</code></pre></div></div>

<p>Converts <code class="language-plaintext highlighter-rouge">Subject</code> to a list of int(), each int representing the
value of one byte. The <code class="language-plaintext highlighter-rouge">part()</code> denotes which part of the
<code class="language-plaintext highlighter-rouge">binary()</code> to convert. Example::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">bin_to_list</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"erlang"</span><span class="o">&gt;&gt;</span><span class="p">,{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">}).</span>
<span class="s">"rla"</span>
<span class="c">%% or [114,108,97] in list notation.
</span></code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">PosLen</code> in any way references outside the binary, a <code class="language-plaintext highlighter-rouge">badarg</code>
exception is raised.</p>

<h3 id="bin_to_listsubject-pos-len---list"><code class="language-plaintext highlighter-rouge">bin_to_list(Subject, Pos, Len) -&gt; list()</code></h3>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Pos</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span>
<span class="nv">Len</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span>
</code></pre></div></div>

<p>The same as <code class="language-plaintext highlighter-rouge">bin_to_list(Subject,{Pos,Len})</code>.</p>

<h4 id="list_to_binbytelist---binary"><code class="language-plaintext highlighter-rouge">list_to_bin(ByteList) -&gt; binary()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ByteList</span> <span class="o">=</span> <span class="nf">iodata</span><span class="p">()</span> <span class="p">(</span><span class="n">see</span> <span class="n">module</span> <span class="n">erlang</span><span class="p">)</span>
</code></pre></div></div>

<p>Works exactly like <code class="language-plaintext highlighter-rouge">erlang:list_to_binary/1</code>, added for completeness.</p>

<h4 id="copysubject---binary"><code class="language-plaintext highlighter-rouge">copy(Subject) -&gt; binary()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
</code></pre></div></div>

<p>The same as <code class="language-plaintext highlighter-rouge">copy(Subject, 1)</code>.</p>

<h3 id="copysubjectn---binary"><code class="language-plaintext highlighter-rouge">copy(Subject,N) -&gt; binary()</code></h3>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">N</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>Creates a binary with the content of <code class="language-plaintext highlighter-rouge">Subject</code> duplicated <code class="language-plaintext highlighter-rouge">N</code>
times.</p>

<p>This function will always create a new binary, even if <code class="language-plaintext highlighter-rouge">N</code> = 1. By
using <code class="language-plaintext highlighter-rouge">copy/1</code> on a binary referencing a larger binary, one might
free up the larger binary for garbage collection.</p>

<blockquote>
  <p>NOTE! By deliberately copying a single binary to avoid referencing a
larger binary, one might, instead of freeing up the larger binary for
later garbage collection, create much more binary data than
needed. Sharing binary data is usually good. Only in special cases,
when small parts reference large binaries and the large binaries are
no longer used <em>in any process</em>, deliberate copying might be a good idea.</p>
</blockquote>

<p>If <code class="language-plaintext highlighter-rouge">N</code> &lt; 0, a <code class="language-plaintext highlighter-rouge">badarg</code> exception is raised.</p>

<h4 id="referenced_byte_sizebinary---int"><code class="language-plaintext highlighter-rouge">referenced_byte_size(binary()) -&gt; int()</code></h4>

<p>If a binary references a larger binary (often described as being a
sub-binary), it can be useful to get the size of the actual referenced
binary. This function can be used in a program to trigger the
use of <code class="language-plaintext highlighter-rouge">copy/1</code>. By copying a binary, one might dereference the
original, possibly large, binary which a smaller binary is a reference
to.</p>

<p>Example::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">store</span><span class="p">(</span><span class="nv">Binary</span><span class="p">,</span> <span class="nv">GBSet</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="nv">NewBin</span> <span class="o">=</span> 
      <span class="k">case</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">referenced_byte_size</span><span class="p">(</span><span class="nv">Binary</span><span class="p">)</span> <span class="k">of</span>
          <span class="nv">Large</span> <span class="k">when</span> <span class="nv">Large</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">byte_size</span><span class="p">(</span><span class="nv">Binary</span><span class="p">)</span> <span class="o">-&gt;</span>
      	     <span class="nn">binary</span><span class="p">:</span><span class="nf">copy</span><span class="p">(</span><span class="nv">Binary</span><span class="p">);</span>
          <span class="p">_</span> <span class="o">-&gt;</span>
	     <span class="nv">Binary</span>
      <span class="k">end</span><span class="p">,</span>
  <span class="nn">gb_sets</span><span class="p">:</span><span class="nf">insert</span><span class="p">(</span><span class="nv">NewBin</span><span class="p">,</span><span class="nv">GBSet</span><span class="p">).</span>
</code></pre></div></div>

<p>In this example, we chose to copy the binary content before inserting
it in the <code class="language-plaintext highlighter-rouge">gb_set()</code> if it references a binary more than twice the size
of the data we’re going to keep. Of course different rules for when
copying will apply to different programs.</p>

<p>Binary sharing will occur whenever binaries are taken apart, this is
the fundamental reason why binaries are fast, decomposition can always
be done with O(1) complexity. In rare circumstances this data sharing
is however undesirable, why this function together with <code class="language-plaintext highlighter-rouge">copy/1</code>
might be useful when optimizing for memory use.</p>

<p>Example of binary sharing::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nv">A</span> <span class="o">=</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">copy</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="mi">100</span><span class="p">).</span>
<span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span> <span class="p">...</span>
<span class="mi">2</span><span class="o">&gt;</span> <span class="nb">byte_size</span><span class="p">(</span><span class="nv">A</span><span class="p">).</span>
<span class="mi">100</span>
<span class="mi">3</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">referenced_byte_size</span><span class="p">(</span><span class="nv">A</span><span class="p">)</span>
<span class="mi">100</span>
<span class="mi">4</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span><span class="p">_:</span><span class="mi">10</span><span class="o">/</span><span class="n">binary</span><span class="p">,</span><span class="nv">B</span><span class="p">:</span><span class="mi">10</span><span class="o">/</span><span class="n">binary</span><span class="p">,_</span><span class="o">/</span><span class="n">binary</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nv">A</span><span class="p">.</span>
<span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span> <span class="p">...</span>
<span class="mi">5</span><span class="o">&gt;</span> <span class="nb">byte_size</span><span class="p">(</span><span class="nv">B</span><span class="p">).</span>
<span class="mi">10</span>
<span class="mi">6</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">referenced_byte_size</span><span class="p">(</span><span class="nv">B</span><span class="p">)</span>
<span class="mi">100</span>
</code></pre></div></div>

<blockquote>
  <p>NOTE! Binary data is shared among processes. If another process still
references the larger binary, copying the part this process uses only
consumes more memory and will not free up the larger binary for garbage
collection. Use this kind of intrusive functions with extreme care,
and only if a <em>real</em> problem is detected.</p>
</blockquote>

<h4 id="encode_unsignedunsigned---binary"><code class="language-plaintext highlighter-rouge">encode_unsigned(Unsigned) -&gt; binary()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Unsigned</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>The same as <code class="language-plaintext highlighter-rouge">encode_unsigned(Unsigned,big)</code>.</p>

<h4 id="encode_unsignedunsignedendianess---binary"><code class="language-plaintext highlighter-rouge">encode_unsigned(Unsigned,Endianess) -&gt; binary()</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Unsigned</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="nv">Endianess</span> <span class="o">=</span> <span class="n">big</span> <span class="p">|</span> <span class="n">little</span>
</code></pre></div></div>

<p>Converts a positive integer to the smallest possible representation
in in a binary digit representation, either big or little endian.</p>

<p>Example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">encode_unsigned</span><span class="p">(</span><span class="mi">11111111</span><span class="p">,</span><span class="n">big</span><span class="p">).</span> 
<span class="o">&lt;&lt;</span><span class="mi">169</span><span class="p">,</span><span class="mi">138</span><span class="p">,</span><span class="mi">199</span><span class="o">&gt;&gt;</span>
</code></pre></div></div>

<h4 id="decode_unsignedsubject---unsigned"><code class="language-plaintext highlighter-rouge">decode_unsigned(Subject) -&gt; Unsigned</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Unsigned</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>The same as <code class="language-plaintext highlighter-rouge">encode_unsigned(Subject,big)</code>.</p>

<h4 id="decode_unsignedsubject-endianess---unsigned"><code class="language-plaintext highlighter-rouge">decode_unsigned(Subject, Endianess) -&gt; Unsigned</code></h4>

<p>Types:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Subject</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Endianess</span> <span class="o">=</span> <span class="n">big</span> <span class="p">|</span> <span class="n">little</span>
<span class="nv">Unsigned</span> <span class="o">=</span> <span class="nf">int</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>Converts the binary digit representation, in big or little endian, of
a positive integer in <code class="language-plaintext highlighter-rouge">Subject</code> to an Erlang int().</p>

<p>Example::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">decode_unsigned</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="mi">169</span><span class="p">,</span><span class="mi">138</span><span class="p">,</span><span class="mi">199</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">big</span><span class="p">).</span> 
<span class="mi">11111111</span>
</code></pre></div></div>

<h2 id="guard-bif">Guard BIF</h2>

<p>I suggest adding the functions <code class="language-plaintext highlighter-rouge">binary:part/2</code> and <code class="language-plaintext highlighter-rouge">binary:part/3</code>
to the set of BIFs allowed in guard tests. As guard BIFs are traditionally
put in the erlang module, the following names for the guard BIFs are
suggested::</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">erlang</span><span class="p">:</span><span class="n">binary_part</span><span class="o">/</span><span class="mi">2</span>
<span class="nn">erlang</span><span class="p">:</span><span class="n">binary_part</span><span class="o">/</span><span class="mi">3</span>
</code></pre></div></div>

<p>They should both work exactly as their counterparts in the binary module.</p>

<h2 id="interface-design-discussion">Interface design discussion</h2>

<p>As with all modules, there are a lot of arguments about the actual
interface, sometimes more than about the functionality. In this case a
number of parameters has to be considered.</p>

<ul>
  <li>
    <p>Effectiveness - The interface should be constructed so that fast
implementation is possible and so that code using the interface can
be written in an effective way. To not create unnecessary garbage is
one parameter, to allow for general code is another.</p>
  </li>
  <li>
    <p>Parameter ordering - I’ve chosen to make the binary subject the
first parameter in all applicable calls. Putting the subject first
corresponds to the <code class="language-plaintext highlighter-rouge">re</code> interface. The <code class="language-plaintext highlighter-rouge">lists</code> module, however,
usually has the subject as last parameter. We could go for that
instead, but unfortunately the <code class="language-plaintext highlighter-rouge">lists:sublist/{2,3}</code> interface,
which corresponds to the <code class="language-plaintext highlighter-rouge">part</code> function, has the subject
first, why following the conventions of <code class="language-plaintext highlighter-rouge">lists</code> would not only
break conformance with <code class="language-plaintext highlighter-rouge">re</code>, it would also give us a generally
non-stringent interface. The effect of not conforming to the
<code class="language-plaintext highlighter-rouge">lists</code> interface is that using function names from that module
would lead to confusion and therefore is avoided.</p>
  </li>
  <li>
    <p>Function naming - We have two related modules to take into account
when naming functions here. The module <code class="language-plaintext highlighter-rouge">re</code> is related to the
searching function (<code class="language-plaintext highlighter-rouge">match</code>, <code class="language-plaintext highlighter-rouge">replace</code> etc), while the <code class="language-plaintext highlighter-rouge">lists</code>
module is related to the decomposition functions (<code class="language-plaintext highlighter-rouge">first</code>,
<code class="language-plaintext highlighter-rouge">last</code> etc).</p>

    <p>I’ve basically retained the names from <code class="language-plaintext highlighter-rouge">re</code> when I find the
functionality, both in concept and interface to be similar
enough. The nature of regular expressions as small executable
programs, which is to much to say for a collection of binaries as
the patterns are in this module, prohibits the use of the function
name <code class="language-plaintext highlighter-rouge">run</code> for actually doing the searching. We use <code class="language-plaintext highlighter-rouge">match</code> and 
<code class="language-plaintext highlighter-rouge">matches</code> instead of <code class="language-plaintext highlighter-rouge">run</code>.</p>

    <p>As this module is more general than <code class="language-plaintext highlighter-rouge">re</code>, a function name like
<code class="language-plaintext highlighter-rouge">compile</code> is not really good. <code class="language-plaintext highlighter-rouge">re:compile</code> means “compile a
regular expression”, but what would <code class="language-plaintext highlighter-rouge">binary:compile</code> mean?
Therefore the pre-processing function is instead called
<code class="language-plaintext highlighter-rouge">compile_pattern</code>.</p>

    <p>When it comes to the <code class="language-plaintext highlighter-rouge">lists</code> module, the parameter ordering has
prevented me from reusing any function names but <code class="language-plaintext highlighter-rouge">last</code>, which
only takes one parameter in <code class="language-plaintext highlighter-rouge">lists</code> and there is no real
alternative there.</p>
  </li>
  <li>
    <p>Options or multiple functions - I believe a good rule of thumb is to
not have options that change the return type of the function, which
would have been the case if we i.e. had a <code class="language-plaintext highlighter-rouge">global</code> option to
<code class="language-plaintext highlighter-rouge">match/3</code> instead of a separate <code class="language-plaintext highlighter-rouge">matches/3</code> function.</p>

    <p>The fact that there are a manageable set of possible return types
for the searching and decomposition functions allows us to follow
that rule of thumb.</p>

    <p>(Unfortunately that rule could not be easilly followed in <code class="language-plaintext highlighter-rouge">re</code>, as the
rich assortment of options would have given rise to a non-manageable
amount of function names).</p>
  </li>
</ul>

<h1 id="performance">Performance</h1>

<p>Although the decomposition functions are not really faster than using
bit-syntax for decomposition, they create slightly less garbage than
the bit syntax. As they are not slower than bit-syntax, they also have
a purpose in allowing for a different programming style.</p>

<p>The match/replace/split functionality should be compared to similar
functionality in the <code class="language-plaintext highlighter-rouge">re</code> module. Implementation methods has to be
chosen so that this modules search functions are faster, or possibly
even significantly faster, than <code class="language-plaintext highlighter-rouge">re</code>.</p>

<h1 id="reference-implementation">Reference implementation</h1>

<p>A reference implementation was available on GitHub development branch 
before the final inclusion in R14A.</p>

<h1 id="copyright">Copyright</h1>

<p>This document is licensed under the <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons Attribution 3.0 License">Creative Commons license</a>.</p>


            </div>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>