<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0052 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0052 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Bj√∂rn Gustavsson &lt;bjorn(at)erlang(dot)org&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Accepted/23.0 Proposal is to be implemented in OTP release 23.0</dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>28-Jan-2020</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>23</dd>
                        
                        
                        <dt>Post-History:</dt>
                        <dd>28-Jan-2020</dd>
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                <h2 id="eep-52-allow-key-and-size-expressions-in-map-and-binary-matching">EEP 52: Allow key and size expressions in map and binary matching</h2>

<h1 id="abstract">Abstract</h1>

<p>This EEP proposes an extension to matching of binaries to allow the
size of a segment to be a guard expression and to the matching of maps
to allow the key to be a guard expression.</p>

<h1 id="specification">Specification</h1>

<p>We propose that in binary matching the size of a binary segment can be
a guard expression.  Here is an example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">example1</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="nv">Size</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="nv">Payload</span><span class="p">:((</span><span class="nv">Size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="n">binary</span><span class="p">,</span><span class="nv">Rest</span><span class="o">/</span><span class="n">binary</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="p">{</span><span class="nv">Payload</span><span class="p">,</span><span class="nv">Rest</span><span class="p">}.</span>
</code></pre></div></div>

<p>The same expressions as in guards are allowed, except that the
old-style type tests (such a <code class="language-plaintext highlighter-rouge">list/1</code> or <code class="language-plaintext highlighter-rouge">tuple/1</code>) are not
allowed.  Unless the expression consists of a single number or single
variable is must be enclosed in parentheses.  Any variables used in the
expression must have been previously bound, or become bound in the
same binary pattern as the expression.  That is, the following example
is illegal:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">illegal_example2</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="nv">X</span><span class="p">:</span><span class="nv">N</span><span class="p">,</span><span class="nv">T</span><span class="o">/</span><span class="n">binary</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="nv">X</span><span class="p">,</span><span class="nv">T</span><span class="p">}.</span>
</code></pre></div></div>

<p>A binary pattern will fail to match, if size expression in any of its
segments does not evaluate successfully or evaluates to a non-integer
value.  For example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">example3</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="nv">X</span><span class="p">:(</span><span class="mi">1</span><span class="o">/</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">X</span><span class="p">;</span>
<span class="nf">example3</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="nv">X</span><span class="p">:</span><span class="n">not_integer</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">X</span><span class="p">;</span>
<span class="nf">example3</span><span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">no_match</span><span class="p">.</span>
</code></pre></div></div>

<p>The first clause will not match because the evaluation of <code class="language-plaintext highlighter-rouge">1/0</code> fails.
The second clause will not match because the size evaluates to an atom.</p>

<p>In the current map matching syntax, the keys in a map pattern must be
a single value or a literal.  That leads to unnatural code if the keys
in a map are complex terms.  For example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">example4</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span> <span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Key</span> <span class="o">=</span> <span class="p">{</span><span class="n">tag</span><span class="p">,</span><span class="nv">X</span><span class="p">},</span>
    <span class="err">#</span><span class="p">{</span><span class="nv">Key</span> <span class="p">:</span><span class="o">=</span> <span class="nv">Value</span><span class="p">}</span> <span class="o">=</span> <span class="nv">M</span><span class="p">,</span>
    <span class="nv">Value</span><span class="p">.</span>
</code></pre></div></div>

<p>We propose that the key in a map pattern can be a guard expression.
That will allow the previous example to be written like this:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">example5</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span> <span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="err">#</span><span class="p">{{</span><span class="n">tag</span><span class="p">,</span><span class="nv">X</span><span class="p">}</span> <span class="p">:</span><span class="o">=</span> <span class="nv">Value</span><span class="p">}</span> <span class="o">=</span> <span class="nv">M</span><span class="p">,</span>
    <span class="nv">Value</span><span class="p">.</span>
</code></pre></div></div>

<p>All variables used in a key expression must be previously bound.
Thus, the following example is illegal:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">illegal_example6</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="err">#</span><span class="p">{</span><span class="nv">Key</span> <span class="p">:</span><span class="o">=</span> <span class="nv">Value</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="nv">Value</span><span class="p">.</span>
</code></pre></div></div>

<h1 id="motivation">Motivation</h1>

<p>The current limitations of map keys are surprising.  A literal tuple
such as <code class="language-plaintext highlighter-rouge">{a,b}</code> is allowed as a key, while a tuple with a variable
such as <code class="language-plaintext highlighter-rouge">{a,Var}</code> is not.</p>

<p>In binary matching, it has always been possible to multiply a matched
out number by  a small constant using the <code class="language-plaintext highlighter-rouge">unit:</code> modifier.  The proposed
extension makes is possible in more circumstances to match both header
and payload in the same binary pattern.</p>

<h1 id="rationale">Rationale</h1>

<h2 id="why-allow-guard-expressions">Why allow guard expressions?</h2>

<p>We did consider only allowing term construction and expressions using
arithmetic operators.  There are two reasons we went with guard
expression instead:</p>

<ul>
  <li>
    <p>It is easy to explain and understand exactly what expression are
allowed as segment sizes and as map keys, because the same type of
expressions are allowed in guards.</p>
  </li>
  <li>
    <p>When calculating the size of binary segment, a subset of guard BIFs
could conceivable be useful in practice.  For example: <code class="language-plaintext highlighter-rouge">ceiling/1</code>,
<code class="language-plaintext highlighter-rouge">round/1</code>, <code class="language-plaintext highlighter-rouge">byte_size/1</code>, <code class="language-plaintext highlighter-rouge">bit_size/1</code>, and <code class="language-plaintext highlighter-rouge">map_get/2</code>.  We did not
want an arbitrary list of allowed BIFs in size expressions, so the
only logical thing is to allow full guard expressions.</p>
  </li>
</ul>

<h2 id="why-are-not-absurd-size-expressions-compilation-errors">Why are not absurd size expressions compilation errors?</h2>

<p>Size expressions that obviously never evaluates to an integer will
not cause a compilation error (but may cause a warning).  For example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">example6</span><span class="p">(</span><span class="nv">Bin</span><span class="p">,</span> <span class="nv">V</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="o">&lt;&lt;</span><span class="nv">X</span><span class="p">:(</span><span class="nb">is_list</span><span class="p">(</span><span class="nv">V</span><span class="p">))</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nv">Bin</span><span class="p">,</span>
    <span class="nv">X</span><span class="p">.</span>
</code></pre></div></div>

<p>The reason is that rules for what is a legal Erlang program should be
simple and unambigous, to help both people and tools that generate
Erlang programs.</p>

<h2 id="why-are-parentheses-required-around-non-trivial-size-expressions">Why are parentheses required around non-trivial size expressions?</h2>

<p>For the same reason that they are required when constructing binaries,
namely that language grammar would be ambiguous without the
parentheses, since binary patterns use the characters <code class="language-plaintext highlighter-rouge">:</code>, <code class="language-plaintext highlighter-rouge">/</code>, and
<code class="language-plaintext highlighter-rouge">-</code> with a different meaning than in the rest of the language.</p>

<h1 id="backwards-compatibility">Backwards Compatibility</h1>

<p>Using the extended expressions segment size and map keys would cause a
compilation error in OTP 22 and previous releases.  Therefore, no
existing source code can be affected.</p>

<p>However, there are changes to the semantics of Core Erlang that may
make it necessary to update languages compilers or tools that generate
Core Erlang code.</p>

<p>There are two major changes:</p>

<ul>
  <li>
    <p>A binary pattern in Core Erlang is no longer allowed to bind and use
a variable in the same binary pattern.</p>
  </li>
  <li>
    <p>To fully support binary matching in receives, receives must be lowered
to more primitive operations.</p>
  </li>
</ul>

<h2 id="binary-matching-in-core-erlang">Binary matching in Core Erlang</h2>

<p>In Erlang, a variable can be bound in a binary pattern and used later
in the same pattern as the size of a segment:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">foo</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="nv">Sz</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span><span class="nv">X</span><span class="p">:</span><span class="nv">Sz</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">X</span><span class="p">.</span>
</code></pre></div></div>

<p>In OTP 22 and previous releases, the translation to Core Erlang is
straightforward:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">'foo'</span><span class="o">/</span><span class="mi">1</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="p">(_</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="k">case</span> <span class="p">_</span><span class="mi">0</span> <span class="k">of</span>
          <span class="o">&lt;</span><span class="err">#</span><span class="p">{</span><span class="err">#</span><span class="o">&lt;</span><span class="nv">Sz</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'integer'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]]),</span>
             <span class="err">#</span><span class="o">&lt;</span><span class="nv">X</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">Sz</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'integer'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]])}</span><span class="err">#</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
              <span class="nv">X</span>
          <span class="o">&lt;</span><span class="p">_</span><span class="mi">1</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
              <span class="c">%% Raise function_clause exception.
</span>              <span class="p">.</span>
              <span class="p">.</span>
              <span class="p">.</span>
        <span class="k">end</span>
</code></pre></div></div>

<p>While the translation is straightforward, all Core Erlang passes would need
to handle binding and using a variable in the same scope.  That would become
even more complicated if we were to allow expressions as segment sizes.</p>

<p>In OTP 23, all variables used in a segment size expression must be already
bound in the enclosing environment.  The previous example must be rewritten
like this using nested cases:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">'foo'</span><span class="o">/</span><span class="mi">1</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="p">(_</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span>
          <span class="k">case</span> <span class="p">_</span><span class="mi">0</span> <span class="k">of</span>
              <span class="o">&lt;</span><span class="err">#</span><span class="p">{</span><span class="err">#</span><span class="o">&lt;</span><span class="nv">Sz</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'integer'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]]),</span>
               <span class="err">#</span><span class="o">&lt;</span><span class="p">_</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">'all'</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'binary'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]])}</span><span class="err">#</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                  <span class="k">case</span> <span class="p">_</span><span class="mi">2</span> <span class="k">of</span>
                     <span class="o">&lt;</span><span class="err">#</span><span class="p">{</span><span class="err">#</span><span class="o">&lt;</span><span class="nv">X</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">Sz</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'integer'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]])}</span><span class="err">#</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                         <span class="nv">X</span>
                     <span class="o">&lt;</span><span class="p">_</span><span class="mi">3</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                         <span class="c">%% Raise function_clause exception.
</span>                         <span class="p">.</span>
                         <span class="p">.</span>
                         <span class="p">.</span>
                    <span class="k">end</span>
               <span class="o">&lt;</span><span class="p">_</span><span class="mi">4</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                    <span class="c">%% Raise function_clause exception.
</span>                    <span class="p">.</span>
                    <span class="p">.</span>
                    <span class="p">.</span>
              <span class="k">end</span>
</code></pre></div></div>

<p>However, as can be seen from the example, the code for raising the <code class="language-plaintext highlighter-rouge">function_clause</code>
exception has been duplicated.  The code duplication is no big deal in this simple
example, but it would be in a function where the binary matching clause was followed
by many other clauses.  To avoid the code duplication, we must use <code class="language-plaintext highlighter-rouge">letrec</code> with
the <code class="language-plaintext highlighter-rouge">letrec_goto</code> annotation:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">'foo'</span><span class="o">/</span><span class="mi">1</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="p">(_</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="p">(</span> <span class="n">letrec</span>
              <span class="n">'label^0'</span><span class="o">/</span><span class="mi">0</span> <span class="o">=</span>
                  <span class="k">fun</span> <span class="p">()</span> <span class="o">-&gt;</span>
                        <span class="k">case</span> <span class="p">_</span><span class="mi">0</span> <span class="k">of</span>
                          <span class="o">&lt;</span><span class="p">_</span><span class="mi">1</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                <span class="c">%% Raise function_clause exception.
</span>                                <span class="p">.</span>
                                <span class="p">.</span>
                                <span class="p">.</span>
                        <span class="k">end</span>
          <span class="n">in</span>  <span class="k">case</span> <span class="p">_</span><span class="mi">0</span> <span class="k">of</span>
                <span class="o">&lt;</span><span class="err">#</span><span class="p">{</span><span class="err">#</span><span class="o">&lt;</span><span class="nv">Sz</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'integer'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]]),</span>
                   <span class="err">#</span><span class="o">&lt;</span><span class="p">_</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">'all'</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'binary'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]])}</span><span class="err">#</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                    <span class="k">case</span> <span class="p">_</span><span class="mi">2</span> <span class="k">of</span>
                      <span class="o">&lt;</span><span class="err">#</span><span class="p">{</span><span class="err">#</span><span class="o">&lt;</span><span class="nv">X</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">Sz</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'integer'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]])}</span><span class="err">#</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                          <span class="nv">X</span>
                      <span class="o">&lt;</span><span class="p">_</span><span class="mi">3</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                            <span class="nb">apply</span> <span class="n">'label^0'</span><span class="o">/</span><span class="mi">0</span><span class="p">()</span>
                    <span class="k">end</span>
                <span class="o">&lt;</span><span class="p">_</span><span class="mi">4</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                      <span class="nb">apply</span> <span class="n">'label^0'</span><span class="o">/</span><span class="mi">0</span><span class="p">()</span>
              <span class="k">end</span>
          <span class="o">-</span><span class="p">|</span> <span class="p">[</span><span class="n">'letrec_goto'</span><span class="p">]</span> <span class="p">)</span>
</code></pre></div></div>

<p>When a <code class="language-plaintext highlighter-rouge">letrec</code> has been given the annotation <code class="language-plaintext highlighter-rouge">letrec_goto</code>, it will be
specially translated.  The <code class="language-plaintext highlighter-rouge">apply</code> operations will be translated to a goto
instead of a call to a local function.</p>

<h2 id="translating-receive-to-core-erlang">Translating receive to Core Erlang</h2>

<p>Consider this example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">bar</span><span class="p">(</span><span class="nv">Timeout</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">receive</span>
        <span class="p">{</span><span class="n">tag</span><span class="p">,</span><span class="nv">Msg</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nv">Msg</span>
    <span class="k">after</span>
        <span class="nv">Timeout</span> <span class="o">-&gt;</span>
            <span class="n">no_message</span>
    <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>In a OTP 22 and earlier, the translation to Core Erlang was straightforward:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">'bar'</span><span class="o">/</span><span class="mi">1</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="p">(</span><span class="nv">Timeout</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="k">receive</span>
          <span class="o">&lt;</span><span class="p">{</span><span class="n">'tag'</span><span class="p">,</span><span class="nv">Msg</span><span class="p">}</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
              <span class="nv">Msg</span>
        <span class="k">after</span> <span class="nv">Timeout</span> <span class="o">-&gt;</span>
          <span class="n">'no_message'</span>
</code></pre></div></div>

<p>In order to fully support binary matching in OTP 23, a <code class="language-plaintext highlighter-rouge">receive</code> in Erlang
has now been lowered to more primitive operations in Core Erlang:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">'foo'</span><span class="o">/</span><span class="mi">1</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="p">(</span><span class="nv">Timeout</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="p">(</span> <span class="n">letrec</span>
              <span class="n">'recv$^0'</span><span class="o">/</span><span class="mi">0</span> <span class="o">=</span>
                  <span class="k">fun</span> <span class="p">()</span> <span class="o">-&gt;</span>
                      <span class="k">let</span> <span class="o">&lt;</span><span class="nv">PeekSucceeded</span><span class="p">,</span><span class="nv">Message</span><span class="o">&gt;</span> <span class="o">=</span>
                          <span class="n">primop</span> <span class="nf">'recv_peek_message'</span><span class="p">()</span>
                      <span class="n">in</span>  <span class="k">case</span> <span class="nv">PeekSucceeded</span> <span class="k">of</span>
                            <span class="o">&lt;</span><span class="n">'true'</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                <span class="k">case</span> <span class="nv">Message</span> <span class="k">of</span>
                                  <span class="o">&lt;</span><span class="p">{</span><span class="n">'tag'</span><span class="p">,</span><span class="nv">Msg</span><span class="p">}</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                      <span class="n">do</span>  <span class="n">primop</span> <span class="nf">'remove_message'</span><span class="p">()</span>
                                          <span class="nv">Msg</span>
                                  <span class="o">&lt;</span><span class="nv">Other</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                      <span class="n">do</span>  <span class="n">primop</span> <span class="nf">'recv_next'</span><span class="p">()</span>
                                            <span class="nb">apply</span> <span class="n">'recv$^0'</span><span class="o">/</span><span class="mi">0</span><span class="p">()</span>
                                <span class="k">end</span>
                            <span class="o">&lt;</span><span class="n">'false'</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                <span class="k">let</span> <span class="o">&lt;</span><span class="nv">TimedOut</span><span class="o">&gt;</span> <span class="o">=</span>
                                    <span class="n">primop</span> <span class="nf">'recv_wait_timeout'</span><span class="p">(</span><span class="nv">Timeout</span><span class="p">)</span>
                                <span class="n">in</span>  <span class="k">case</span> <span class="nv">TimedOut</span> <span class="k">of</span>
                                      <span class="o">&lt;</span><span class="n">'true'</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                          <span class="n">do</span>  <span class="n">primop</span> <span class="nf">'timeout'</span><span class="p">()</span>
                                              <span class="n">'no_message'</span>
                                      <span class="o">&lt;</span><span class="n">'false'</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                          <span class="nb">apply</span> <span class="n">'recv$^0'</span><span class="o">/</span><span class="mi">0</span><span class="p">()</span>
                                    <span class="k">end</span>
                          <span class="k">end</span>
          <span class="n">in</span>  <span class="nb">apply</span> <span class="n">'recv$^0'</span><span class="o">/</span><span class="mi">0</span><span class="p">()</span>
          <span class="o">-</span><span class="p">|</span> <span class="p">[</span><span class="n">'letrec_goto'</span><span class="p">]</span> <span class="p">)</span>
</code></pre></div></div>

<p>When compiling from Core Erlang code in OTP 23, the compiler will
accept Core Erlang code that uses the <code class="language-plaintext highlighter-rouge">receive</code> construct and
automatically lower it to the more primitive operations.  That is,
for the example above, the Core Erlang translation from OTP 22 will
be accepted as input to the compiler in OTP 23.</p>

<p>Here is another example where the Core Erlang code from OTP 22
will not be accepted.  Here is the Erlang code:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">foobar</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="k">receive</span>
        <span class="o">&lt;&lt;</span><span class="nv">Sz</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span><span class="nv">X</span><span class="p">:</span><span class="nv">Sz</span><span class="o">&gt;&gt;</span> <span class="o">-&gt;</span> <span class="nv">X</span>
    <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>In OTP 22, this would be translated to Core Erlang code like this:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">'foobar'</span><span class="o">/</span><span class="mi">0</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="p">()</span> <span class="o">-&gt;</span>
        <span class="k">receive</span>
          <span class="o">&lt;</span><span class="err">#</span><span class="p">{</span><span class="err">#</span><span class="o">&lt;</span><span class="nv">Sz</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'integer'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]]),</span>
             <span class="err">#</span><span class="o">&lt;</span><span class="nv">X</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">Sz</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'integer'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]])}</span><span class="err">#</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
              <span class="nv">X</span>
        <span class="k">after</span> <span class="n">'infinity'</span> <span class="o">-&gt;</span>
          <span class="n">'true'</span>
</code></pre></div></div>

<p>That translation will not be accepted by the compiler in OTP 23.  The <code class="language-plaintext highlighter-rouge">receive</code>
must be lowered to more primitive operations, and the binary matching must be
rewritten using nested cases:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">'foobar'</span><span class="o">/</span><span class="mi">0</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="p">()</span> <span class="o">-&gt;</span>
        <span class="p">(</span> <span class="n">letrec</span>
              <span class="n">'recv$^0'</span><span class="o">/</span><span class="mi">0</span> <span class="o">=</span>
                  <span class="k">fun</span> <span class="p">()</span> <span class="o">-&gt;</span>
                      <span class="k">let</span> <span class="o">&lt;</span><span class="p">_</span><span class="mi">5</span><span class="p">,_</span><span class="mi">0</span><span class="o">&gt;</span> <span class="o">=</span>
                          <span class="n">primop</span> <span class="nf">'recv_peek_message'</span><span class="p">()</span>
                      <span class="n">in</span>  <span class="k">case</span> <span class="p">_</span><span class="mi">5</span> <span class="k">of</span>
                            <span class="o">&lt;</span><span class="n">'true'</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                <span class="p">(</span> <span class="n">letrec</span>
                                      <span class="n">'label^0'</span><span class="o">/</span><span class="mi">0</span> <span class="o">=</span>
                                          <span class="k">fun</span> <span class="p">()</span> <span class="o">-&gt;</span>
                                                <span class="n">do</span>  <span class="n">primop</span> <span class="nf">'recv_next'</span><span class="p">()</span>
                                                    <span class="nb">apply</span> <span class="n">'recv$^0'</span><span class="o">/</span><span class="mi">0</span><span class="p">()</span>
                                  <span class="n">in</span>  <span class="k">case</span> <span class="p">_</span><span class="mi">0</span> <span class="k">of</span>
                                        <span class="o">&lt;</span><span class="err">#</span><span class="p">{</span><span class="err">#</span><span class="o">&lt;</span><span class="nv">Sz</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'integer'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]]),</span>
                                           <span class="err">#</span><span class="o">&lt;</span><span class="p">_</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">'all'</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'binary'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]])}</span><span class="err">#</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                            <span class="k">case</span> <span class="p">_</span><span class="mi">1</span> <span class="k">of</span>
                                              <span class="o">&lt;</span><span class="err">#</span><span class="p">{</span><span class="err">#</span><span class="o">&lt;</span><span class="nv">X</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">Sz</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">'integer'</span><span class="p">,[</span><span class="n">'unsigned'</span><span class="p">|[</span><span class="n">'big'</span><span class="p">]])}</span><span class="err">#</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                                  <span class="n">do</span>  <span class="n">primop</span> <span class="nf">'remove_message'</span><span class="p">()</span>
                                                      <span class="nv">X</span>
                                              <span class="o">&lt;</span><span class="p">_</span><span class="mi">2</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                                    <span class="nb">apply</span> <span class="n">'label^0'</span><span class="o">/</span><span class="mi">0</span><span class="p">()</span>
                                            <span class="k">end</span>
                                        <span class="o">&lt;</span><span class="p">_</span><span class="mi">3</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                              <span class="nb">apply</span> <span class="n">'label^0'</span><span class="o">/</span><span class="mi">0</span><span class="p">()</span>
                                      <span class="k">end</span>
                                  <span class="o">-</span><span class="p">|</span> <span class="p">[</span><span class="n">'letrec_goto'</span><span class="p">]</span> <span class="p">)</span>
                            <span class="o">&lt;</span><span class="n">'false'</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                  <span class="k">let</span> <span class="o">&lt;</span><span class="p">_</span><span class="mi">4</span><span class="o">&gt;</span> <span class="o">=</span>
                                      <span class="n">primop</span> <span class="nf">'recv_wait_timeout'</span>
                                          <span class="p">(</span><span class="n">'infinity'</span><span class="p">)</span>
                                  <span class="n">in</span>  <span class="k">case</span> <span class="p">_</span><span class="mi">4</span> <span class="k">of</span>
                                        <span class="o">&lt;</span><span class="n">'true'</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                            <span class="n">do</span>  <span class="n">primop</span> <span class="nf">'timeout'</span><span class="p">()</span>
                                                <span class="n">'true'</span>
                                        <span class="o">&lt;</span><span class="n">'false'</span><span class="o">&gt;</span> <span class="k">when</span> <span class="n">'true'</span> <span class="o">-&gt;</span>
                                            <span class="nb">apply</span> <span class="n">'recv$^0'</span><span class="o">/</span><span class="mi">0</span><span class="p">()</span>
                                      <span class="k">end</span>
                          <span class="k">end</span>
          <span class="n">in</span> <span class="nb">apply</span> <span class="n">'recv$^0'</span><span class="o">/</span><span class="mi">0</span><span class="p">()</span> <span class="p">)</span>
          <span class="o">-</span><span class="p">|</span> <span class="p">[</span><span class="n">'letrec_goto'</span><span class="p">]</span>
</code></pre></div></div>

<h1 id="implementation">Implementation</h1>

<p>The implementation can be found in <a href="https://github.com/erlang/otp/pull/2521" title="#2521: Allow key and size expressions in map and binary matching">PR #2521</a>.</p>

<h1 id="copyright">Copyright</h1>

<p>This document has been placed in the public domain.</p>


            </div>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>