<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0048 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0048 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            José Valim &lt;jose(dot)valim(at)gmail(dot)com&gt;
                            
                            , 
                            
                            
                            Eric Bailey
                            
                            , 
                            
                            
                            Radek Szymczyszyn
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>04-Jan-2018</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                <h2 id="eep-48-documentation-storage-and-format">EEP 48: Documentation storage and format</h2>

<h1 id="abstract">Abstract</h1>

<p>This EEP proposes an official API documentation storage to be used by
by BEAM languages.  By standardizing how API documentation is stored,
it will be possible to write tools that work across languages.</p>

<h1 id="rationale">Rationale</h1>

<p>Currently, different programming languages and libraries running on
BEAM devise their own schemas for storing and accessing documentation.<br />
For example, Elixir and LFE provide a <code class="language-plaintext highlighter-rouge">h</code> helper in their shell that
can print the documentation of any module:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">h</span> <span class="nv">String</span>
<span class="nv">A</span> <span class="nv">String</span> <span class="n">in</span> <span class="nv">Elixir</span> <span class="n">is</span> <span class="n">a</span> <span class="nv">UTF</span><span class="o">-</span><span class="mi">8</span> <span class="n">encoded</span> <span class="n">binary</span><span class="p">.</span>
</code></pre></div></div>

<p>However, Elixir is only able to show docs for Elixir modules.  LFE is
only able to show docs for LFE functions and so on.  If documentation
is standardized, such features can be easily added to other languages
in a way that works consistently across all BEAM languages.</p>

<p>Furthermore, each language ends up building their own tools for
generating, processing and converting documentation.  We hope a unified
approach to documentation will improve the compatibility between tools.
For instance, an Erlang IDE will be able to show inline documentation
for any module and function, regardless if the function is part of OTP,
a library or even written in Elixir, LFE or Alpaca.</p>

<p><strong>Note</strong>: in this document, the word “documentation” refers exclusively
to the API documentation of modules and functions.  Guides, tutorials
and others materials are also essential to projects but not the focus
of this EEP.</p>

<p><strong>Note</strong>: This EEP is not about documentation format.  It is about a
mechanism for storing documentation to make it easier to produce other
formats.  For example, a tool can read the documentation and produce man
pages from it.</p>

<h1 id="specification">Specification</h1>

<p>This EEP is divided in three parts.  The first defines the two
places the documentation can be stored, the second defines the shape of
the documentation and the third discusses integration with OTP.</p>

<h2 id="part-1-the-docsstorage">Part 1: the “Docs”storage</h2>

<p>There are two main mechanisms in which BEAM languages store documentation:
in the filesystem (usually in the <code class="language-plaintext highlighter-rouge">/doc</code> directory) and inside <code class="language-plaintext highlighter-rouge">.beam</code>
files.</p>

<p>This EEP recognizes both options and aim to support both.  To look for
documentation for a module name <code class="language-plaintext highlighter-rouge">example</code>, a tool should:</p>

<ol>
  <li>
    <p>Look for <code class="language-plaintext highlighter-rouge">example.beam</code> in the code path, parse the BEAM file and
retrieve the <code class="language-plaintext highlighter-rouge">Docs</code> chunk</p>
  </li>
  <li>
    <p>If the chunk is not available, it should look for “example.beam”
in the code path and find the <code class="language-plaintext highlighter-rouge">doc/chunks/example.chunk</code> file in
the application that defines the <code class="language-plaintext highlighter-rouge">example</code> module</p>
  </li>
  <li>
    <p>If a <code class="language-plaintext highlighter-rouge">.chunk</code> file is not available, then documentation is not
available</p>
  </li>
</ol>

<p>The choice of using a chunk or the filesystem is completely up to the
language or library.  In both cases, the documentation can be added or
removed at any moment by stripping the <code class="language-plaintext highlighter-rouge">Docs</code> chunk or by removing the
<code class="language-plaintext highlighter-rouge">doc/chunks</code> directory.</p>

<p>For example, languages like Elixir and LFE attach the <code class="language-plaintext highlighter-rouge">Docs</code> chunk at
compilation time, which can be controlled via a compiler flag.  On the
other hand, projects like OTP itself will likely generate the <code class="language-plaintext highlighter-rouge">doc/chunks</code>
entries on a separate command, completely unrelated from code compilation.</p>

<h2 id="part-2-the-docs-format">Part 2: the “Docs” format</h2>

<p>In both storages, the documentation is written in the exactly same
format: an Erlang term serialized to binary via <code class="language-plaintext highlighter-rouge">term_to_binary/1</code>.
The term may be optionally compressed when serialized and must follow
the type specification below:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">docs_v1</span><span class="p">,</span>
 <span class="nv">Anno</span> <span class="p">::</span> <span class="nn">erl_anno</span><span class="p">:</span><span class="nf">anno</span><span class="p">(),</span>
 <span class="nv">BeamLanguage</span> <span class="p">::</span> <span class="nf">atom</span><span class="p">(),</span>
 <span class="nv">Format</span> <span class="p">::</span> <span class="nf">mime_type</span><span class="p">(),</span>
 <span class="nv">ModuleDoc</span> <span class="p">::</span> <span class="err">#</span><span class="p">{</span><span class="nf">optional</span><span class="p">(</span><span class="nv">DocLanguage</span><span class="p">)</span> <span class="p">:</span><span class="o">=</span> <span class="nv">DocValue</span><span class="p">}</span> <span class="p">|</span> <span class="n">none</span> <span class="p">|</span> <span class="n">hidden</span><span class="p">,</span>
 <span class="nv">Metadata</span> <span class="p">::</span> <span class="nf">map</span><span class="p">(),</span>
 <span class="nv">Docs</span> <span class="p">::</span>
   <span class="p">[{{</span><span class="nv">Kind</span><span class="p">,</span> <span class="nv">Name</span><span class="p">,</span> <span class="nv">Arity</span><span class="p">},</span>
     <span class="nv">Anno</span> <span class="p">::</span> <span class="nn">erl_anno</span><span class="p">:</span><span class="nf">anno</span><span class="p">(),</span>
     <span class="nv">Signature</span> <span class="p">::</span> <span class="p">[</span><span class="nf">binary</span><span class="p">()],</span>
     <span class="nv">Doc</span> <span class="p">::</span> <span class="err">#</span><span class="p">{</span><span class="nf">optional</span><span class="p">(</span><span class="nv">DocLanguage</span><span class="p">)</span> <span class="p">:</span><span class="o">=</span> <span class="nv">DocValue</span><span class="p">}</span> <span class="p">|</span> <span class="n">none</span> <span class="p">|</span> <span class="n">hidden</span><span class="p">,</span>
     <span class="nv">Metadata</span> <span class="p">::</span> <span class="nf">map</span><span class="p">()</span>
    <span class="p">}]}</span> <span class="k">when</span> <span class="nv">DocLanguage</span> <span class="p">::</span> <span class="nf">binary</span><span class="p">(),</span>
             <span class="nv">DocValue</span> <span class="p">::</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="nf">term</span><span class="p">()</span>
</code></pre></div></div>

<p>where in the root tuple we have:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Anno</code> - annotation (line, column, file) of the definition itself
(see <code class="language-plaintext highlighter-rouge">erl_anno</code>)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">BeamLanguage</code> - an atom representing the language, for example:
<code class="language-plaintext highlighter-rouge">erlang</code>, <code class="language-plaintext highlighter-rouge">elixir</code>, <code class="language-plaintext highlighter-rouge">lfe</code>, <code class="language-plaintext highlighter-rouge">alpaca</code>, etc</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Format</code> - the mime type of the documentation, such as “text/markdown”
or “application/erlang+html” (see the FAQ for a discussion on this field)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ModuleDoc</code> - a map with the documentation language as key, such as
<code class="language-plaintext highlighter-rouge">&lt;&lt;"en"&gt;&gt;</code> or <code class="language-plaintext highlighter-rouge">&lt;&lt;"pt_BR"&gt;&gt;</code>, and the documentation as a binary value.
It may be the atom <code class="language-plaintext highlighter-rouge">none</code> in case there is no documentation or the
atom <code class="language-plaintext highlighter-rouge">hidden</code> if documentation has been explicitly disabled for this
entry</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Metadata</code> - a map of atom keys with any term as value.  This can be
used to add annotations like the “authors” of a module, “deprecated”,
or anything else a language or documentation tool may find relevant</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Docs</code> - a list of documentation for other entities (such as
functions and types) in the module</p>
  </li>
</ul>

<p>For each entry in <code class="language-plaintext highlighter-rouge">Docs</code>, we have:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">{Kind, Name, Arity}</code> - the kind, name and arity identifying the
function, callback, type, etc.  The official entities are: <code class="language-plaintext highlighter-rouge">function</code>,
<code class="language-plaintext highlighter-rouge">type</code> and <code class="language-plaintext highlighter-rouge">callback</code>.  Other languages will add their own. For
instance, Elixir and LFE may add <code class="language-plaintext highlighter-rouge">macro</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Anno</code> - annotation (line, column, file) of the module documentation
or of the definition itself (see erl_anno)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Signature</code> - the signature of the entity.  It is is a list of
binaries. Each entry represents a binary in the signature that can
be joined with a whitespace or a newline.  For example,
<code class="language-plaintext highlighter-rouge">["binary_to_atom(Binary, Encoding)", "when is_binary(Binary)"]</code>
may be rendered as as a single line or two lines. It exists
exclusively for exhibition purposes</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Doc</code> - a map with the documentation language as key, such as
<code class="language-plaintext highlighter-rouge">&lt;&lt;"en"&gt;&gt;</code> or <code class="language-plaintext highlighter-rouge">&lt;&lt;"pt_BR"&gt;&gt;</code>, and the documentation as a value.
The documentation may either be a binary or any Erlang term,
both described by <code class="language-plaintext highlighter-rouge">Format</code>. If it is an Erlang term, then the
<code class="language-plaintext highlighter-rouge">Format</code> must be “application/erlang+SUFFIX”, such as
“application/erlang+html” when the documentation is an Erlang
representation of an HTML document. The <code class="language-plaintext highlighter-rouge">Doc</code> may also be the
atom <code class="language-plaintext highlighter-rouge">none</code> in case there is no documentation or the atom <code class="language-plaintext highlighter-rouge">hidden</code>
if documentation has been explicitly disabled for this entry</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Metadata</code> - a map of atom keys with any term as value</p>
  </li>
</ul>

<blockquote>
  <p>Note: the documentation map can be empty. In this case, a reference
to said function was added to the documentation index, making it
effectively public, but no documentation was written.</p>
</blockquote>

<p>This shared format is the heart of the EEP as it is what effectively
allows cross-language collaboration.</p>

<p>The <code class="language-plaintext highlighter-rouge">Metadata</code> field exists to allow languages, tools and libraries to
add custom information to each entry.  This EEP documents the
following metadata keys:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">authors := [binary()]</code> - a list of authors as binaries</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cross_references := [module() | {module(), {Kind, Name, Arity}}]</code> -
a list of modules or module entries that can be used as cross
references when generating documentation</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">deprecated := binary()</code> - when present, it means the current entry
is deprecated with a binary that represents the reason for
deprecation and a recommendation to replace the deprecated code</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">since := binary()</code> - a binary representing the version such entry
was added, such as <code class="language-plaintext highlighter-rouge">&lt;&lt;"1.3.0"&gt;&gt;</code> or <code class="language-plaintext highlighter-rouge">&lt;&lt;"20.0"&gt;&gt;</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">edit_url := binary()</code> - a binary representing a URL to change to
change the documentation itself</p>
  </li>
</ul>

<p>Any key may be added to Metadata at any time.  Keys that are frequently
used by the community can be standardized in future versions.</p>

<h2 id="part-3-integration-with-otp">Part 3: Integration with OTP</h2>

<p>The last part focuses on integrating the previous parts with OTP docs,
tools and workflows.  The items below are suggestions and are not
necessary for the adoption of this EEP, neither by OTP nor by any other
language or library.</p>

<p>At this point we should consider changes to OTP such as:</p>

<ul>
  <li>
    <p>Distributing the <code class="language-plaintext highlighter-rouge">doc/chunks/*.chunk</code> files as part of OTP and
changing the tools that ship with OTP to rely on them. For example,
<code class="language-plaintext highlighter-rouge">erl -man lists</code> could be changed to locate the <code class="language-plaintext highlighter-rouge">lists.chunk</code> file,
parsing the documentation out and then converting it to a man page
on the fly.  This task may require multiple changes, as OTP stores
documentation on XML files as well as directly in the source code.
<code class="language-plaintext highlighter-rouge">edoc</code> itself should likely be augmented with functions that spit
out <code class="language-plaintext highlighter-rouge">.chunk</code> files from the source code</p>
  </li>
  <li>
    <p>Adding <code class="language-plaintext highlighter-rouge">h(Module)</code>, <code class="language-plaintext highlighter-rouge">h(Module, Function, Arity)</code>, and similar to
Erlang’s shell to print the documentation of a module or of a
given function and arity. This should be able to print docs any
other library or language that implements this proposal</p>
  </li>
</ul>

<h1 id="faq">FAQ</h1>

<p><em>Q: Why do we have a Format entry in the documentation?</em></p>

<p>The main trade-off in the proposal is the documentation format.  We have
two options:</p>

<ul>
  <li>Allow each language/library/tool to choose their own documentation
format</li>
  <li>Impose a unified documentation format on all languages</li>
</ul>

<p>A unified format for documentation gives no flexibility to languages and
libraries in choosing how documentation is written.  As the ecosystem
gets more diverse, it will be unlikely to find a format that suits all.
For this reason we introduced a Format field that allows each language
and library to pick their documentation format.  The downside is that,
if the Elixir docs are written in Markdown and a language does not know
how to format Markdown, then the language will have to choose to either
not show the Elixir docs or show them raw (i.e. in Markdown).</p>

<p>Erlang is in a privileged position.  All languages will be able to
support whatever format is chosen for Erlang since all languages run on
Erlang and will have direct access to Erlang’s tooling.</p>

<p><em>Q: If I have an Erlang/Elixir/LFE/Alpaca library that uses a custom
documentation toolkit, will I also be able to leverage this?</em></p>

<p>As long as the documentation ends up up in the <code class="language-plaintext highlighter-rouge">Docs</code> chunk or inside
the <code class="language-plaintext highlighter-rouge">doc/chunks</code> directory, we absolutely do not care how the
documentation was originally written.  If you use a custom format,
you may need to teach your language of choice how to render it though.
See the previous question.</p>

<h1 id="copyright">Copyright</h1>

<p>This document has been placed in the public domain.</p>


            </div>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>