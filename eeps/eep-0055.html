<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0055 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0055 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Richard carlsson &lt;carlsson.richard(at)gmail(dot)com&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>21-Dec-2020</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>24</dd>
                        
                        
                        <dt>Post-History:</dt>
                        <dd>24-Dec-2020</dd>
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                <h2 id="eep-55-pinning-operator--in-patterns">EEP 55: Pinning operator ^ in patterns</h2>

<h1 id="abstract">Abstract</h1>

<p>This EEP proposes the addition of a new unary operator <code class="language-plaintext highlighter-rouge">^</code> for
explicitly marking variables in patterns as being already bound.  This
is known as “pinning” in Elixir - see [Elixir doc][the Elixir
documentation].</p>

<p>For example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
        <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="nv">Y</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">ok</span><span class="p">;</span>
        <span class="p">_</span> <span class="o">-&gt;</span> <span class="n">error</span>
    <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>could be written more explicitly:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
        <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="err">^</span><span class="nv">Y</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">ok</span><span class="p">;</span>
        <span class="p">_</span> <span class="o">-&gt;</span> <span class="n">error</span>
    <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>In Elixir, this operator is strictly necessary for being able to refer
to the value of a bound variable as part of a pattern, because
variables in patterns are always regarded as being new shadowing
instances (like in Erlang’s fun clause heads), unless explicitly
pinned.</p>

<p>In Erlang, they would be optional, but are still a good idea because
they make programs more robust under edits and refactorings, and
furthermore allow the use of pinned variables in fun clause heads and
in comprehension generator patterns.</p>

<h1 id="specification">Specification</h1>

<p>A new unary operator <code class="language-plaintext highlighter-rouge">^</code> is added to Erlang, called the “pinning
operator”.  It may only be used in patterns, and only on variables.
Its meaning is that the “pinned” variable is to be interpreted in the
enclosing environment of the pattern, and its value used in its place
for that position in the pattern.</p>

<p>In current Erlang, this behaviour is what happens automatically in
ordinary matching constructs if the variable is already bound in the
enclosing environment.  In the following example:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
        <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="nv">Y</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
        <span class="p">_</span> <span class="o">-&gt;</span> <span class="n">error</span>
    <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>the use of <code class="language-plaintext highlighter-rouge">Y</code> in the pattern is regarded as a reference to the
function parameter <code class="language-plaintext highlighter-rouge">Y</code>, instead of as introducing a new variable, and
the <code class="language-plaintext highlighter-rouge">Y</code> in the clause body is then that same parameter.  Therefore,
annotating the pattern variable as <code class="language-plaintext highlighter-rouge">^Y</code> in this case does not change
the behaviour of the program, but makes the intent explicit:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
        <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="err">^</span><span class="nv">Y</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
        <span class="p">_</span> <span class="o">-&gt;</span> <span class="n">error</span>
    <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>For fun expressions and list comprehension generator patterns, the
pinning operator makes the language more expressive.  Take the
following Erlang code:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">F</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">({</span><span class="n">a</span><span class="p">,</span> <span class="nv">Y</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
            <span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">error</span>
        <span class="k">end</span><span class="p">,</span>
    <span class="nv">F</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>

<p>Here, the occurrence of <code class="language-plaintext highlighter-rouge">Y</code> in the clause head of the fun <code class="language-plaintext highlighter-rouge">F</code> is a new
variable instance, shadowing the <code class="language-plaintext highlighter-rouge">Y</code> parameter of <code class="language-plaintext highlighter-rouge">f(X, Y)</code>, and the
fun clause will match any value in that position.  The <code class="language-plaintext highlighter-rouge">Y</code> in the
clause body is the one bound in the clause head.  However, using the
pinning operator, we can selectively match on variables bound in the
outer scope:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">F</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">({</span><span class="n">a</span><span class="p">,</span> <span class="err">^</span><span class="nv">Y</span><span class="p">})</span>  <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
            <span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">error</span>
        <span class="k">end</span><span class="p">,</span>
    <span class="nv">F</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>

<p>In this case, there is no new binding of <code class="language-plaintext highlighter-rouge">Y</code>, and the use of <code class="language-plaintext highlighter-rouge">Y</code> in
the fun clause body refers to the function parameter.  But it is also
possible to combine pinning and shadowing in the same pattern:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">F</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">({</span><span class="n">a</span><span class="p">,</span> <span class="err">^</span><span class="nv">Y</span><span class="p">,</span> <span class="nv">Y</span><span class="p">})</span>  <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
            <span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">error</span>
        <span class="k">end</span><span class="p">,</span>
    <span class="nv">F</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>

<p>In this case, the pinned field refers to the value of the function
function parameter, but there is also a new shadowing binding of <code class="language-plaintext highlighter-rouge">Y</code>
to the third field of the tuple.  The use in the fun clause body now
refers to the shadowing instance.</p>

<p>Generator patterns in list comprehensions or binary comprehensions
follow the same rules as fun clause heads, so with pinning we can for
example write the following code:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[{</span><span class="n">b</span><span class="p">,</span> <span class="nv">Y</span><span class="p">}</span> <span class="p">||</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="err">^</span><span class="nv">Y</span><span class="p">,</span> <span class="nv">Y</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="nv">X</span><span class="p">].</span>
</code></pre></div></div>

<p>where the <code class="language-plaintext highlighter-rouge">Y</code> in <code class="language-plaintext highlighter-rouge">{b, Y}</code> is the shadowing instance bound to the third
element of the pattern tuple.</p>

<p>Finally, a new compiler flag <code class="language-plaintext highlighter-rouge">warn_unpinned_vars</code> is added, disabled
by default, which if enabled makes the compiler emit warnings about
all uses of already bound variables in patterns that are not
explicitly annotated with the <code class="language-plaintext highlighter-rouge">^</code> operator.  This allows users to
migrate their code module by module towards using explicit pinning in
all their code.  If pinning becomes the norm in Erlang, this flag
could be turned on by default, and eventually, the pinning operator
could become strictly required for referring to already bound
variables in patterns.</p>

<h1 id="rationale">Rationale</h1>

<p>The explicit pinning of variables in patterns make programs more
readable, because the intent of the code becomes clear.  When already
bound variables are used in Erlang without any annotation, anyone
reading a piece of code must first study it closely to understand
which variables will be bound at the point of a pattern, before they
can tell whether any pattern variable is a new binding or implies an
equality assertion.  This is easy to miss even for experienced
Erlangers, be it during code reviews or while trying to understand a
piece of poorly commented code.</p>

<p>Perhaps more importantly, pinning also makes programs more robust
under edits and refactorings.  Take our previous example, and add a
print statement:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">"checking: </span><span class="si">~p</span><span class="s">"</span><span class="p">,</span> <span class="p">[</span><span class="nv">Y</span><span class="p">]),</span>
    <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
        <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="nv">Y</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
        <span class="p">_</span> <span class="o">-&gt;</span> <span class="n">error</span>
    <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>Suppose someone renames the function parameter from <code class="language-plaintext highlighter-rouge">Y</code> to <code class="language-plaintext highlighter-rouge">Z</code> and
updates the print statement but forgets to update the use in the case
clause.  Without an explicit pinning annotation, the change would be
quietly allowed, but the <code class="language-plaintext highlighter-rouge">Y</code> in the pattern would be interpreted as a
new variable that will match any value, which will then be used in the
body.  This changes the behaviour of the program.  If the use in the
pattern had been annotated as <code class="language-plaintext highlighter-rouge">^Y</code>, the compiler would have generated
an error “Y is unbound” and the mistake would have been caught.</p>

<p>When code is being modified to add a feature or fix a bug, a
programmer might want to introduce a new variable for a temporary
result.  In a long function body, this risks introducing a new bug.
Consider the following:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">g</span><span class="p">(</span><span class="nv">Stuff</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="p">...</span>
   <span class="nv">Thing</span> <span class="o">=</span> <span class="k">case</span> <span class="p">...</span> <span class="k">of</span>
               <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="nv">T</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nv">T</span><span class="p">;</span>
               <span class="p">_</span> <span class="o">-&gt;</span> <span class="mi">0</span>
           <span class="k">end</span><span class="p">,</span>
   <span class="p">...</span>
   <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="p">[</span><span class="nv">Thing</span><span class="p">|</span><span class="nv">Stuff</span><span class="p">]}.</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">T</code> is a new variable, clearly intended as just a temporary and
local variable for extracting the second element of the tuple.  But
suppose that someone adds a binding of the name <code class="language-plaintext highlighter-rouge">T</code> further up in the
function body, without noticing that the name is already in use:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">g</span><span class="p">(</span><span class="nv">Stuff</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="p">...</span>
   <span class="nv">T</span> <span class="o">=</span> <span class="nf">q</span><span class="p">(</span><span class="nv">Stuff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
   <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">"</span><span class="si">~p</span><span class="s">"</span><span class="p">,</span> <span class="p">[</span><span class="nf">p</span><span class="p">(</span><span class="nv">T</span><span class="p">)]),</span>
   <span class="p">...</span>
   <span class="nv">Thing</span> <span class="o">=</span> <span class="k">case</span> <span class="p">...</span> <span class="k">of</span>
               <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="nv">T</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nv">T</span><span class="p">;</span>
               <span class="p">_</span> <span class="o">-&gt;</span> <span class="mi">0</span>
           <span class="k">end</span><span class="p">,</span>
   <span class="p">...</span>
   <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="p">[</span><span class="nv">Thing</span><span class="p">|</span><span class="nv">Stuff</span><span class="p">]}.</span>
</code></pre></div></div>

<p>Now the first clause of the case switch will only match if the second
element of the tuple has the exact same value as the previously
defined <code class="language-plaintext highlighter-rouge">T</code>.  Again, the compiler quietly accepts this change, while
if it had been instructed to warn about all non-annotated uses of
already bound variables in patterns, this mistake would have been
detected.</p>

<h2 id="shadowing-in-funs-and-comprehensions">Shadowing in Funs and Comprehensions</h2>

<p>In funs and comprehensions, pinning also lets us do things that
otherwise requires additional temporary variables.  Consider the
following code:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">F</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">({</span><span class="n">a</span><span class="p">,</span> <span class="nv">Y</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
            <span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">error</span>
        <span class="k">end</span><span class="p">,</span>
    <span class="nv">F</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>

<p>Since the <code class="language-plaintext highlighter-rouge">Y</code> in the clause head of the fun is a new shadowing
instance, the pattern will match any value in that position.  To match
only the value passed as <code class="language-plaintext highlighter-rouge">Y</code> to <code class="language-plaintext highlighter-rouge">f</code>, a clause guard must be added, and
a temporary variable be used to access the outer <code class="language-plaintext highlighter-rouge">Y</code>:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">OuterY</span> <span class="o">=</span> <span class="nv">Y</span><span class="p">,</span>
    <span class="nv">F</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">({</span><span class="n">a</span><span class="p">,</span> <span class="nv">Y</span><span class="p">})</span> <span class="k">when</span> <span class="nv">Y</span> <span class="o">=:=</span> <span class="nv">OuterY</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
            <span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">error</span>
        <span class="k">end</span><span class="p">,</span>
    <span class="nv">F</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>

<p>We could instead rename the inner use of <code class="language-plaintext highlighter-rouge">Y</code> to avoid shadowing, but
the equality test must still be written as an explicit guard:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">F</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">({</span><span class="n">a</span><span class="p">,</span> <span class="nv">Z</span><span class="p">})</span> <span class="k">when</span> <span class="nv">Z</span> <span class="o">=:=</span> <span class="nv">Y</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
            <span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">error</span>
        <span class="k">end</span><span class="p">,</span>
    <span class="nv">F</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>

<p>With the help of the pinning operator, such things are no longer a
concern, and we can simply write:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">F</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">({</span><span class="n">a</span><span class="p">,</span> <span class="err">^</span><span class="nv">Y</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
            <span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">error</span>
        <span class="k">end</span><span class="p">,</span>
    <span class="nv">F</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>

<p>Furthermore, in the odd case that the pattern would both need to
access the surrounding definition of <code class="language-plaintext highlighter-rouge">Y</code> as well as introduce a new
shadowing binding, this can be easily written using pinning:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">F</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">({</span><span class="n">a</span><span class="p">,</span> <span class="err">^</span><span class="nv">Y</span><span class="p">,</span> <span class="nv">Y</span><span class="p">})</span>  <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
            <span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">error</span>
        <span class="k">end</span><span class="p">,</span>
    <span class="nv">F</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>

<p>but in current Erlang, two separate temporary variables would be
required:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">OuterY</span> <span class="o">=</span> <span class="nv">Y</span><span class="p">,</span>
    <span class="nv">F</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">({</span><span class="n">a</span><span class="p">,</span> <span class="nv">Temp</span><span class="p">,</span> <span class="nv">Y</span><span class="p">})</span> <span class="k">when</span> <span class="nv">Temp</span> <span class="o">=:=</span> <span class="nv">OuterY</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Y</span><span class="p">};</span>
            <span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">error</span>
        <span class="k">end</span><span class="p">,</span>
    <span class="nv">F</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>

<p>As explained before, the same goes for patterns in generators of
comprehensions.</p>

<h1 id="backwards-compatibility">Backwards Compatibility</h1>

<p>The addition of a new and previously unused operator <code class="language-plaintext highlighter-rouge">^</code> does not
affect the meaning of existing code, and the compiler will not emit
any new warnings or errors for existing code, unless explicitly
enabled with <code class="language-plaintext highlighter-rouge">warn_unpinned_vars</code>.  This change is therefore fully
backwards compatible.</p>

<h1 id="implementation">Implementation</h1>

<p>The implementation can be found in <a href="https://github.com/erlang/otp/pull/2951" title="#2951: Add a new operator ^ for pinning of pattern variables">PR #2951</a>.</p>

<h1 id="copyright">Copyright</h1>

<p>This document has been placed in the public domain.</p>


            </div>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>