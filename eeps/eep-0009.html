<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0009 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0009 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Fredrik Svahn &lt;Fredrik(dot)Svahn(at)gmail&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>28-Dec-2007</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>R12B-2</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                <h2 id="eep-9-library-for-working-with-binaries">EEP 9: Library for working with binaries</h2>

<h1 id="abstract">Abstract</h1>

<p>This EEP suggests the addition of two binary help libraries with built-in
functions for time critical activities such as searching and splitting
erlang binaries as well as library functions for common operations on
binaries. The EEP also suggest the addition of a regular expressions
library using built in functions.</p>

<h1 id="rationale">Rationale</h1>

<p>For the lists data type there is a help library providing functions for
common operations such as searching and splitting lists.  This EEP suggests
that a similar set of library functions should be created for binaries.
Many of the proposed functions are based on answers to questions regarding
binaries on the erlang-questions mailing list, e.g. “how do I convert a
number to a binary?”.</p>

<h1 id="motivation">Motivation</h1>

<p>Since binaries are typically used for time critical activities on larger
amounts of data it is suggested that some operations on binaries are
implemented as built-in functions, BIF:s.</p>

<p>Specifically there seems to be a huge interest in the community for an 
efficient regexp implementation for searching binaries. Also for maximum
performance when searching and splitting binaries it is suggested that the
the regexp search function is complemented by a high performance function
for simple searches, e.g. locating and splitting binaries on newline
characters. Tests show that e.g. the Boyer-Moore algorithm may be 
significantly faster than regular expression algorithms for such purposes.</p>

<p>When reviewing the EEP it is clear that there is also a strong demand for
string operations on binaries for better performance.</p>

<p>The reference implementation sent separately to the OTP team gives 
an indication of the expected performance improvements compared to e.g.
the current regular expression module for searching on lists. Some results
are available at the end of this EEP.</p>

<h1 id="suggested-changes">Suggested Changes</h1>

<p>This EEP suggests the addition of two new modules; one module named
binary and one called binary_string.</p>

<p>The EEP also suggests a new regular expression library based on Perl
Compatible Regular Expressions (PCRE). The library should be able to 
operate both on binary_strings and on strings.</p>

<p>Finally, the following functions should be added to the erlang module:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">binary_to_atom</span><span class="p">(</span><span class="nv">Binary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Atom</span>
<span class="nf">atom_to_binary</span><span class="p">(</span><span class="nv">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Binary</span>
<span class="nf">binary_to_existing_atom</span><span class="p">(</span><span class="nv">Binary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Atom</span>
</code></pre></div></div>

<h2 id="not-included">Not Included</h2>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">At</span> <span class="n">the</span> <span class="n">moment</span> <span class="n">the</span> <span class="n">following</span> <span class="n">is</span> <span class="ow">not</span> <span class="n">included</span> <span class="n">in</span> <span class="n">the</span> <span class="nv">EEP</span><span class="p">:</span>
<span class="p">-</span><span class="err"> S</span><span class="ni">upport</span> <span class="n">for</span> <span class="n">different</span> <span class="n">encodings</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">g</span><span class="p">.</span> <span class="nv">UTF</span><span class="o">-</span><span class="mi">8</span>
<span class="p">-</span><span class="err"> C</span><span class="ni">hanges</span> <span class="n">to</span> <span class="n">the</span> <span class="n">string</span> <span class="n">module</span>
</code></pre></div></div>

<h2 id="the-binary_string-module">The “binary_string” Module</h2>

<p>The binary_string module should be based on the current string module but 
should operate on strings represented by binaries as opposed to the 
current strings module which operates on strings represented by lists.</p>

<p>Apart from operating on binaries the interface of binary_string should be 
the same as for string with the following exceptions:</p>

<ol>
  <li>str/2 and rstr/2 should be modified to optionally take a list of 
binaries or a MatchSpec such as the one returned by 
binary:match_compile/2 as second argument. If the Keys argument 
corresponds to several keys the function should return a tuple
indicating the Key that matched and the matching Index, i.e.</li>
</ol>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">str</span><span class="p">(</span><span class="nv">Binary</span><span class="p">,</span> <span class="nv">Keys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Return</span>
    <span class="nf">rstr</span><span class="p">(</span><span class="nv">Binary</span><span class="p">,</span> <span class="nv">Keys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Return</span>

<span class="nv">Binary</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Keys</span> <span class="o">=</span> <span class="nv">Key</span> <span class="p">|</span> <span class="p">[</span> <span class="nv">Key</span> <span class="p">]</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
<span class="nv">Key</span> <span class="o">=</span> <span class="nf">string</span><span class="p">()</span> <span class="p">|</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="nn">binary</span><span class="p">:</span><span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
<span class="nv">Return</span> <span class="o">=</span> <span class="nv">Index</span> <span class="p">|</span> <span class="p">{</span><span class="nv">NeedleNumber</span><span class="p">,</span> <span class="nv">Index</span><span class="p">}</span>
<span class="nv">Index</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">str</span><span class="o">/</span><span class="n">rstr</span> <span class="n">should</span> <span class="n">be</span> <span class="n">implemented</span> <span class="n">as</span> <span class="n">built</span><span class="o">-</span><span class="n">in</span> <span class="n">functions</span> <span class="n">using</span> 
<span class="n">efficient</span> <span class="n">algorithms</span> <span class="n">such</span> <span class="n">as</span> <span class="nv">Boyer</span><span class="o">-</span><span class="nv">Moore</span><span class="p">,</span> <span class="nv">Aho</span><span class="o">-</span><span class="nv">Corasick</span> <span class="ow">or</span>
<span class="n">similar</span><span class="p">.</span> <span class="nv">Typically</span> <span class="n">the</span> <span class="n">function</span> <span class="n">could</span> <span class="n">be</span> <span class="n">built</span> <span class="n">on</span> <span class="nn">binary</span><span class="p">:</span><span class="n">match</span><span class="o">/</span><span class="mi">2</span><span class="p">.</span>
</code></pre></div></div>

<ol>
  <li>A new function split should be added. It should behave as tokens/2
but take a list of separator binaries/strings instead of a list of
separator characters.</li>
</ol>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">split</span><span class="p">(</span><span class="nv">Binary</span><span class="p">,</span> <span class="nv">SplitKeys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">List</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">Binary</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
    <span class="nv">SplitKeys</span> <span class="o">=</span> <span class="nv">Key</span> <span class="p">|</span> <span class="p">[</span> <span class="nv">Key</span> <span class="p">]</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
    <span class="nv">Key</span> <span class="o">=</span> <span class="nf">string</span><span class="p">()</span> <span class="p">|</span> <span class="nf">binary</span><span class="p">()</span>
    <span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="nn">binary</span><span class="p">:</span><span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
    <span class="nv">List</span> <span class="o">=</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Splits</span> <span class="nv">Binary</span> <span class="n">into</span> <span class="n">a</span> <span class="n">list</span> <span class="k">of</span> <span class="n">binaries</span> <span class="n">based</span> <span class="n">on</span> <span class="n">matching</span> <span class="n">the</span> <span class="n">pattern</span>
<span class="n">specified</span> <span class="n">in</span> <span class="n">the</span> <span class="nv">SplitKeys</span> <span class="n">binary</span><span class="p">.</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Examples</span><span class="p">:</span>
    <span class="o">&gt;</span> <span class="nn">binary_string</span><span class="p">:</span><span class="nf">split</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"cat and dog"</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="s">"and"</span><span class="o">&gt;&gt;</span><span class="p">).</span>
    <span class="p">[</span><span class="o">&lt;&lt;</span><span class="s">"cat "</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="s">" dog"</span><span class="o">&gt;&gt;</span><span class="p">]</span> 
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="o">&gt;</span> <span class="nn">binary_string</span><span class="p">:</span><span class="nf">split</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"cat and dog"</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="s">"and"</span><span class="p">).</span>
    <span class="p">[</span><span class="o">&lt;&lt;</span><span class="s">"cat "</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="s">" dog"</span><span class="o">&gt;&gt;</span><span class="p">]</span> 
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="o">&gt;</span> <span class="nn">binary_string</span><span class="p">:</span><span class="nf">split</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"cat and dog"</span><span class="o">&gt;&gt;</span><span class="p">,[</span><span class="s">"a"</span><span class="p">,</span><span class="s">"n"</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"d"</span><span class="o">&gt;&gt;</span><span class="p">]).</span>
    <span class="p">[</span><span class="o">&lt;&lt;</span><span class="s">"c"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"t "</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"og"</span><span class="o">&gt;&gt;</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">The</span> <span class="n">resulting</span> <span class="n">list</span> <span class="n">should</span> <span class="n">be</span> <span class="n">the</span> <span class="n">same</span> <span class="n">as</span> <span class="n">for</span> <span class="nn">regexp</span><span class="p">:</span><span class="n">split</span><span class="o">/</span><span class="mi">2</span> 
<span class="p">(</span><span class="n">with</span> <span class="n">the</span> <span class="n">obvious</span> <span class="n">exception</span> <span class="n">for</span> <span class="n">special</span> <span class="n">characters</span> <span class="n">such</span> <span class="n">as</span> <span class="s">"*"</span><span class="p">,</span> 
<span class="s">"."</span><span class="p">,</span> <span class="s">"^"</span><span class="p">,</span> <span class="n">etc</span><span class="p">).</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Please</span> <span class="n">note</span> <span class="n">that</span> <span class="n">the</span> <span class="n">third</span> <span class="n">example</span> <span class="n">should</span> <span class="n">give</span> <span class="n">the</span> <span class="n">same</span> <span class="n">result</span> <span class="n">as</span>
<span class="nn">binary_string</span><span class="p">:</span><span class="nf">tokens</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"cat and dog"</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="s">"and"</span><span class="p">).</span> 
</code></pre></div></div>

<ol>
  <li>The new functions substitute and globally_substitute should be 
added.</li>
</ol>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="nf">substitute</span><span class="p">(</span><span class="nv">OldBinary</span><span class="p">,</span> <span class="nv">Key</span><span class="p">,</span> <span class="nv">Replacement</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">NewBinary</span>
        
     <span class="nv">OldBinary</span><span class="p">,</span> <span class="nv">NewBinary</span><span class="p">,</span> <span class="nv">Replacement</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
     <span class="nv">Keys</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
     <span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="nn">binary</span><span class="p">:</span><span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
        
 <span class="nv">Creates</span> <span class="n">a</span> <span class="n">binary</span> <span class="nv">NewBinary</span> <span class="n">from</span> <span class="nv">OldBinary</span> <span class="n">by</span> <span class="n">substituting</span> <span class="n">the</span> 
 <span class="n">first</span> <span class="n">occurence</span> <span class="k">of</span> <span class="n">any</span> <span class="k">of</span> <span class="n">the</span> <span class="n">binaries</span> <span class="n">in</span> <span class="nv">Keys</span> <span class="n">in</span> <span class="nv">OldBinary</span>
 <span class="n">with</span> <span class="n">the</span> <span class="nv">Replacement</span> <span class="n">binary</span><span class="p">.</span> 
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">The</span> <span class="nv">Replacement</span> <span class="n">binary</span> <span class="n">need</span> <span class="ow">not</span> <span class="n">have</span> <span class="n">the</span> <span class="n">same</span> <span class="nb">size</span> <span class="n">as</span> <span class="n">the</span> <span class="n">matched</span> 
 <span class="nv">Key</span><span class="p">.</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">Example</span><span class="p">:</span>
    <span class="o">&gt;</span> <span class="nn">binary_string</span><span class="p">:</span><span class="nf">substitute</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"cat anf dog"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"anf"</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="s">"and"</span><span class="o">&gt;&gt;</span><span class="p">).</span>
    <span class="p">[</span><span class="o">&lt;&lt;</span><span class="s">"cat and dog"</span><span class="o">&gt;&gt;</span><span class="p">]</span> 
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">globally_substitute</span><span class="p">(</span><span class="nv">OldBinary</span><span class="p">,</span> <span class="nv">Key</span><span class="p">,</span> <span class="nv">Replacement</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">NewBinary</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">OldBinary</span><span class="p">,</span> <span class="nv">NewBinary</span><span class="p">,</span> <span class="nv">Replacement</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
    <span class="nv">Keys</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
    <span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="nn">binary</span><span class="p">:</span><span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Same</span> <span class="n">as</span> <span class="n">substitute</span> <span class="n">except</span> <span class="n">that</span> <span class="n">all</span> <span class="n">non</span><span class="o">-</span><span class="n">overlapping</span> <span class="n">occurrences</span> <span class="k">of</span> 
<span class="n">a</span> <span class="n">subbinary</span> <span class="n">in</span> <span class="nv">OldBinary</span> <span class="n">are</span> <span class="n">replaced</span> <span class="n">by</span> <span class="n">the</span> <span class="nv">Replacement</span> <span class="n">binary</span><span class="p">.</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">It</span> <span class="n">is</span> <span class="n">suggested</span> <span class="n">that</span> <span class="n">the</span> <span class="n">same</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">also</span> <span class="n">added</span> <span class="n">to</span> <span class="n">the</span> <span class="n">string</span>
<span class="n">module</span><span class="p">,</span> <span class="n">but</span> <span class="n">this</span> <span class="n">is</span> <span class="n">out</span> <span class="k">of</span> <span class="n">the</span> <span class="n">scope</span> <span class="k">of</span> <span class="n">this</span> <span class="nv">EEP</span><span class="p">.</span>
</code></pre></div></div>

<h2 id="the-binary-module">The “binary” Module</h2>

<p>The interface of the binary module should have the following exported 
functions (please note that some functions are intentionally the same as
in binary_string since it is believed they can be useful both for string
and binary data manipulation):</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">match</span><span class="p">(</span><span class="nv">Binary</span><span class="p">,</span> <span class="nv">Keys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Return</span>
<span class="nf">match</span><span class="p">(</span><span class="nv">Binary</span><span class="p">,</span> <span class="nv">Keys</span><span class="p">,</span> <span class="p">{</span><span class="nv">StartIndex</span><span class="p">,</span> <span class="nv">EndIndex</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="nv">Return</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Binary</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Keys</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="nn">binary</span><span class="p">:</span><span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
<span class="nv">StartIndex</span> <span class="o">=</span> <span class="nv">EndIndex</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Return</span> <span class="o">=</span> <span class="nv">Index</span> <span class="p">|</span> <span class="p">{</span><span class="nv">KeyNumber</span><span class="p">,</span> <span class="nv">Index</span><span class="p">}</span>
<span class="nv">Index</span> <span class="o">=</span> <span class="nv">KeyNumber</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">()</span>
</code></pre></div></div>

<p>Returns position of first occurence in Binary of the first 
matching binary in Keys or 0 if no match. If a list of keys
is given, the function will return a tuple with the KeyNumber of
the matched Key and the position in Binary where it was found.</p>

<p>There has been a discussion on whether the function should return
the matched Key instead of the KeyNumber. Returning the KeyNumber
should be slightly more efficient, and since the matched key
can easily be retrieved by lists:nth(KeyNumber, Keys) if needed it
is suggested that the function returns the KeyNumber.</p>

<p>Binary is searched from StartIndex to EndIndex. If StartIndex 
and EndIndex are not specified the default is to search Binary 
from the beginning to the end.</p>

<p>Example:</p>
<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">match</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">).</span>
<span class="mi">4</span> 
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">match</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">255</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="p">[</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="mi">255</span><span class="o">&gt;&gt;</span><span class="p">]).</span>
<span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</code></pre></div></div>

<p>Suggestions on implementation: Should be implemented as one or
more BIF:s using e.g. Boyer-Moore, Aho-Corasick or similar 
efficient algorithms.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">matches</span><span class="p">(</span><span class="nv">Binary</span><span class="p">,</span> <span class="nv">Keys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Return</span>
<span class="nf">matches</span><span class="p">(</span><span class="nv">Binary</span><span class="p">,</span> <span class="nv">Keys</span><span class="p">,</span> <span class="p">{</span><span class="nv">StartIndex</span><span class="p">,</span> <span class="nv">EndIndex</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="nv">Return</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Binary</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Keys</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="nn">binary</span><span class="p">:</span><span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
<span class="nv">StartIndex</span> <span class="o">=</span> <span class="nv">EndIndex</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">()</span> 
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Return</span> <span class="o">=</span> <span class="p">[</span> <span class="nv">Index</span> <span class="p">]</span> <span class="p">|</span> <span class="p">[</span> <span class="p">{</span><span class="nv">KeyNumber</span><span class="p">,</span> <span class="nv">Index</span><span class="p">}</span> <span class="p">]</span>
<span class="nv">Index</span> <span class="o">=</span> <span class="nv">KeyNumber</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">()</span>
</code></pre></div></div>

<p>Finds all matches of the Keys in Haystack. Returns a list of the
indexes for all non-overlapping ocurrences of the key or keys.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">split</span><span class="p">(</span><span class="nv">Binary</span><span class="p">,</span> <span class="nv">SplitKeys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">List</span>
<span class="nf">split</span><span class="p">(</span><span class="nv">Binary</span><span class="p">,</span> <span class="nv">SplitKeys</span><span class="p">,</span> <span class="p">{</span><span class="nv">StartIndex</span><span class="p">,</span> <span class="nv">EndIndex</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="nv">List</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Binary</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">SplitKeys</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="nn">binary</span><span class="p">:</span><span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
<span class="nv">StartIndex</span> <span class="o">=</span> <span class="nv">EndIndex</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">List</span> <span class="o">=</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span>
</code></pre></div></div>

<p>Splits Binary into a list of binaries based on matching the pattern
specified in SplitKeys.</p>

<p>Example:</p>
<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">split</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">).</span>
<span class="p">[</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="p">]</span> 
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">split</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">9</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="p">[</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="o">&gt;&gt;</span><span class="p">]).</span>
<span class="p">[</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="o">&gt;&gt;</span><span class="p">]</span> 
</code></pre></div></div>

<p>The resulting list should basically be the same as for 
regexp:split/2 (with the obvious exception for special characters
such as “*”, “.”, “^”, etc).</p>

<p>The binaries in List are all subbinaries of Binary meaning that
the data in Binary is not actually copied to new binaries.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">substitute</span><span class="p">(</span><span class="nv">OldBinary</span><span class="p">,</span> <span class="nv">Key</span><span class="p">,</span> <span class="nv">Replacement</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">NewBinary</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">OldBinary</span><span class="p">,</span> <span class="nv">NewBinary</span><span class="p">,</span> <span class="nv">Replacement</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Keys</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="nn">binary</span><span class="p">:</span><span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
</code></pre></div></div>

<p>Creates a binary NewBinary from OldBinary by substituting the 
first occurence of any of the binaries in Keys in OldBinary
with the Replacement binary.</p>

<p>The Replacement binary need not have the same size as the matched 
Key.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">globally_substitute</span><span class="p">(</span><span class="nv">OldBinary</span><span class="p">,</span> <span class="nv">Key</span><span class="p">,</span> <span class="nv">Replacement</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">NewBinary</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">OldBinary</span><span class="p">,</span> <span class="nv">NewBinary</span><span class="p">,</span> <span class="nv">Replacement</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span>
<span class="nv">Keys</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="nn">binary</span><span class="p">:</span><span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
</code></pre></div></div>

<p>Same as substitute except that all non-overlapping occurrences of 
a subbinary in OldBinary are replaced by the Replacement binary.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">match_compile</span><span class="p">(</span><span class="nv">Keys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">MatchSpec</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Keys</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span> 
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> 
</code></pre></div></div>

<p>Builds an internal structure representing one or more search
keys. The MatchSpec structure can be used to speed up searching if
multiple searches with binary:match/2 or binary_string:str/2
are to be performed with the same search keywords.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">binary</span><span class="p">:</span><span class="nf">from_unsigned</span><span class="p">(</span><span class="nv">Integer</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">Binary</span>
<span class="nn">binary</span><span class="p">:</span><span class="nf">to_unsigned</span><span class="p">(</span><span class="nv">Binary</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">Integer</span>
</code></pre></div></div>

<p>Converts a positive integer the smallest possible representation
in the binary data type format and vice versa.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Example</span><span class="p">:</span>
<span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">from_unsigned</span><span class="p">(</span><span class="mi">11111111</span><span class="p">).</span> 
<span class="o">&lt;&lt;</span><span class="mi">169</span><span class="p">,</span><span class="mi">138</span><span class="p">,</span><span class="mi">199</span><span class="o">&gt;&gt;</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">to_unsigned</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="mi">169</span><span class="p">,</span><span class="mi">138</span><span class="p">,</span><span class="mi">199</span><span class="o">&gt;&gt;</span><span class="p">).</span>
<span class="mi">11111111</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">first</span><span class="p">(</span><span class="nv">Binary1</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">Binary2</span>
<span class="nf">first</span><span class="p">(</span><span class="nv">SizeBytes</span><span class="p">,</span> <span class="nv">Binary1</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">Binary2</span>
</code></pre></div></div>

<p>Returns a subbinary with the first byte or the SizeBytes first 
bytes in Binary1.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Example</span><span class="p">:</span>
<span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">first</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="s">"abc"</span><span class="o">&gt;&gt;</span><span class="p">).</span>                                  
<span class="o">&lt;&lt;</span><span class="s">"ab"</span><span class="o">&gt;&gt;</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">last</span><span class="p">(</span><span class="nv">Binary1</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">Binary2</span><span class="p">.</span>
<span class="nf">last</span><span class="p">(</span><span class="nv">SizeBytes</span><span class="p">,</span> <span class="nv">Binary1</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">Binary2</span>
</code></pre></div></div>

<p>Returns a subbinary with the last byte or the SizeBytes last bytes
in Binary1.</p>

<p>Example:</p>
<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">last</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="s">"abc"</span><span class="o">&gt;&gt;</span><span class="p">).</span>                                  
<span class="o">&lt;&lt;</span><span class="s">"bc"</span><span class="o">&gt;&gt;</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">nth</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">Binary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Value</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">N</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">(),</span> <span class="mi">1</span> <span class="o">=&lt;</span> <span class="nv">N</span> <span class="o">=&lt;</span> <span class="nb">size</span><span class="p">(</span><span class="nv">Binary</span><span class="p">)</span>
<span class="nv">Value</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">()</span>
</code></pre></div></div>

<p>Extracts a byte at position N from Binary. Same as</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">T</span> <span class="o">=</span> <span class="nv">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="o">&lt;&lt;</span><span class="p">_:</span><span class="nv">T</span><span class="o">/</span><span class="n">binary</span><span class="p">,</span> <span class="nv">Value</span><span class="p">:</span><span class="nv">Size</span><span class="o">/</span><span class="n">binary</span><span class="p">,</span> <span class="p">_</span><span class="o">/</span><span class="n">binary</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nv">Binary</span><span class="p">,</span> 
<span class="nv">Value</span><span class="p">.</span>
</code></pre></div></div>

<p>although this function is somewhat shorter and easier to write.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">extract</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">Size</span><span class="p">,</span> <span class="nv">Binary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">SubBinary</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">N</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">(),</span> <span class="mi">1</span> <span class="o">=&lt;</span> <span class="nv">N</span> <span class="o">=&lt;</span> <span class="nb">size</span><span class="p">(</span><span class="nv">Binary</span><span class="p">)</span>
<span class="nv">Size</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">()</span>
<span class="nv">SubBinary</span> <span class="o">=</span> <span class="nf">subbinary</span><span class="p">()</span>
</code></pre></div></div>

<p>Returns a subbinary of size Size starting at position N from 
Binary. No data is copied in this operation.</p>

<p>It has been discussed if there should be a function for copying
a part of a binary rather than getting a subbinary. This would
make it possible to get a small part of a binary and let the
rest be garbage collected. Since it is possible to achieve the same
result by converting the extracted part to a list and then back
again to a binary and it is a very specialized operation which
may confuse new users it has been excluded at this stage.</p>

<p>When talking to designers many seem to prefer the name extract
over the name subbinary for this function.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">duplicate</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">Byte</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">Binary</span>
</code></pre></div></div>

<p>Similar to <code class="language-plaintext highlighter-rouge">lists:duplicate/2</code>. Creates a new binary consisting of
Byte repeated N times.</p>

<p>Example:</p>
<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">duplicate</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="sc">$a</span><span class="p">).</span>
<span class="o">&lt;&lt;</span><span class="s">"aaaaa"</span><span class="o">&gt;&gt;</span>
</code></pre></div></div>

<h2 id="the-regular-expressions-library">The Regular Expressions Library</h2>

<p>It is suggested that a new regular expression library based on
built in functions is added. It should have the following interface
functions (name of the module to be decided, for backwards
compatibility reasons it should probably exists in parallell with
the old regexp module):</p>

<p>During a first round of feedback it has been suggested that the 
final implementation should be a built in function based on the 
<a href="http://en.wikipedia.org/wiki/PCRE">Perl Compatible Regular Expressions (PCRE) library</a>. It is 
optimised, well supported, and is more or less considered a <a href="http://www.pcre.org/pcre.txt" title="Man page for pcrematching">standard</a>
today. It is used in a number of prominent products and projects, e.g.
Apples Safari, Apache, KDE, PHP, Postfix and Nmap.</p>

<p>It is suggested that the module has the following exported functions:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">compile</span><span class="p">(</span><span class="nv">Regex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">MatchSpec</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Regex</span> <span class="o">=</span> <span class="nf">string</span><span class="p">()</span>
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> 
</code></pre></div></div>

<p>Builds an internal structure representing one or more search
keys. The MatchSpec structure can be used to speed up searching if
multiple searches are to be performed with the same search 
keywords.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">match</span><span class="p">(</span><span class="nv">BinOrString</span><span class="p">,</span> <span class="nv">RegExp</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">Return</span>
<span class="nf">match</span><span class="p">(</span><span class="nv">BinOrString</span><span class="p">,</span> <span class="nv">RegExp</span><span class="p">,</span> <span class="p">{</span><span class="nv">StartIndex</span><span class="p">,</span> <span class="nv">EndIndex</span><span class="p">})</span><span class="o">-&gt;</span> <span class="nv">Return</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">BinOrString</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="nf">string</span><span class="p">()</span>
<span class="nv">RegExp</span> <span class="o">=</span> <span class="nf">string</span><span class="p">()</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
<span class="nv">StartIndex</span> <span class="o">=</span> <span class="nv">EndIndex</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">()</span>
<span class="nv">Return</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">|</span> <span class="p">{</span><span class="nv">Start</span><span class="p">,</span> <span class="nv">Length</span><span class="p">,</span> <span class="p">[</span><span class="nv">CapturedPatterns</span><span class="p">]}</span>
</code></pre></div></div>

<p>Finds the first, longest match of the regular expression RegExp 
in BinOrString. This function searches for the longest possible 
match and returns the first one found if there are several 
expressions of the same length.</p>

<p>The function supports pattern capturing. Patterns captured (if
any) are returned in a list in the Return tuple.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Examples</span><span class="p">:</span>
<span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">regex_match</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"abcde"</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="s">"b?cd"</span><span class="p">).</span>
<span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,[]}</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">regex_match</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"127.0.0.1"</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="s">"(</span><span class="se">\d</span><span class="s">*)</span><span class="err">\</span><span class="s">.(</span><span class="se">\d</span><span class="s">*)</span><span class="err">\</span><span class="s">."</span><span class="p">).</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,[</span><span class="o">&lt;&lt;</span><span class="s">"127"</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="s">"0"</span><span class="o">&gt;&gt;</span><span class="p">]}</span>
</code></pre></div></div>

<p>Open questions:</p>
<ul>
  <li>It might be a good idea to add an Options parameter (optional 
of course), e.g. to specify that the partial matching feature 
should be activated</li>
  <li>handling of Encodings.</li>
</ul>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">matches</span><span class="p">(</span><span class="nv">BinOrString</span><span class="p">,</span> <span class="nv">RegExp</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">Return</span>
<span class="nf">matches</span><span class="p">(</span><span class="nv">BinOrString</span><span class="p">,</span> <span class="nv">RegExp</span><span class="p">,</span> <span class="p">{</span><span class="nv">StartIndex</span><span class="p">,</span> <span class="nv">EndIndex</span><span class="p">})</span><span class="o">-&gt;</span> <span class="nv">Return</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">BinOrString</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="nf">string</span><span class="p">()</span>
<span class="nv">RegExp</span> <span class="o">=</span> <span class="nf">string</span><span class="p">()</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
<span class="nv">StartIndex</span> <span class="o">=</span> <span class="nv">EndIndex</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Return</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">|</span> <span class="p">[</span> <span class="p">{</span><span class="nv">Start</span><span class="p">,</span> <span class="nv">Length</span><span class="p">,</span> <span class="p">[</span><span class="nv">CapturedPatterns</span><span class="p">]}</span> <span class="p">]</span>
</code></pre></div></div>

<p>Finds all matches of the regular expression RegExp in BinOrString.</p>

<p>Example:</p>
<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nn">binary</span><span class="p">:</span><span class="nf">regex_matches</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">"aaa"</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="s">"a"</span><span class="p">).</span>
<span class="p">[{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,[]},{</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,[]},{</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,[]}]</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sub</span><span class="p">(</span><span class="nv">BinOrString</span><span class="p">,</span> <span class="nv">RegExp</span><span class="p">,</span> <span class="nv">Replacement</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">NewStringOrBinary</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">BinOrString</span> <span class="o">=</span> <span class="nv">NewStringOrBinary</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="nf">string</span><span class="p">()</span>
<span class="nv">RegExp</span> <span class="o">=</span> <span class="nf">string</span><span class="p">()</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
<span class="nv">Replacement</span> <span class="o">=</span> <span class="nf">string</span><span class="p">()</span>
</code></pre></div></div>

<p>Substitutes the first occurence of a substring or subbinary 
matching RegExp in BinOrString with Replacement. A &amp; in the 
Replacement string is replaced by the matched substring or
subbinary of BinOrString. \&amp; puts a literal &amp; into the 
replacement string or binary. The type of NewStringOrBinary
will be the same as the type of BinOrString.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">gsub</span><span class="p">(</span><span class="nv">BinOrString</span><span class="p">,</span> <span class="nv">RegExp</span><span class="p">,</span> <span class="nv">Replacement</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nv">Binary2</span>
</code></pre></div></div>

<p>Same as sub except that all non-overlapping occurrences of 
a substring or subbinary matching RegExp in BinOrString are 
replaced by the string Replacement.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">split</span><span class="p">(</span><span class="nv">BinOrString</span><span class="p">,</span> <span class="nv">RegExp</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">List</span>
<span class="nf">split</span><span class="p">(</span><span class="nv">BinOrString</span><span class="p">,</span> <span class="nv">RegExp</span><span class="p">,</span> <span class="p">{</span><span class="nv">StartIndex</span><span class="p">,</span> <span class="nv">EndIndex</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="nv">List</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">BinOrString</span> <span class="o">=</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">|</span> <span class="nf">string</span><span class="p">()</span>
<span class="nv">RegExp</span> <span class="o">=</span> <span class="nf">string</span><span class="p">()</span> <span class="p">|</span> <span class="nv">MatchSpec</span>
<span class="nv">MatchSpec</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">()</span> <span class="n">as</span> <span class="n">returned</span> <span class="n">by</span> <span class="n">match_compile</span><span class="o">/</span><span class="mi">1</span>
<span class="nv">StartIndex</span> <span class="o">=</span> <span class="nv">EndIndex</span> <span class="o">=</span> <span class="nf">integer</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">List</span> <span class="o">=</span> <span class="p">[</span> <span class="nf">binary</span><span class="p">()</span> <span class="p">]</span>
</code></pre></div></div>

<p>Splits Binary into a list of binaries based on the pattern
specified in RegExp.</p>

<p>The resulting list should basically be the same as for 
regexp:split/2.</p>

<h1 id="performance">Performance</h1>

<p>Performance was measured for the functions considered most 
important using the reference implementation. Some examples:</p>

<ol>
  <li>Searching for a non-existing 1 and 3 byte binary in a ~1 Mb binary. 
Notice how binary:match/2 gets faster the longer the needle is thanks to 
the O(n/m) <a href="http://swtch.com/~rsc/regexp/regexp1.html">algorithm</a>. All times in microseconds.</li>
</ol>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="nv">Search</span> <span class="nn">for</span><span class="p">:</span>        <span class="mi">1</span> <span class="n">byte</span>   <span class="mi">3</span> <span class="n">bytes</span>
    <span class="o">---------------------------------------</span>   
    <span class="nn">binary</span><span class="p">:</span><span class="n">match</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>        <span class="mi">17598</span>      <span class="mi">6045</span> 
    <span class="nn">binary</span><span class="p">:</span><span class="n">regex_first</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>  <span class="mi">47299</span>     <span class="mi">46701</span>
    <span class="nn">string</span><span class="p">:</span><span class="n">str</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>          <span class="mi">68969</span>     <span class="mi">69637</span>
    <span class="nn">regexp</span><span class="p">:</span><span class="n">first_match</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span> <span class="mi">460858</span>    <span class="mi">887485</span>
</code></pre></div></div>

<ol>
  <li>Splitting a ~1 Mb binary on newline chars. This particular binary 
contained a newline every 60 chars on average.</li>
</ol>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nn">binary</span><span class="p">:</span><span class="n">split</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>  <span class="mi">89142</span> <span class="n">microseconds</span>
    <span class="nn">regexp</span><span class="p">:</span><span class="n">split</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span> <span class="mi">564911</span> <span class="n">microseconds</span>
</code></pre></div></div>

<ol>
  <li>Regex-DNA benchmark from computer language shootout</li>
</ol>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">prototype</span> <span class="n">regexp</span> <span class="nn">bif</span><span class="p">:</span>    <span class="mi">1</span><span class="p">.</span><span class="mi">9</span> <span class="n">seconds</span>
    <span class="n">regexp</span> <span class="n">module</span> <span class="n">in</span> <span class="nv">R12B</span><span class="p">:</span>  <span class="mi">99</span><span class="p">.</span><span class="mi">1</span> <span class="n">seconds</span>
</code></pre></div></div>

<p>In the examples at the computer language shootout PCRE has a slightly 
lower performance compared to other algorithms such as the one in the 
reference implementation or in particular the one featured in TCL. This
may not necessarily mean that this is true for all types of patterns.</p>

<h1 id="reference-implementation">Reference implementation</h1>

<p>A reference implementation has been provided to the OTP team.</p>

<h1 id="copyright">Copyright</h1>

<p>This document is licensed under the Creative Commons license.</p>


            </div>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>