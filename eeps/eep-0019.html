<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/erlang-org/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://erlang.github.io/erlang-org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://erlang.github.io/erlang-org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0019 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0019 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://erlang.github.io/erlang-org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://erlang.github.io/erlang-org/blog.xml" />
    
    <link rel="stylesheet" href="/erlang-org/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/erlang-org/"><img
                    src="/erlang-org/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/erlang-org/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="post" action="https://duckduckgo.com/?kg=p"
                    onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:erlang.org'; return true;">
                    <input type="hidden" id="searchq" name="q" class="hidden" />
                    <input class="form-control me-2" id="searchfield" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Richard A. O&#39;Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>14-Aug-2008</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>R12B-4</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                <h2 id="eep-19-comprehension-multigenerators">EEP 19: Comprehension multigenerators</h2>

<h1 id="abstract">Abstract</h1>

<p>Add Clean-inspired multi-sequence generators to comprehensions,
making code more intention-revealing and reducing the need to zip.</p>

<p>This is related to <a href="eep-0012.md" title="EEP 12">EEP 12</a>, but is independent of it.</p>

<h1 id="specification">Specification</h1>

<p>Currently, Erlang has</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Pattern</span> <span class="o">&lt;-</span> <span class="nv">Expr</span>
</code></pre></div></div>

<p>to enumerate over the elements of a single list and</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Pattern</span> <span class="o">&lt;=</span> <span class="nv">Expr</span>
</code></pre></div></div>

<p>to enumerate over a binary.  <a href="eep-0012.md" title="EEP 12">EEP 12</a> adds</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Pattern</span> <span class="p">[</span><span class="o">&lt;-</span><span class="p">]</span> <span class="nv">List</span>
<span class="nv">Pattern</span> <span class="p">{</span><span class="o">&lt;-</span><span class="p">}</span> <span class="nv">Tuple</span>
<span class="nv">Pattern</span> <span class="o">&lt;&lt;&lt;-&gt;&gt;</span> <span class="nv">Binary</span>
</code></pre></div></div>

<p>This proposal changes that to</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">generator</span><span class="p">:</span> <span class="n">term_generator</span> <span class="p">|</span> <span class="n">binary_generator</span><span class="p">;</span>
<span class="nn">binary_generator</span><span class="p">:</span> <span class="n">pattern</span> <span class="n">'&lt;='</span> <span class="n">expression</span><span class="p">;</span>
<span class="nn">term_generator</span><span class="p">:</span> <span class="n">term_generator</span> <span class="n">'&amp;&amp;'</span> <span class="n">term_generator</span>
              <span class="p">|</span> <span class="n">pattern</span> <span class="n">'&lt;-'</span> <span class="n">expression</span><span class="p">;</span>
</code></pre></div></div>

<p>if we otherwise stick with current Erlang, or</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">generator</span><span class="p">:</span> <span class="n">term_generator</span> <span class="p">|</span> <span class="n">binary_generator</span><span class="p">;</span>
<span class="nn">binary_generator</span><span class="p">:</span> <span class="n">pattern</span> <span class="n">'&lt;='</span> <span class="n">expression</span>
                <span class="p">|</span> <span class="n">pattern</span> <span class="n">'&lt;&lt;'</span> <span class="n">'&lt;-'</span> <span class="n">'&gt;&gt;'</span> <span class="n">expression</span><span class="p">;</span>
<span class="nn">term_generator</span><span class="p">:</span> <span class="n">term_generator</span> <span class="n">'&amp;&amp;'</span> <span class="n">term_generator</span>
              <span class="p">|</span> <span class="n">pattern</span> <span class="n">'&lt;-'</span> <span class="n">expression</span>
              <span class="p">|</span> <span class="n">pattern</span> <span class="n">'['</span> <span class="n">'&lt;-'</span> <span class="n">']'</span> <span class="n">expression</span>
              <span class="p">|</span> <span class="n">pattern</span> <span class="n">'{'</span> <span class="n">'&lt;-'</span> <span class="n">'}'</span> <span class="n">expression</span><span class="p">;</span>
</code></pre></div></div>

<p>if we go with <a href="eep-0012.md" title="EEP 12">EEP 12</a>.</p>

<p>Roughly speaking, ignoring errors and side effects,
the effect of <code class="language-plaintext highlighter-rouge">P1 &lt;- E1 &amp;&amp; ... Pn &lt;- En</code>
is the effect of <code class="language-plaintext highlighter-rouge">{P1,...,Pn} &lt;- zip(E1, ..., En)</code>
where</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">zip</span><span class="p">([</span><span class="nv">X1</span><span class="p">|</span><span class="nv">Xs1</span><span class="p">],</span> <span class="p">...,</span> <span class="p">[</span><span class="nv">Xn</span><span class="p">|</span><span class="nv">Xsn</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="p">[{</span><span class="nv">X1</span><span class="p">,...,</span><span class="nv">Xn</span><span class="p">}</span> <span class="p">|</span> <span class="nf">zip</span><span class="p">(</span><span class="nv">Xs1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">Xsn</span><span class="p">)];</span>
<span class="nf">zip</span><span class="p">([],</span> <span class="p">...,</span> <span class="p">[])</span> <span class="o">-&gt;</span>
    <span class="p">[].</span>
</code></pre></div></div>

<p>However, it is expected that there will NOT be any extra list
or tuples created by the implementation; this specifies the
effect but NOT how it is to be implemented.</p>

<p>The effect of a term generator using the new notations of EEP 12
is that which would be obtained by first replacing</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">P</span> <span class="p">{</span><span class="o">&lt;-</span><span class="p">}</span> <span class="nv">E</span>   <span class="n">with</span>   <span class="nv">P</span> <span class="o">&lt;-</span> <span class="nb">tuple_to_list</span><span class="p">(</span><span class="nv">E</span><span class="p">)</span>
<span class="nv">P</span> <span class="p">[</span><span class="o">&lt;-</span><span class="p">]</span> <span class="nv">E</span>   <span class="n">with</span>   <span class="nv">P</span> <span class="o">&lt;-</span> <span class="nv">E</span>
</code></pre></div></div>

<p>and then applying the translation above.</p>

<p>In the presence of errors, the behaviour of &amp;&amp; is not precisely
the same as using zip.  We need to specify the actual behaviour
more precisely.  For brevity, I ignore binary enumeration.  Both
tuple enumeration and tuple comprehension are currently defined
by rewriting to plain list comprehension, so that’s all we need
to worry about for now.</p>

<p>A list comprehension has the form <code class="language-plaintext highlighter-rouge">[E || C1, ..., Cn]</code>
where each Ci is</p>

<ul>
  <li>a generator <code class="language-plaintext highlighter-rouge">Pattern &lt;- List_Expression</code></li>
  <li>a binding   <code class="language-plaintext highlighter-rouge">Pattern =  Any_Expression</code></li>
  <li>a “guard”   <code class="language-plaintext highlighter-rouge">Other_Expression</code> that should give true or false.</li>
</ul>

<p>This acts like</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">R</span> <span class="o">=</span> <span class="p">[],</span>
<span class="o">&lt;</span><span class="p">|</span> <span class="nv">E</span> <span class="p">||</span> <span class="p">[</span><span class="nv">C1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">Cn</span><span class="p">]</span> <span class="p">|</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">R</span><span class="p">),</span>
<span class="nf">reverse</span><span class="p">(</span><span class="nv">R</span><span class="p">)</span>
</code></pre></div></div>

<p>where</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="p">|</span> <span class="nv">E</span> <span class="p">||</span> <span class="p">[]</span> <span class="p">|</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">R</span><span class="p">)</span>
<span class="o">=&gt;</span>  <span class="nv">R</span> <span class="o">=</span> <span class="p">[</span><span class="nv">E</span> <span class="p">|</span> <span class="nv">R</span><span class="p">]</span>             <span class="c">% reassign R
</span>
<span class="o">&lt;</span><span class="p">|</span> <span class="nv">E</span> <span class="p">||</span> <span class="p">[</span><span class="nv">Pi</span> <span class="o">&lt;-</span> <span class="nv">Ei</span><span class="p">|</span><span class="nv">Cs</span><span class="p">]</span> <span class="p">|</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">R</span><span class="p">)</span>
<span class="o">=&gt;</span>  <span class="nv">Ti</span> <span class="o">=</span> <span class="nv">Ei</span>
    <span class="nv">Label</span><span class="p">:</span> <span class="k">case</span> <span class="nv">Ti</span>
             <span class="k">of</span> <span class="p">[</span><span class="nv">Pi</span><span class="p">|</span><span class="nv">X</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="nv">Ti</span> <span class="o">=</span> <span class="nv">X</span> <span class="c">% reassign Ti
</span>                          <span class="o">&lt;</span><span class="p">|</span> <span class="nv">E</span> <span class="p">||</span> <span class="nv">Cs</span> <span class="p">|</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">R</span><span class="p">)</span>
                          <span class="n">goto</span> <span class="nv">Label</span>
              <span class="p">;</span> <span class="p">[_</span> <span class="p">|</span><span class="nv">X</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="nv">Ti</span> <span class="o">=</span> <span class="nv">X</span> <span class="c">% reassign Ti
</span>                          <span class="n">goto</span> <span class="nv">Label</span>
              <span class="p">;</span> <span class="p">[]</span>     <span class="o">-&gt;</span> <span class="n">ok</span>                              
           <span class="k">end</span>

<span class="o">&lt;</span><span class="p">|</span> <span class="nv">E</span> <span class="p">||</span> <span class="p">[</span><span class="nv">Pi</span> <span class="o">=</span> <span class="nv">Ei</span><span class="p">|</span><span class="nv">Cs</span><span class="p">]</span> <span class="p">|</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">R</span><span class="p">)</span>
<span class="o">=&gt;</span>  <span class="k">case</span> <span class="nv">Ei</span>
      <span class="k">of</span> <span class="nv">Pi</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="p">|</span> <span class="nv">E</span> <span class="p">||</span> <span class="nv">Cs</span> <span class="p">|</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">R</span><span class="p">)</span>
       <span class="p">;</span> <span class="p">_</span>  <span class="o">-&gt;</span> <span class="n">ok</span>
    <span class="k">end</span>

<span class="o">&lt;</span><span class="p">|</span> <span class="nv">E</span> <span class="p">||</span> <span class="p">[</span><span class="nv">Ei</span><span class="p">|</span><span class="nv">Cs</span><span class="p">]</span> <span class="p">|</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">R</span><span class="p">)</span>
<span class="o">=&gt;</span>  <span class="k">case</span> <span class="nv">Ei</span>
      <span class="k">of</span> <span class="n">true</span>  <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="p">|</span> <span class="nv">E</span> <span class="p">||</span> <span class="nv">Cs</span> <span class="p">|</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">R</span><span class="p">)</span>
       <span class="p">;</span> <span class="n">false</span> <span class="o">-&gt;</span> <span class="n">ok</span>
    <span class="k">end</span>

</code></pre></div></div>
<p>In these translations, pattern matching syntax is used, with the
intent that the variables which are unbound according to the
normal rules of Erlang, and thus get bound by the Pi &lt;- or Pi =
matching, are treated <em>as if</em> unbound in the code to be generated,
ignoring whatever values they might previous have had.  That also
applies when R or Ti appears on the left of a pattern match; the
fact that the variable really was bound is ignored and a simple
assignment is done.</p>

<p>This does involve (re-)assignment to local variables in the code
to be generated, but it does NOT involve user-visible assignment
and it does NOT involve mutable data structures.  It is no more
problematic for the language or the runtime system than reusing a
dead register is.</p>

<p>Handling multi-list enumeration is a simple, albeit schematic,
change to the rule for enumeration.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="p">|</span> <span class="nv">E</span> <span class="p">||</span> <span class="p">[</span><span class="nv">Pi1</span> <span class="o">&lt;-</span> <span class="nv">Ei1</span> <span class="err">&amp;&amp;</span> <span class="nv">Pi2</span> <span class="o">&lt;-</span> <span class="nv">Ei2</span> <span class="err">&amp;&amp;</span> <span class="p">...</span> <span class="err">&amp;&amp;</span> <span class="nv">Pik</span> <span class="o">&lt;-</span> <span class="nv">Eik</span><span class="p">|</span><span class="nv">Cs</span><span class="p">]</span> <span class="p">|</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">R</span><span class="p">)</span>
<span class="o">=&gt;</span>  <span class="nv">Ti1</span> <span class="o">=</span> <span class="nv">Ei1</span>
    <span class="p">...</span>
    <span class="nv">Tik</span> <span class="o">=</span> <span class="nv">Eik</span>
    <span class="nv">Label</span><span class="p">:</span> <span class="k">case</span> <span class="p">{</span><span class="nv">Ti1</span><span class="p">,...,</span><span class="nv">Tik</span><span class="p">}</span>
             <span class="k">of</span> <span class="p">{[</span><span class="nv">Pi1</span><span class="p">|</span><span class="nv">X1</span><span class="p">],</span> <span class="p">...,</span> <span class="p">[</span><span class="nv">Pik</span><span class="p">,</span><span class="nv">Xk</span><span class="p">]}</span> <span class="o">-&gt;</span>
                <span class="nv">Ti1</span> <span class="o">=</span> <span class="nv">X1</span>    <span class="c">% reassign
</span>                <span class="p">...</span>
                <span class="nv">Tik</span> <span class="o">=</span> <span class="nv">Xk</span>    <span class="c">% reassign
</span>                <span class="o">&lt;</span><span class="p">|</span> <span class="nv">E</span> <span class="p">||</span> <span class="nv">Cs</span> <span class="p">|</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">R</span><span class="p">)</span>
                <span class="n">goto</span> <span class="n">label</span>
              <span class="p">;</span> <span class="p">{[_|</span><span class="nv">X1</span><span class="p">],</span> <span class="p">...,</span> <span class="p">[_|</span><span class="nv">Xk</span><span class="p">]}</span> <span class="o">-&gt;</span>
                <span class="nv">Ti1</span> <span class="o">=</span> <span class="nv">X1</span>    <span class="c">% reassign
</span>                <span class="p">...</span>
                <span class="nv">Tik</span> <span class="o">=</span> <span class="nv">Xk</span>    <span class="c">% reassign
</span>              <span class="p">;</span> <span class="p">{[],</span> <span class="p">...,</span> <span class="p">[]}</span> <span class="o">-&gt;</span>
                <span class="n">ok</span>
           <span class="k">end</span>

</code></pre></div></div>
<p>Note that the use of tuple syntax in the case expression and the
case clauses does not imply the literal creation of a tuple in
the generated code, only that k values are to be matched against
k patterns in each case clause.</p>

<h1 id="motivation">Motivation</h1>

<p>“How do I iterate over several lists at once?” is a moderately
common question from Erlang and Haskell beginners.  The stock
answer, “use zip”, is almost tolerable for Haskell, where the
the zipping family goes up to 7 lists and the compiler works
hard to eliminate the intermediate data structures by using
deforestation.  For Erlang, where even zip4 is missing, and
where the apparent cost of creating the unwanted list and
tuples is all too real, the fact that the use of zips makes
the code harder to read means that there is no good to
outweigh the bad.</p>

<p>With the new notation,</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">zip4</span><span class="p">(</span><span class="nv">As</span><span class="p">,</span> <span class="nv">Bs</span><span class="p">,</span> <span class="nv">Cs</span><span class="p">,</span> <span class="nv">Ds</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[{</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">D</span><span class="p">}</span> <span class="p">||</span> <span class="nv">A</span> <span class="o">&lt;-</span> <span class="nv">As</span> <span class="err">&amp;&amp;</span> <span class="nv">B</span> <span class="o">&lt;-</span> <span class="nv">Bs</span> <span class="err">&amp;&amp;</span> <span class="nv">C</span> <span class="o">&lt;-</span> <span class="nv">Cs</span> <span class="err">&amp;&amp;</span> <span class="nv">D</span> <span class="o">&lt;-</span> <span class="nv">Ds</span><span class="p">].</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">zipwith4</span><span class="p">(</span><span class="nv">F</span><span class="p">,</span> <span class="nv">As</span><span class="p">,</span> <span class="nv">Bs</span><span class="p">,</span> <span class="nv">Cs</span><span class="p">,</span> <span class="nv">Ds</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="nv">F</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">D</span><span class="p">)</span> <span class="p">||</span> <span class="nv">A</span> <span class="o">&lt;-</span> <span class="nv">As</span> <span class="err">&amp;&amp;</span> <span class="nv">B</span> <span class="o">&lt;-</span> <span class="nv">Bs</span> <span class="err">&amp;&amp;</span> <span class="nv">C</span> <span class="o">&lt;-</span> <span class="nv">Cs</span> <span class="err">&amp;&amp;</span> <span class="nv">D</span> <span class="o">&lt;-</span> <span class="nv">Ds</span><span class="p">].</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">dot</span><span class="p">(</span><span class="nv">Xs</span><span class="p">,</span> <span class="nv">Ys</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nf">sum</span><span class="p">([</span><span class="nv">X</span><span class="o">*</span><span class="nv">Y</span> <span class="p">||</span> <span class="nv">X</span> <span class="o">&lt;-</span> <span class="nv">Xs</span> <span class="err">&amp;&amp;</span> <span class="nv">Y</span> <span class="o">&lt;-</span> <span class="nv">Ys</span><span class="p">]).</span>
</code></pre></div></div>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">ifelse</span><span class="p">(</span><span class="nv">Tests</span><span class="p">,</span> <span class="nv">Xs</span><span class="p">,</span> <span class="nv">Ys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="c">% Simulate R's ifelse(,,)
</span>    <span class="p">[</span>  <span class="k">case</span> <span class="nv">T</span> <span class="k">of</span> <span class="n">true</span> <span class="o">-&gt;</span> <span class="nv">X</span> <span class="p">;</span> <span class="n">false</span> <span class="o">-&gt;</span> <span class="nv">Y</span> <span class="k">end</span>
    <span class="p">||</span> <span class="nv">T</span> <span class="o">&lt;-</span> <span class="nv">Tests</span> <span class="err">&amp;&amp;</span> <span class="nv">X</span> <span class="o">&lt;-</span> <span class="nv">Xs</span> <span class="err">&amp;&amp;</span> <span class="nv">Y</span> <span class="o">&lt;-</span> <span class="nv">Ys</span>
    <span class="p">].</span>
</code></pre></div></div>

<p>This code from module <code class="language-plaintext highlighter-rouge">dialyzer_dep</code></p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">merge_outs</span><span class="p">([</span><span class="nl">#output</span><span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">list</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="nv">L1</span><span class="p">}|</span><span class="nv">Left</span><span class="p">],</span>
           <span class="nl">#output</span><span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">list</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="nv">L2</span><span class="p">})</span> <span class="o">-&gt;</span>
  <span class="nv">NewList</span> <span class="o">=</span> <span class="p">[</span><span class="nf">merge_outs</span><span class="p">([</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">])</span> <span class="p">||</span> <span class="p">{</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="nn">lists</span><span class="p">:</span><span class="nf">zip</span><span class="p">(</span><span class="nv">L1</span><span class="p">,</span> <span class="nv">L2</span><span class="p">)],</span>
  <span class="nf">merge_outs</span><span class="p">(</span><span class="nv">Left</span><span class="p">,</span> <span class="nf">output</span><span class="p">(</span><span class="nv">NewList</span><span class="p">));</span>
</code></pre></div></div>

<p>would become</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">merge_outs</span><span class="p">([</span><span class="nl">#output</span><span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">list</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="nv">L1</span><span class="p">}|</span><span class="nv">Left</span><span class="p">],</span>
            <span class="nl">#output</span><span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">list</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="nv">L2</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="nf">merge_outs</span><span class="p">(</span><span class="nv">Left</span><span class="p">,</span> <span class="nf">output</span><span class="p">(</span>
        <span class="p">[</span><span class="nf">merge_outs</span><span class="p">([</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">])</span> <span class="p">||</span> <span class="nv">X</span> <span class="o">&lt;-</span> <span class="nv">L1</span> <span class="err">&amp;&amp;</span> <span class="nv">Y</span> <span class="o">&lt;-</span> <span class="nv">L2</span><span class="p">]));</span>
</code></pre></div></div>

<p>This code from <code class="language-plaintext highlighter-rouge">forward_args/3</code> in module <code class="language-plaintext highlighter-rouge">dialyzer_dataflow</code></p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">NewArgTypes</span> <span class="o">=</span> <span class="p">[</span><span class="nf">t_sup</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">||</span>
               <span class="p">{</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="nn">lists</span><span class="p">:</span><span class="nf">zip</span><span class="p">(</span><span class="nv">ArgTypes</span><span class="p">,</span> <span class="nv">OldArgTypes</span><span class="p">)],</span>
</code></pre></div></div>

<p>would become</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">NewArgTypes</span> <span class="o">=</span> <span class="p">[</span><span class="nf">t_sup</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">||</span> <span class="nv">X</span> <span class="o">&lt;-</span> <span class="nv">ArgTypes</span> <span class="err">&amp;&amp;</span> <span class="nv">Y</span> <span class="o">&lt;-</span> <span class="nv">OldArgTypes</span><span class="p">],</span>
</code></pre></div></div>

<h1 id="rationale">Rationale</h1>

<p>This is a case where no invention is required, really.
Clean has</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Qualifier</span> <span class="o">=</span> <span class="nv">Generators</span> <span class="p">{|</span><span class="nv">Guard</span><span class="p">}</span>
<span class="nv">Generators</span> <span class="o">=</span> <span class="p">{</span><span class="nv">Generator</span><span class="p">}</span><span class="o">-</span><span class="n">list</span>
           <span class="p">|</span> <span class="nv">Generator</span> <span class="p">{</span><span class="err">&amp;</span> <span class="nv">Generator</span><span class="p">}</span>
<span class="nv">Generator</span> <span class="o">=</span> <span class="nv">Selector</span> <span class="o">&lt;-</span> <span class="nv">ListExpr</span> <span class="o">//</span> <span class="n">lazy</span> <span class="n">list</span>
          <span class="p">|</span> <span class="nv">Selector</span> <span class="o">&lt;</span><span class="p">|</span><span class="o">-</span> <span class="nv">ListExpr</span> <span class="o">//</span> <span class="n">overloaded</span> <span class="n">list</span>
          <span class="p">|</span> <span class="nv">Selector</span> <span class="o">&lt;-</span><span class="p">:</span> <span class="nv">ArrayExpr</span> <span class="o">//</span>  <span class="n">array</span>
</code></pre></div></div>

<p>All I have to do is bend this a little to fit it into Erlang
syntax.  Since we use “||” for list comprehensions, “&amp;&amp;” was
the obvious spelling for generators that step together.</p>

<p>I do not yet understand in detail what the Erlang compiler
does, but it seems to involve generating an auxiliary function.
Let’s take</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">||</span> <span class="nv">X</span> <span class="o">&lt;-</span> <span class="nv">Xs</span><span class="p">,</span> <span class="nv">X</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<p>as an example.  This seems to be compiled as</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">foo</span><span class="p">(</span><span class="nv">Xs</span><span class="p">)</span>
</code></pre></div></div>

<p>where</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">foo</span><span class="p">([</span><span class="nv">X</span><span class="p">|</span><span class="nv">Xs</span><span class="p">])</span> <span class="k">when</span> <span class="nv">X</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">|</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">Xs</span><span class="p">)];</span>
<span class="nf">foo</span><span class="p">([_|</span><span class="nv">Xs</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">Xs</span><span class="p">);</span>
<span class="nf">foo</span><span class="p">([])</span> <span class="o">-&gt;</span> <span class="p">[].</span>
</code></pre></div></div>

<p>With a multi-sequence generator, the translation is similar.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">g</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">||</span> <span class="nv">X</span> <span class="o">&lt;-</span> <span class="nv">Xs</span> <span class="err">&amp;&amp;</span> <span class="nv">Y</span> <span class="o">&lt;-</span> <span class="nv">Ys</span><span class="p">,</span> <span class="nv">X</span> <span class="o">&gt;</span> <span class="nv">Y</span><span class="p">]</span>
</code></pre></div></div>

<p>can be compiled as</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">bar</span><span class="p">(</span><span class="nv">Xs</span><span class="p">,</span> <span class="nv">Ys</span><span class="p">)</span>
</code></pre></div></div>

<p>where</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">bar</span><span class="p">([</span><span class="nv">X</span><span class="p">|</span><span class="nv">Xs</span><span class="p">],</span> <span class="p">[</span><span class="nv">Y</span><span class="p">|</span><span class="nv">Ys</span><span class="p">])</span> <span class="k">when</span> <span class="nv">X</span> <span class="o">&gt;</span> <span class="nv">Y</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="nf">g</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">|</span> <span class="nf">bar</span><span class="p">(</span><span class="nv">Xs</span><span class="p">,</span> <span class="nv">Ys</span><span class="p">)];</span>
<span class="nf">bar</span><span class="p">([_|</span><span class="nv">Xs</span><span class="p">],</span> <span class="p">[_|</span><span class="nv">Ys</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nf">bar</span><span class="p">(</span><span class="nv">Xs</span><span class="p">,</span> <span class="nv">Ys</span><span class="p">);</span>
<span class="nf">bar</span><span class="p">([],</span> <span class="p">[])</span> <span class="o">-&gt;</span> <span class="p">[].</span>
</code></pre></div></div>

<p>The specification above gives the kind of translation I would like
to see; I do have an implementation in mind (based on Pop-2) that
doesn’t need the reversal but don’t know how it would fit in BEAM.</p>

<p>One obvious question is whether we need this at all.  Why not just
get people to write calls to <code class="language-plaintext highlighter-rouge">lists:zip</code> and get the compiler to
optimise them?  One answer is that this notation is much clearer;
the programmer’s <em>intent</em> is to advance along two or more lists
at the same time, not to create a list of pairs.  When you want to
create a list of pairs, <code class="language-plaintext highlighter-rouge">lists:zip/2</code> is the perfect way to do it.
A more important answer is that the proposed notation is NOT a
simple optimisation of equivalent code using <code class="language-plaintext highlighter-rouge">lists:zip/2</code>.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nv">E</span> <span class="p">||</span> <span class="p">{</span><span class="nv">P</span><span class="p">,</span><span class="nv">Q</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="nn">lists</span><span class="p">:</span><span class="nf">zip</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">)]</span>    <span class="c">% "zip version"
</span></code></pre></div></div>

<p>fails at once if A and B are not proper lists of the same length.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nv">E</span> <span class="p">||</span> <span class="nv">P</span> <span class="o">&lt;-</span> <span class="nv">A</span> <span class="err">&amp;&amp;</span> <span class="nv">Q</span> <span class="o">&lt;-</span> <span class="nv">B</span><span class="p">]</span>            <span class="c">% "Clean version"
</span></code></pre></div></div>

<p>eventually fails if A and B are not proper lists of the same
length, but may have evaluated E (which may have had side effects)
many times before that.  So an Erlang compiler would not be
allowed to replace the “zip version” by the “Clean version” unless
it could prove both that A and B were lists (which may be within
the abilities of the Dialyzer) and that they were exactly the same
length (which as far as I know isn’t).</p>

<p>However, a multi-sequence generator and a single-sequence one
using calls to <code class="language-plaintext highlighter-rouge">lists:zip/2</code> are clearly <em>similar</em>, so they should
eventually react to lists of different length the same way.
In Haskell, zipping two lists of different length acts as if the
longer were truncated to the length of the shorter.  Since
Haskell has lazy evaluation, lists may be infinite, so you can’t
afford to wait until the end to start a comprehension.  Since
Erlang is strict, and since mistakes are common, <code class="language-plaintext highlighter-rouge">lists:zip/2</code> in
Erlang makes sense as it is.</p>

<h1 id="backwards-compatibility">Backwards Compatibility</h1>

<p>The “operator” ‘&amp;&amp;’ is not legal syntax anywhere in Erlang
at the moment, so no existing code can be affected.</p>

<h1 id="reference-implementation">Reference Implementation</h1>

<p>None yet, but I’d like to do it when I can figure out how.</p>

<h1 id="copyright">Copyright</h1>

<p>This document has been placed in the public domain.
[EmacsVar]: &lt;&gt; “Local Variables:”
[EmacsVar]: &lt;&gt; “mode: indented-text”
[EmacsVar]: &lt;&gt; “indent-tabs-mode: nil”
[EmacsVar]: &lt;&gt; “sentence-end-double-space: t”
[EmacsVar]: &lt;&gt; “fill-column: 70”
[EmacsVar]: &lt;&gt; “coding: utf-8”
[EmacsVar]: &lt;&gt; “End:”</p>

            </div>
        </div>
    </div>
</div>
<script src="/erlang-org/assets/js/prismjs/prism.js"></script>
<script src="/erlang-org/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/erlang-org/downloads.html" title="DOWNLOAD"><img src="/erlang-org/assets/img/download.png"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/erlang-org/assets/img/GitHub-Mark-32px.png"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/erlang-org/assets/img/twitter.png"
                    width="32"></a>
        </div>
    </footer>
    <script src="/erlang-org/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>